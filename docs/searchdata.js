var SearchFiles = ["GUID-81A73CB2-02C0-41CF-9C28-0AECE56FFF26.html",
							"GUID-97853572-2DF9-4BDC-8CC2-427931EE96D9.html",
							"GUID-261B02C6-E685-4C12-8EB7-5E717F054F60.html",
							"GUID-173A4FCA-4C46-47BE-BCDA-0159C4CF2505.html",
							"GUID-C6935B6F-3F19-4CEE-AE52-998913858742.html",
							"GUID-F3B4D4E5-0BE3-42AB-8080-D04E58F54789.html",
							"GUID-98F10C10-D69B-45C3-A273-F3488B67B1A3.html",
							"GUID-3FE78AB9-5672-4748-BEEE-ADD364C8774A.html",
							"GUID-3FE78AB9-5672-4748-BEEE-ADD364C8774A.html",
							"GUID-3FE78AB9-5672-4748-BEEE-ADD364C8774A.html",
							"GUID-3FE78AB9-5672-4748-BEEE-ADD364C8774A.html",
							"GUID-3FE78AB9-5672-4748-BEEE-ADD364C8774A.html",
							"GUID-3FE78AB9-5672-4748-BEEE-ADD364C8774A.html",
							"GUID-3FE78AB9-5672-4748-BEEE-ADD364C8774A.html",
							"GUID-3FE78AB9-5672-4748-BEEE-ADD364C8774A.html",
							"GUID-CC7037AE-6A1F-4EAF-894A-9588EEF3BEAD.html",
							"GUID-CC7037AE-6A1F-4EAF-894A-9588EEF3BEAD.html",
							"GUID-CC7037AE-6A1F-4EAF-894A-9588EEF3BEAD.html",
							"GUID-CC7037AE-6A1F-4EAF-894A-9588EEF3BEAD.html",
							"GUID-CC7037AE-6A1F-4EAF-894A-9588EEF3BEAD.html",
							"GUID-CC7037AE-6A1F-4EAF-894A-9588EEF3BEAD.html",
							"GUID-CC7037AE-6A1F-4EAF-894A-9588EEF3BEAD.html",
							"GUID-CC7037AE-6A1F-4EAF-894A-9588EEF3BEAD.html",
							"GUID-CC7037AE-6A1F-4EAF-894A-9588EEF3BEAD.html",
							"GUID-CC2FC1BB-40F6-41C6-9676-40E1BA7DB412.html",
							"GUID-CC2FC1BB-40F6-41C6-9676-40E1BA7DB412.html",
							"GUID-CC2FC1BB-40F6-41C6-9676-40E1BA7DB412.html",
							"GUID-CC2FC1BB-40F6-41C6-9676-40E1BA7DB412.html",
							"GUID-CC2FC1BB-40F6-41C6-9676-40E1BA7DB412.html",
							"GUID-CC2FC1BB-40F6-41C6-9676-40E1BA7DB412.html",
							"GUID-CC2FC1BB-40F6-41C6-9676-40E1BA7DB412.html",
							"GUID-CC2FC1BB-40F6-41C6-9676-40E1BA7DB412.html",
							"GUID-CC2FC1BB-40F6-41C6-9676-40E1BA7DB412.html",
							"GUID-EB2FF372-3E82-4F17-8A72-E36EFEFD1B6A.html",
							"GUID-EB2FF372-3E82-4F17-8A72-E36EFEFD1B6A.html",
							"GUID-EB2FF372-3E82-4F17-8A72-E36EFEFD1B6A.html",
							"GUID-EB2FF372-3E82-4F17-8A72-E36EFEFD1B6A.html",
							"GUID-EB2FF372-3E82-4F17-8A72-E36EFEFD1B6A.html",
							"GUID-EB2FF372-3E82-4F17-8A72-E36EFEFD1B6A.html",
							"GUID-EB2FF372-3E82-4F17-8A72-E36EFEFD1B6A.html",
							"GUID-EB2FF372-3E82-4F17-8A72-E36EFEFD1B6A.html",
							"GUID-51BE7E9A-45DF-4673-9AE2-7D7163536E44.html",
							"GUID-51BE7E9A-45DF-4673-9AE2-7D7163536E44.html",
							"GUID-51BE7E9A-45DF-4673-9AE2-7D7163536E44.html",
							"GUID-51BE7E9A-45DF-4673-9AE2-7D7163536E44.html",
							"GUID-51BE7E9A-45DF-4673-9AE2-7D7163536E44.html",
							"GUID-51BE7E9A-45DF-4673-9AE2-7D7163536E44.html",
							"GUID-51BE7E9A-45DF-4673-9AE2-7D7163536E44.html",
							"GUID-51BE7E9A-45DF-4673-9AE2-7D7163536E44.html",
							"GUID-51BE7E9A-45DF-4673-9AE2-7D7163536E44.html",
							"GUID-01855CB4-57E8-4BE3-A093-14CBFFAABD51.html",
							"GUID-01855CB4-57E8-4BE3-A093-14CBFFAABD51.html",
							"GUID-01855CB4-57E8-4BE3-A093-14CBFFAABD51.html",
							"GUID-01855CB4-57E8-4BE3-A093-14CBFFAABD51.html",
							"GUID-01855CB4-57E8-4BE3-A093-14CBFFAABD51.html",
							"GUID-01855CB4-57E8-4BE3-A093-14CBFFAABD51.html",
							"GUID-01855CB4-57E8-4BE3-A093-14CBFFAABD51.html",
							"GUID-01855CB4-57E8-4BE3-A093-14CBFFAABD51.html",
							"GUID-01855CB4-57E8-4BE3-A093-14CBFFAABD51.html",
							"GUID-8E175C09-6CD6-4846-A1D3-C49B7CB583E6.html",
							"GUID-8E175C09-6CD6-4846-A1D3-C49B7CB583E6.html",
							"GUID-8E175C09-6CD6-4846-A1D3-C49B7CB583E6.html",
							"GUID-8E175C09-6CD6-4846-A1D3-C49B7CB583E6.html",
							"GUID-8E175C09-6CD6-4846-A1D3-C49B7CB583E6.html",
							"GUID-8E175C09-6CD6-4846-A1D3-C49B7CB583E6.html",
							"GUID-8E175C09-6CD6-4846-A1D3-C49B7CB583E6.html",
							"GUID-8E175C09-6CD6-4846-A1D3-C49B7CB583E6.html",
							"GUID-8E175C09-6CD6-4846-A1D3-C49B7CB583E6.html",
							"GUID-D33A9EC1-6EB5-4EB8-820A-BF8B6AFAC54D.html",
							"GUID-D33A9EC1-6EB5-4EB8-820A-BF8B6AFAC54D.html",
							"GUID-D33A9EC1-6EB5-4EB8-820A-BF8B6AFAC54D.html",
							"GUID-D33A9EC1-6EB5-4EB8-820A-BF8B6AFAC54D.html",
							"GUID-D33A9EC1-6EB5-4EB8-820A-BF8B6AFAC54D.html",
							"GUID-D33A9EC1-6EB5-4EB8-820A-BF8B6AFAC54D.html",
							"GUID-D33A9EC1-6EB5-4EB8-820A-BF8B6AFAC54D.html",
							"GUID-D33A9EC1-6EB5-4EB8-820A-BF8B6AFAC54D.html",
							"GUID-D33A9EC1-6EB5-4EB8-820A-BF8B6AFAC54D.html",
							"GUID-A48A9C4F-4251-4807-A3CB-FE22524FF8B1.html",
							"GUID-A48A9C4F-4251-4807-A3CB-FE22524FF8B1.html",
							"GUID-A48A9C4F-4251-4807-A3CB-FE22524FF8B1.html",
							"GUID-A48A9C4F-4251-4807-A3CB-FE22524FF8B1.html",
							"GUID-A48A9C4F-4251-4807-A3CB-FE22524FF8B1.html",
							"GUID-A48A9C4F-4251-4807-A3CB-FE22524FF8B1.html",
							"GUID-A48A9C4F-4251-4807-A3CB-FE22524FF8B1.html",
							"GUID-A48A9C4F-4251-4807-A3CB-FE22524FF8B1.html",
							"GUID-A48A9C4F-4251-4807-A3CB-FE22524FF8B1.html",
							"GUID-B7C7F0AD-BC60-40E7-AFBA-2B1E32343684.html",
							"GUID-B7C7F0AD-BC60-40E7-AFBA-2B1E32343684.html",
							"GUID-B7C7F0AD-BC60-40E7-AFBA-2B1E32343684.html",
							"GUID-B7C7F0AD-BC60-40E7-AFBA-2B1E32343684.html",
							"GUID-B7C7F0AD-BC60-40E7-AFBA-2B1E32343684.html",
							"GUID-B7C7F0AD-BC60-40E7-AFBA-2B1E32343684.html",
							"GUID-B7C7F0AD-BC60-40E7-AFBA-2B1E32343684.html",
							"GUID-B7C7F0AD-BC60-40E7-AFBA-2B1E32343684.html",
							"GUID-B7C7F0AD-BC60-40E7-AFBA-2B1E32343684.html",
							"GUID-CAC25733-1D0F-44AE-84B4-82D140523B79.html",
							"GUID-CAC25733-1D0F-44AE-84B4-82D140523B79.html",
							"GUID-CAC25733-1D0F-44AE-84B4-82D140523B79.html",
							"GUID-CAC25733-1D0F-44AE-84B4-82D140523B79.html",
							"GUID-CAC25733-1D0F-44AE-84B4-82D140523B79.html",
							"GUID-CAC25733-1D0F-44AE-84B4-82D140523B79.html",
							"GUID-CAC25733-1D0F-44AE-84B4-82D140523B79.html",
							"GUID-CAC25733-1D0F-44AE-84B4-82D140523B79.html",
							"GUID-CAC25733-1D0F-44AE-84B4-82D140523B79.html",
							"GUID-E1673D08-316E-42AF-A8D8-9B2D3E9DABCE.html",
							"GUID-E1673D08-316E-42AF-A8D8-9B2D3E9DABCE.html",
							"GUID-E1673D08-316E-42AF-A8D8-9B2D3E9DABCE.html",
							"GUID-E1673D08-316E-42AF-A8D8-9B2D3E9DABCE.html",
							"GUID-E1673D08-316E-42AF-A8D8-9B2D3E9DABCE.html",
							"GUID-E1673D08-316E-42AF-A8D8-9B2D3E9DABCE.html",
							"GUID-E1673D08-316E-42AF-A8D8-9B2D3E9DABCE.html",
							"GUID-E1673D08-316E-42AF-A8D8-9B2D3E9DABCE.html",
							"GUID-E1673D08-316E-42AF-A8D8-9B2D3E9DABCE.html",
							"GUID-D08B8E46-56BF-4AE9-996E-B096DE7CCBA5.html",
							"GUID-D08B8E46-56BF-4AE9-996E-B096DE7CCBA5.html",
							"GUID-D08B8E46-56BF-4AE9-996E-B096DE7CCBA5.html",
							"GUID-D08B8E46-56BF-4AE9-996E-B096DE7CCBA5.html",
							"GUID-D08B8E46-56BF-4AE9-996E-B096DE7CCBA5.html",
							"GUID-D08B8E46-56BF-4AE9-996E-B096DE7CCBA5.html",
							"GUID-D08B8E46-56BF-4AE9-996E-B096DE7CCBA5.html",
							"GUID-D08B8E46-56BF-4AE9-996E-B096DE7CCBA5.html",
							"GUID-D08B8E46-56BF-4AE9-996E-B096DE7CCBA5.html",
							"GUID-5DCB155E-01FF-4C75-9BB8-64521923327F.html",
							"GUID-5DCB155E-01FF-4C75-9BB8-64521923327F.html",
							"GUID-5DCB155E-01FF-4C75-9BB8-64521923327F.html",
							"GUID-5DCB155E-01FF-4C75-9BB8-64521923327F.html",
							"GUID-5DCB155E-01FF-4C75-9BB8-64521923327F.html",
							"GUID-5DCB155E-01FF-4C75-9BB8-64521923327F.html",
							"GUID-5DCB155E-01FF-4C75-9BB8-64521923327F.html",
							"GUID-5DCB155E-01FF-4C75-9BB8-64521923327F.html",
							"GUID-5DCB155E-01FF-4C75-9BB8-64521923327F.html",
							"GUID-800E7E2E-B682-4D22-8CFA-9820472A966B.html",
							"GUID-800E7E2E-B682-4D22-8CFA-9820472A966B.html",
							"GUID-800E7E2E-B682-4D22-8CFA-9820472A966B.html",
							"GUID-800E7E2E-B682-4D22-8CFA-9820472A966B.html",
							"GUID-800E7E2E-B682-4D22-8CFA-9820472A966B.html",
							"GUID-800E7E2E-B682-4D22-8CFA-9820472A966B.html",
							"GUID-800E7E2E-B682-4D22-8CFA-9820472A966B.html",
							"GUID-800E7E2E-B682-4D22-8CFA-9820472A966B.html",
							"GUID-800E7E2E-B682-4D22-8CFA-9820472A966B.html",
							"GUID-E467AA51-4BBE-4E17-A290-7C8C7B73AF9D.html",
							"GUID-E467AA51-4BBE-4E17-A290-7C8C7B73AF9D.html",
							"GUID-E467AA51-4BBE-4E17-A290-7C8C7B73AF9D.html",
							"GUID-E467AA51-4BBE-4E17-A290-7C8C7B73AF9D.html",
							"GUID-E467AA51-4BBE-4E17-A290-7C8C7B73AF9D.html",
							"GUID-559A006E-859E-45E8-BB5A-70CE63853872.html",
							"GUID-559A006E-859E-45E8-BB5A-70CE63853872.html",
							"GUID-559A006E-859E-45E8-BB5A-70CE63853872.html",
							"GUID-559A006E-859E-45E8-BB5A-70CE63853872.html",
							"GUID-559A006E-859E-45E8-BB5A-70CE63853872.html",
							"GUID-50946BC4-586A-4660-A918-D3CED116127A.html",
							"GUID-50946BC4-586A-4660-A918-D3CED116127A.html",
							"GUID-50946BC4-586A-4660-A918-D3CED116127A.html",
							"GUID-50946BC4-586A-4660-A918-D3CED116127A.html",
							"GUID-50946BC4-586A-4660-A918-D3CED116127A.html",
							"GUID-725B3EE4-66DB-443D-BFAF-6BAE2C541655.html",
							"GUID-725B3EE4-66DB-443D-BFAF-6BAE2C541655.html",
							"GUID-725B3EE4-66DB-443D-BFAF-6BAE2C541655.html",
							"GUID-725B3EE4-66DB-443D-BFAF-6BAE2C541655.html",
							"GUID-725B3EE4-66DB-443D-BFAF-6BAE2C541655.html",
							"GUID-725B3EE4-66DB-443D-BFAF-6BAE2C541655.html",
							"GUID-725B3EE4-66DB-443D-BFAF-6BAE2C541655.html",
							"GUID-725B3EE4-66DB-443D-BFAF-6BAE2C541655.html",
							"GUID-D7A3C017-0DC8-473F-93D5-E5FF0507B1BA.html",
							"GUID-D7A3C017-0DC8-473F-93D5-E5FF0507B1BA.html",
							"GUID-D7A3C017-0DC8-473F-93D5-E5FF0507B1BA.html",
							"GUID-D7A3C017-0DC8-473F-93D5-E5FF0507B1BA.html",
							"GUID-D7A3C017-0DC8-473F-93D5-E5FF0507B1BA.html",
							"GUID-D7A3C017-0DC8-473F-93D5-E5FF0507B1BA.html",
							"GUID-D7A3C017-0DC8-473F-93D5-E5FF0507B1BA.html",
							"GUID-D7A3C017-0DC8-473F-93D5-E5FF0507B1BA.html",
							"GUID-9D9C46CF-4296-4502-B64F-9115B5A9C08B.html",
							"GUID-9D9C46CF-4296-4502-B64F-9115B5A9C08B.html",
							"GUID-9D9C46CF-4296-4502-B64F-9115B5A9C08B.html",
							"GUID-9D9C46CF-4296-4502-B64F-9115B5A9C08B.html",
							"GUID-9D9C46CF-4296-4502-B64F-9115B5A9C08B.html",
							"GUID-9D9C46CF-4296-4502-B64F-9115B5A9C08B.html",
							"GUID-9D9C46CF-4296-4502-B64F-9115B5A9C08B.html",
							"GUID-9D9C46CF-4296-4502-B64F-9115B5A9C08B.html",
							"GUID-E34B89AE-146E-4416-8D1D-5CD2075F5A80.html",
							"GUID-E34B89AE-146E-4416-8D1D-5CD2075F5A80.html",
							"GUID-E34B89AE-146E-4416-8D1D-5CD2075F5A80.html",
							"GUID-E34B89AE-146E-4416-8D1D-5CD2075F5A80.html",
							"GUID-E34B89AE-146E-4416-8D1D-5CD2075F5A80.html",
							"GUID-E34B89AE-146E-4416-8D1D-5CD2075F5A80.html",
							"GUID-E34B89AE-146E-4416-8D1D-5CD2075F5A80.html",
							"GUID-E34B89AE-146E-4416-8D1D-5CD2075F5A80.html",
							"GUID-DFD74282-E687-4256-A70B-A787486FF4B5.html",
							"GUID-DFD74282-E687-4256-A70B-A787486FF4B5.html",
							"GUID-DFD74282-E687-4256-A70B-A787486FF4B5.html",
							"GUID-DFD74282-E687-4256-A70B-A787486FF4B5.html",
							"GUID-12833367-18A3-4273-875A-63BBDDAEB68F.html",
							"GUID-FB84DD36-66A1-4AC7-8809-C528890A4B16.html",
							"GUID-FB84DD36-66A1-4AC7-8809-C528890A4B16.html",
							"GUID-FB84DD36-66A1-4AC7-8809-C528890A4B16.html",
							"GUID-FB84DD36-66A1-4AC7-8809-C528890A4B16.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-D271D58D-4E8B-4AF0-B031-70E9C8E0D23F.html",
							"GUID-5DA261DF-FDDC-4A4D-9FB9-4001FF3036DD.html",
							"GUID-5DA261DF-FDDC-4A4D-9FB9-4001FF3036DD.html",
							"GUID-5DA261DF-FDDC-4A4D-9FB9-4001FF3036DD.html",
							"GUID-5DA261DF-FDDC-4A4D-9FB9-4001FF3036DD.html",
							"GUID-B89FD8FD-29D0-4A95-A949-4F22179558D0.html",
							"GUID-B89FD8FD-29D0-4A95-A949-4F22179558D0.html",
							"GUID-B89FD8FD-29D0-4A95-A949-4F22179558D0.html",
							"GUID-B89FD8FD-29D0-4A95-A949-4F22179558D0.html",
							"GUID-7BD82710-5BEA-4FEA-BF26-D2B0693F9B54.html",
							"GUID-7BD82710-5BEA-4FEA-BF26-D2B0693F9B54.html",
							"GUID-7BD82710-5BEA-4FEA-BF26-D2B0693F9B54.html",
							"GUID-7BD82710-5BEA-4FEA-BF26-D2B0693F9B54.html",
							"GUID-9F6DC912-C55A-4BCD-90FA-BC4CCACA9138.html",
							"GUID-9F6DC912-C55A-4BCD-90FA-BC4CCACA9138.html",
							"GUID-9F6DC912-C55A-4BCD-90FA-BC4CCACA9138.html",
							"GUID-9F6DC912-C55A-4BCD-90FA-BC4CCACA9138.html",
							"GUID-AF19D487-59D9-4D2F-AA35-E1583DDFB82D.html",
							"GUID-AF19D487-59D9-4D2F-AA35-E1583DDFB82D.html",
							"GUID-AF19D487-59D9-4D2F-AA35-E1583DDFB82D.html",
							"GUID-AF19D487-59D9-4D2F-AA35-E1583DDFB82D.html",
							"GUID-AF19D487-59D9-4D2F-AA35-E1583DDFB82D.html",
							"GUID-443BB1EE-2B22-45AB-AD80-E0011189606F.html",
							"GUID-443BB1EE-2B22-45AB-AD80-E0011189606F.html",
							"GUID-443BB1EE-2B22-45AB-AD80-E0011189606F.html",
							"GUID-443BB1EE-2B22-45AB-AD80-E0011189606F.html",
							"GUID-443BB1EE-2B22-45AB-AD80-E0011189606F.html",
							"GUID-C351E8B0-8A8B-4006-89E0-3DE133B33D5E.html",
							"GUID-C351E8B0-8A8B-4006-89E0-3DE133B33D5E.html",
							"GUID-C351E8B0-8A8B-4006-89E0-3DE133B33D5E.html",
							"GUID-C351E8B0-8A8B-4006-89E0-3DE133B33D5E.html",
							"GUID-C351E8B0-8A8B-4006-89E0-3DE133B33D5E.html",
							"GUID-F65CE03F-4B50-4092-AB96-CA7DE388B46B.html",
							"GUID-F65CE03F-4B50-4092-AB96-CA7DE388B46B.html",
							"GUID-F65CE03F-4B50-4092-AB96-CA7DE388B46B.html",
							"GUID-F65CE03F-4B50-4092-AB96-CA7DE388B46B.html",
							"GUID-F65CE03F-4B50-4092-AB96-CA7DE388B46B.html",
							"GUID-EE53EE94-8EDB-4740-AE6B-F8C1E3277BC5.html",
							"GUID-EE53EE94-8EDB-4740-AE6B-F8C1E3277BC5.html",
							"GUID-EE53EE94-8EDB-4740-AE6B-F8C1E3277BC5.html",
							"GUID-EE53EE94-8EDB-4740-AE6B-F8C1E3277BC5.html",
							"GUID-EE53EE94-8EDB-4740-AE6B-F8C1E3277BC5.html",
							"GUID-3BCCA565-F529-442A-BE9B-324CCA7F2702.html",
							"GUID-3BCCA565-F529-442A-BE9B-324CCA7F2702.html",
							"GUID-3BCCA565-F529-442A-BE9B-324CCA7F2702.html",
							"GUID-3BCCA565-F529-442A-BE9B-324CCA7F2702.html",
							"GUID-3BCCA565-F529-442A-BE9B-324CCA7F2702.html",
							"GUID-AF884BA6-67E5-4927-8D31-B1F196BE22BD.html",
							"GUID-35725EB2-BDEE-4B6A-B204-9B892470097A.html",
							"GUID-35725EB2-BDEE-4B6A-B204-9B892470097A.html",
							"GUID-35725EB2-BDEE-4B6A-B204-9B892470097A.html",
							"GUID-35725EB2-BDEE-4B6A-B204-9B892470097A.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-C7DD098A-D23F-4DFD-BE53-74C297670599.html",
							"GUID-FF6556EE-43F6-41E6-87E4-B10CBEA8DF12.html",
							"GUID-FF6556EE-43F6-41E6-87E4-B10CBEA8DF12.html",
							"GUID-FF6556EE-43F6-41E6-87E4-B10CBEA8DF12.html",
							"GUID-FF6556EE-43F6-41E6-87E4-B10CBEA8DF12.html",
							"GUID-C33C587B-747B-4FAB-9976-F27A7875D841.html",
							"GUID-C33C587B-747B-4FAB-9976-F27A7875D841.html",
							"GUID-C33C587B-747B-4FAB-9976-F27A7875D841.html",
							"GUID-C33C587B-747B-4FAB-9976-F27A7875D841.html",
							"GUID-CE36C238-4FFB-4E75-BF61-A16DEFE6C538.html",
							"GUID-CE36C238-4FFB-4E75-BF61-A16DEFE6C538.html",
							"GUID-CE36C238-4FFB-4E75-BF61-A16DEFE6C538.html",
							"GUID-CE36C238-4FFB-4E75-BF61-A16DEFE6C538.html",
							"GUID-D74B0E99-F889-4785-907E-AD92A06C9D2A.html",
							"GUID-D74B0E99-F889-4785-907E-AD92A06C9D2A.html",
							"GUID-D74B0E99-F889-4785-907E-AD92A06C9D2A.html",
							"GUID-D74B0E99-F889-4785-907E-AD92A06C9D2A.html",
							"GUID-610A01D5-B3B5-43BF-968F-EB6B6BE00373.html",
							"GUID-610A01D5-B3B5-43BF-968F-EB6B6BE00373.html",
							"GUID-610A01D5-B3B5-43BF-968F-EB6B6BE00373.html",
							"GUID-610A01D5-B3B5-43BF-968F-EB6B6BE00373.html",
							"GUID-BE95F15B-2EE5-4955-A737-8EACFC145E48.html",
							"GUID-BE95F15B-2EE5-4955-A737-8EACFC145E48.html",
							"GUID-BE95F15B-2EE5-4955-A737-8EACFC145E48.html",
							"GUID-BE95F15B-2EE5-4955-A737-8EACFC145E48.html",
							"GUID-313FB4A6-7FAE-4AF5-AA07-CBD513967D27.html",
							"GUID-313FB4A6-7FAE-4AF5-AA07-CBD513967D27.html",
							"GUID-313FB4A6-7FAE-4AF5-AA07-CBD513967D27.html",
							"GUID-313FB4A6-7FAE-4AF5-AA07-CBD513967D27.html",
							"GUID-0D3D6A14-02C7-4AD3-B221-BC057153A38B.html",
							"GUID-0D3D6A14-02C7-4AD3-B221-BC057153A38B.html",
							"GUID-0D3D6A14-02C7-4AD3-B221-BC057153A38B.html",
							"GUID-0D3D6A14-02C7-4AD3-B221-BC057153A38B.html",
							"GUID-D6A8F4B2-ABF8-4BB2-B38F-28A4A20CA152.html",
							"GUID-D6A8F4B2-ABF8-4BB2-B38F-28A4A20CA152.html",
							"GUID-D6A8F4B2-ABF8-4BB2-B38F-28A4A20CA152.html",
							"GUID-D6A8F4B2-ABF8-4BB2-B38F-28A4A20CA152.html",
							"GUID-D6A8F4B2-ABF8-4BB2-B38F-28A4A20CA152.html",
							"GUID-D0C15B1D-39F9-4EE2-8C8E-E0D13695B096.html",
							"GUID-D0C15B1D-39F9-4EE2-8C8E-E0D13695B096.html",
							"GUID-D0C15B1D-39F9-4EE2-8C8E-E0D13695B096.html",
							"GUID-D0C15B1D-39F9-4EE2-8C8E-E0D13695B096.html",
							"GUID-D0C15B1D-39F9-4EE2-8C8E-E0D13695B096.html",
							"GUID-F9A46118-1365-4666-88F4-980A97C99850.html",
							"GUID-F9A46118-1365-4666-88F4-980A97C99850.html",
							"GUID-F9A46118-1365-4666-88F4-980A97C99850.html",
							"GUID-F9A46118-1365-4666-88F4-980A97C99850.html",
							"GUID-F9A46118-1365-4666-88F4-980A97C99850.html",
							"GUID-56CEDA9B-50C8-4747-8849-4C5E3FA88FF7.html",
							"GUID-56CEDA9B-50C8-4747-8849-4C5E3FA88FF7.html",
							"GUID-56CEDA9B-50C8-4747-8849-4C5E3FA88FF7.html",
							"GUID-56CEDA9B-50C8-4747-8849-4C5E3FA88FF7.html",
							"GUID-56CEDA9B-50C8-4747-8849-4C5E3FA88FF7.html",
							"GUID-A7685FE8-B336-4379-A26B-C821EBD7CD85.html",
							"GUID-93466C84-5C2E-4AA6-A8AB-812D804F9074.html",
							"GUID-3DCCAE10-97B3-4C66-89AA-0A031CE6814F.html",
							"GUID-EEC710D4-41F0-4CBF-88C6-9DDAF6BBE7E5.html",
							"GUID-D07D7626-C64B-4A08-A120-8F182086A3FF.html",
							"GUID-8D6705DB-D96A-4786-9724-F6B586F876B7.html",
							"GUID-8D6705DB-D96A-4786-9724-F6B586F876B7.html",
							"GUID-8D6705DB-D96A-4786-9724-F6B586F876B7.html",
							"GUID-8D6705DB-D96A-4786-9724-F6B586F876B7.html",
							"GUID-8D6705DB-D96A-4786-9724-F6B586F876B7.html",
							"GUID-8D6705DB-D96A-4786-9724-F6B586F876B7.html",
							"GUID-8D6705DB-D96A-4786-9724-F6B586F876B7.html",
							"GUID-8D6705DB-D96A-4786-9724-F6B586F876B7.html",
							"GUID-CFC0A3D7-6B3D-4D47-A061-7314346BFFCF.html",
							"GUID-CFC0A3D7-6B3D-4D47-A061-7314346BFFCF.html",
							"GUID-CFC0A3D7-6B3D-4D47-A061-7314346BFFCF.html",
							"GUID-CFC0A3D7-6B3D-4D47-A061-7314346BFFCF.html",
							"GUID-CFC0A3D7-6B3D-4D47-A061-7314346BFFCF.html",
							"GUID-CFC0A3D7-6B3D-4D47-A061-7314346BFFCF.html",
							"GUID-CFC0A3D7-6B3D-4D47-A061-7314346BFFCF.html",
							"GUID-CFC0A3D7-6B3D-4D47-A061-7314346BFFCF.html",
							"GUID-CFC0A3D7-6B3D-4D47-A061-7314346BFFCF.html",
							"GUID-ED53495E-E570-4FBC-9472-16BCF057AD77.html",
							"GUID-ED53495E-E570-4FBC-9472-16BCF057AD77.html",
							"GUID-ED53495E-E570-4FBC-9472-16BCF057AD77.html",
							"GUID-ED53495E-E570-4FBC-9472-16BCF057AD77.html",
							"GUID-ED53495E-E570-4FBC-9472-16BCF057AD77.html",
							"GUID-ED53495E-E570-4FBC-9472-16BCF057AD77.html",
							"GUID-ED53495E-E570-4FBC-9472-16BCF057AD77.html",
							"GUID-ED53495E-E570-4FBC-9472-16BCF057AD77.html",
							"GUID-ED53495E-E570-4FBC-9472-16BCF057AD77.html",
							"GUID-0C474247-A02D-4DAA-B7CA-976F25A16403.html",
							"GUID-0C474247-A02D-4DAA-B7CA-976F25A16403.html",
							"GUID-0C474247-A02D-4DAA-B7CA-976F25A16403.html",
							"GUID-0C474247-A02D-4DAA-B7CA-976F25A16403.html",
							"GUID-0C474247-A02D-4DAA-B7CA-976F25A16403.html",
							"GUID-0C474247-A02D-4DAA-B7CA-976F25A16403.html",
							"GUID-0C474247-A02D-4DAA-B7CA-976F25A16403.html",
							"GUID-0C474247-A02D-4DAA-B7CA-976F25A16403.html",
							"GUID-0C474247-A02D-4DAA-B7CA-976F25A16403.html",
							"GUID-39692EBF-C9ED-41F6-A1BB-52B76247E293.html",
							"GUID-39692EBF-C9ED-41F6-A1BB-52B76247E293.html",
							"GUID-39692EBF-C9ED-41F6-A1BB-52B76247E293.html",
							"GUID-39692EBF-C9ED-41F6-A1BB-52B76247E293.html",
							"GUID-39692EBF-C9ED-41F6-A1BB-52B76247E293.html",
							"GUID-39692EBF-C9ED-41F6-A1BB-52B76247E293.html",
							"GUID-39692EBF-C9ED-41F6-A1BB-52B76247E293.html",
							"GUID-39692EBF-C9ED-41F6-A1BB-52B76247E293.html",
							"GUID-39692EBF-C9ED-41F6-A1BB-52B76247E293.html",
							"GUID-C38AD3F4-CA6C-48DE-A6A1-28C18B778318.html",
							"GUID-C38AD3F4-CA6C-48DE-A6A1-28C18B778318.html",
							"GUID-C38AD3F4-CA6C-48DE-A6A1-28C18B778318.html",
							"GUID-C38AD3F4-CA6C-48DE-A6A1-28C18B778318.html",
							"GUID-C38AD3F4-CA6C-48DE-A6A1-28C18B778318.html",
							"GUID-C38AD3F4-CA6C-48DE-A6A1-28C18B778318.html",
							"GUID-C38AD3F4-CA6C-48DE-A6A1-28C18B778318.html",
							"GUID-C38AD3F4-CA6C-48DE-A6A1-28C18B778318.html",
							"GUID-C38AD3F4-CA6C-48DE-A6A1-28C18B778318.html",
							"GUID-F3DA568F-1791-4DD6-9397-5528439DEEEE.html",
							"GUID-F3DA568F-1791-4DD6-9397-5528439DEEEE.html",
							"GUID-F3DA568F-1791-4DD6-9397-5528439DEEEE.html",
							"GUID-F3DA568F-1791-4DD6-9397-5528439DEEEE.html",
							"GUID-F3DA568F-1791-4DD6-9397-5528439DEEEE.html",
							"GUID-F3DA568F-1791-4DD6-9397-5528439DEEEE.html",
							"GUID-F3DA568F-1791-4DD6-9397-5528439DEEEE.html",
							"GUID-F3DA568F-1791-4DD6-9397-5528439DEEEE.html",
							"GUID-F3DA568F-1791-4DD6-9397-5528439DEEEE.html",
							"GUID-7696B688-2CF7-4EC3-BAA2-FE442F8A9CA3.html",
							"GUID-7696B688-2CF7-4EC3-BAA2-FE442F8A9CA3.html",
							"GUID-7696B688-2CF7-4EC3-BAA2-FE442F8A9CA3.html",
							"GUID-7696B688-2CF7-4EC3-BAA2-FE442F8A9CA3.html",
							"GUID-7696B688-2CF7-4EC3-BAA2-FE442F8A9CA3.html",
							"GUID-7696B688-2CF7-4EC3-BAA2-FE442F8A9CA3.html",
							"GUID-7696B688-2CF7-4EC3-BAA2-FE442F8A9CA3.html",
							"GUID-7696B688-2CF7-4EC3-BAA2-FE442F8A9CA3.html",
							"GUID-7696B688-2CF7-4EC3-BAA2-FE442F8A9CA3.html",
							"GUID-E254FA9C-1F59-4868-98F7-97FC767992D1.html",
							"GUID-E254FA9C-1F59-4868-98F7-97FC767992D1.html",
							"GUID-E254FA9C-1F59-4868-98F7-97FC767992D1.html",
							"GUID-E254FA9C-1F59-4868-98F7-97FC767992D1.html",
							"GUID-E254FA9C-1F59-4868-98F7-97FC767992D1.html",
							"GUID-E254FA9C-1F59-4868-98F7-97FC767992D1.html",
							"GUID-E254FA9C-1F59-4868-98F7-97FC767992D1.html",
							"GUID-E254FA9C-1F59-4868-98F7-97FC767992D1.html",
							"GUID-E254FA9C-1F59-4868-98F7-97FC767992D1.html",
							"GUID-292AE054-43EB-4942-A030-F4D2A2F55F87.html",
							"GUID-292AE054-43EB-4942-A030-F4D2A2F55F87.html",
							"GUID-292AE054-43EB-4942-A030-F4D2A2F55F87.html",
							"GUID-292AE054-43EB-4942-A030-F4D2A2F55F87.html",
							"GUID-292AE054-43EB-4942-A030-F4D2A2F55F87.html",
							"GUID-292AE054-43EB-4942-A030-F4D2A2F55F87.html",
							"GUID-292AE054-43EB-4942-A030-F4D2A2F55F87.html",
							"GUID-292AE054-43EB-4942-A030-F4D2A2F55F87.html",
							"GUID-292AE054-43EB-4942-A030-F4D2A2F55F87.html",
							"GUID-D8DBD579-20F6-4CBF-BA28-FCB386F1E9B8.html",
							"GUID-D8DBD579-20F6-4CBF-BA28-FCB386F1E9B8.html",
							"GUID-D8DBD579-20F6-4CBF-BA28-FCB386F1E9B8.html",
							"GUID-D8DBD579-20F6-4CBF-BA28-FCB386F1E9B8.html",
							"GUID-D8DBD579-20F6-4CBF-BA28-FCB386F1E9B8.html",
							"GUID-D8DBD579-20F6-4CBF-BA28-FCB386F1E9B8.html",
							"GUID-D8DBD579-20F6-4CBF-BA28-FCB386F1E9B8.html",
							"GUID-D8DBD579-20F6-4CBF-BA28-FCB386F1E9B8.html",
							"GUID-D8DBD579-20F6-4CBF-BA28-FCB386F1E9B8.html",
							"GUID-59DADBE8-E54E-42C0-B62A-5652DAFB766E.html",
							"GUID-59DADBE8-E54E-42C0-B62A-5652DAFB766E.html",
							"GUID-59DADBE8-E54E-42C0-B62A-5652DAFB766E.html",
							"GUID-59DADBE8-E54E-42C0-B62A-5652DAFB766E.html",
							"GUID-59DADBE8-E54E-42C0-B62A-5652DAFB766E.html",
							"GUID-59DADBE8-E54E-42C0-B62A-5652DAFB766E.html",
							"GUID-59DADBE8-E54E-42C0-B62A-5652DAFB766E.html",
							"GUID-59DADBE8-E54E-42C0-B62A-5652DAFB766E.html",
							"GUID-59DADBE8-E54E-42C0-B62A-5652DAFB766E.html",
							"GUID-791DBB8A-FE97-43D1-AD04-41B7AE192649.html",
							"GUID-791DBB8A-FE97-43D1-AD04-41B7AE192649.html",
							"GUID-791DBB8A-FE97-43D1-AD04-41B7AE192649.html",
							"GUID-791DBB8A-FE97-43D1-AD04-41B7AE192649.html",
							"GUID-791DBB8A-FE97-43D1-AD04-41B7AE192649.html",
							"GUID-791DBB8A-FE97-43D1-AD04-41B7AE192649.html",
							"GUID-791DBB8A-FE97-43D1-AD04-41B7AE192649.html",
							"GUID-791DBB8A-FE97-43D1-AD04-41B7AE192649.html",
							"GUID-791DBB8A-FE97-43D1-AD04-41B7AE192649.html",
							"GUID-517695B0-A450-411B-8033-B8B837C26FD3.html",
							"GUID-517695B0-A450-411B-8033-B8B837C26FD3.html",
							"GUID-517695B0-A450-411B-8033-B8B837C26FD3.html",
							"GUID-517695B0-A450-411B-8033-B8B837C26FD3.html",
							"GUID-517695B0-A450-411B-8033-B8B837C26FD3.html",
							"GUID-517695B0-A450-411B-8033-B8B837C26FD3.html",
							"GUID-517695B0-A450-411B-8033-B8B837C26FD3.html",
							"GUID-517695B0-A450-411B-8033-B8B837C26FD3.html",
							"GUID-517695B0-A450-411B-8033-B8B837C26FD3.html",
							"GUID-0582DE0E-C854-4C96-BA08-C165BF90A15F.html",
							"GUID-0582DE0E-C854-4C96-BA08-C165BF90A15F.html",
							"GUID-0582DE0E-C854-4C96-BA08-C165BF90A15F.html",
							"GUID-0582DE0E-C854-4C96-BA08-C165BF90A15F.html",
							"GUID-0582DE0E-C854-4C96-BA08-C165BF90A15F.html",
							"GUID-0582DE0E-C854-4C96-BA08-C165BF90A15F.html",
							"GUID-0582DE0E-C854-4C96-BA08-C165BF90A15F.html",
							"GUID-0582DE0E-C854-4C96-BA08-C165BF90A15F.html",
							"GUID-0582DE0E-C854-4C96-BA08-C165BF90A15F.html",
							"GUID-96988540-2CDE-43E3-B49A-FED2B49DEA37.html",
							"GUID-96988540-2CDE-43E3-B49A-FED2B49DEA37.html",
							"GUID-96988540-2CDE-43E3-B49A-FED2B49DEA37.html",
							"GUID-96988540-2CDE-43E3-B49A-FED2B49DEA37.html",
							"GUID-96988540-2CDE-43E3-B49A-FED2B49DEA37.html",
							"GUID-96988540-2CDE-43E3-B49A-FED2B49DEA37.html",
							"GUID-96988540-2CDE-43E3-B49A-FED2B49DEA37.html",
							"GUID-96988540-2CDE-43E3-B49A-FED2B49DEA37.html",
							"GUID-96988540-2CDE-43E3-B49A-FED2B49DEA37.html",
							"GUID-6ACB9986-8D9A-42C0-B408-82F14C261ADA.html",
							"GUID-6ACB9986-8D9A-42C0-B408-82F14C261ADA.html",
							"GUID-6ACB9986-8D9A-42C0-B408-82F14C261ADA.html",
							"GUID-6ACB9986-8D9A-42C0-B408-82F14C261ADA.html",
							"GUID-6ACB9986-8D9A-42C0-B408-82F14C261ADA.html",
							"GUID-6ACB9986-8D9A-42C0-B408-82F14C261ADA.html",
							"GUID-6ACB9986-8D9A-42C0-B408-82F14C261ADA.html",
							"GUID-6ACB9986-8D9A-42C0-B408-82F14C261ADA.html",
							"GUID-6ACB9986-8D9A-42C0-B408-82F14C261ADA.html",
							"GUID-1D099440-709D-4D2E-AE2C-163F5D2415CE.html",
							"GUID-1D099440-709D-4D2E-AE2C-163F5D2415CE.html",
							"GUID-1D099440-709D-4D2E-AE2C-163F5D2415CE.html",
							"GUID-1D099440-709D-4D2E-AE2C-163F5D2415CE.html",
							"GUID-1D099440-709D-4D2E-AE2C-163F5D2415CE.html",
							"GUID-1D099440-709D-4D2E-AE2C-163F5D2415CE.html",
							"GUID-1D099440-709D-4D2E-AE2C-163F5D2415CE.html",
							"GUID-1D099440-709D-4D2E-AE2C-163F5D2415CE.html",
							"GUID-1D099440-709D-4D2E-AE2C-163F5D2415CE.html",
							"GUID-93531DF8-21C2-4F4D-9540-60E4867FAF8F.html",
							"GUID-93531DF8-21C2-4F4D-9540-60E4867FAF8F.html",
							"GUID-93531DF8-21C2-4F4D-9540-60E4867FAF8F.html",
							"GUID-93531DF8-21C2-4F4D-9540-60E4867FAF8F.html",
							"GUID-93531DF8-21C2-4F4D-9540-60E4867FAF8F.html",
							"GUID-93531DF8-21C2-4F4D-9540-60E4867FAF8F.html",
							"GUID-93531DF8-21C2-4F4D-9540-60E4867FAF8F.html",
							"GUID-93531DF8-21C2-4F4D-9540-60E4867FAF8F.html",
							"GUID-93531DF8-21C2-4F4D-9540-60E4867FAF8F.html",
							"GUID-C878A278-A038-469F-AA4E-717F236F2131.html",
							"GUID-C878A278-A038-469F-AA4E-717F236F2131.html",
							"GUID-C878A278-A038-469F-AA4E-717F236F2131.html",
							"GUID-C878A278-A038-469F-AA4E-717F236F2131.html",
							"GUID-C878A278-A038-469F-AA4E-717F236F2131.html",
							"GUID-C878A278-A038-469F-AA4E-717F236F2131.html",
							"GUID-C878A278-A038-469F-AA4E-717F236F2131.html",
							"GUID-C878A278-A038-469F-AA4E-717F236F2131.html",
							"GUID-C878A278-A038-469F-AA4E-717F236F2131.html",
							"GUID-55498A05-5BFD-4A23-8F82-57F0C6736476.html",
							"GUID-55498A05-5BFD-4A23-8F82-57F0C6736476.html",
							"GUID-55498A05-5BFD-4A23-8F82-57F0C6736476.html",
							"GUID-55498A05-5BFD-4A23-8F82-57F0C6736476.html",
							"GUID-2073D6BA-CDEC-4E93-9C98-8C6C78D11FF6.html",
							"GUID-2073D6BA-CDEC-4E93-9C98-8C6C78D11FF6.html",
							"GUID-2073D6BA-CDEC-4E93-9C98-8C6C78D11FF6.html",
							"GUID-2073D6BA-CDEC-4E93-9C98-8C6C78D11FF6.html",
							"GUID-2073D6BA-CDEC-4E93-9C98-8C6C78D11FF6.html",
							"GUID-2073D6BA-CDEC-4E93-9C98-8C6C78D11FF6.html",
							"GUID-2073D6BA-CDEC-4E93-9C98-8C6C78D11FF6.html",
							"GUID-2073D6BA-CDEC-4E93-9C98-8C6C78D11FF6.html",
							"GUID-A528297A-C3D6-48ED-AEC2-C8221CBD4A12.html",
							"GUID-A528297A-C3D6-48ED-AEC2-C8221CBD4A12.html",
							"GUID-A528297A-C3D6-48ED-AEC2-C8221CBD4A12.html",
							"GUID-A528297A-C3D6-48ED-AEC2-C8221CBD4A12.html",
							"GUID-A528297A-C3D6-48ED-AEC2-C8221CBD4A12.html",
							"GUID-A528297A-C3D6-48ED-AEC2-C8221CBD4A12.html",
							"GUID-A528297A-C3D6-48ED-AEC2-C8221CBD4A12.html",
							"GUID-A528297A-C3D6-48ED-AEC2-C8221CBD4A12.html",
							"GUID-F79615A6-B539-4AC6-B6A5-61F185C38ABC.html",
							"GUID-F79615A6-B539-4AC6-B6A5-61F185C38ABC.html",
							"GUID-F79615A6-B539-4AC6-B6A5-61F185C38ABC.html",
							"GUID-F79615A6-B539-4AC6-B6A5-61F185C38ABC.html",
							"GUID-F79615A6-B539-4AC6-B6A5-61F185C38ABC.html",
							"GUID-F79615A6-B539-4AC6-B6A5-61F185C38ABC.html",
							"GUID-F79615A6-B539-4AC6-B6A5-61F185C38ABC.html",
							"GUID-F79615A6-B539-4AC6-B6A5-61F185C38ABC.html",
							"GUID-86C39B7F-4C57-4AE6-98CE-A878EAF6E667.html",
							"GUID-86C39B7F-4C57-4AE6-98CE-A878EAF6E667.html",
							"GUID-86C39B7F-4C57-4AE6-98CE-A878EAF6E667.html",
							"GUID-86C39B7F-4C57-4AE6-98CE-A878EAF6E667.html",
							"GUID-86C39B7F-4C57-4AE6-98CE-A878EAF6E667.html",
							"GUID-86C39B7F-4C57-4AE6-98CE-A878EAF6E667.html",
							"GUID-86C39B7F-4C57-4AE6-98CE-A878EAF6E667.html",
							"GUID-86C39B7F-4C57-4AE6-98CE-A878EAF6E667.html",
							"GUID-C2D20394-132A-400D-9BA7-214987F254B5.html",
							"GUID-C2D20394-132A-400D-9BA7-214987F254B5.html",
							"GUID-C2D20394-132A-400D-9BA7-214987F254B5.html",
							"GUID-C2D20394-132A-400D-9BA7-214987F254B5.html",
							"GUID-C2D20394-132A-400D-9BA7-214987F254B5.html",
							"GUID-C2D20394-132A-400D-9BA7-214987F254B5.html",
							"GUID-C2D20394-132A-400D-9BA7-214987F254B5.html",
							"GUID-C2D20394-132A-400D-9BA7-214987F254B5.html",
							"GUID-6333F1EC-0849-49B3-AA6E-9422B26CCFBD.html",
							"GUID-6333F1EC-0849-49B3-AA6E-9422B26CCFBD.html",
							"GUID-6333F1EC-0849-49B3-AA6E-9422B26CCFBD.html",
							"GUID-6333F1EC-0849-49B3-AA6E-9422B26CCFBD.html",
							"GUID-6333F1EC-0849-49B3-AA6E-9422B26CCFBD.html",
							"GUID-6333F1EC-0849-49B3-AA6E-9422B26CCFBD.html",
							"GUID-6333F1EC-0849-49B3-AA6E-9422B26CCFBD.html",
							"GUID-6333F1EC-0849-49B3-AA6E-9422B26CCFBD.html",
							"GUID-41D05A4C-2080-40F6-A2A2-D30E77AC5A64.html",
							"GUID-41D05A4C-2080-40F6-A2A2-D30E77AC5A64.html",
							"GUID-41D05A4C-2080-40F6-A2A2-D30E77AC5A64.html",
							"GUID-41D05A4C-2080-40F6-A2A2-D30E77AC5A64.html",
							"GUID-41D05A4C-2080-40F6-A2A2-D30E77AC5A64.html",
							"GUID-41D05A4C-2080-40F6-A2A2-D30E77AC5A64.html",
							"GUID-41D05A4C-2080-40F6-A2A2-D30E77AC5A64.html",
							"GUID-41D05A4C-2080-40F6-A2A2-D30E77AC5A64.html",
							"GUID-406ADE0C-D859-4B2B-9B58-E75C9A66D04B.html",
							"GUID-406ADE0C-D859-4B2B-9B58-E75C9A66D04B.html",
							"GUID-406ADE0C-D859-4B2B-9B58-E75C9A66D04B.html",
							"GUID-406ADE0C-D859-4B2B-9B58-E75C9A66D04B.html",
							"GUID-406ADE0C-D859-4B2B-9B58-E75C9A66D04B.html",
							"GUID-406ADE0C-D859-4B2B-9B58-E75C9A66D04B.html",
							"GUID-406ADE0C-D859-4B2B-9B58-E75C9A66D04B.html",
							"GUID-406ADE0C-D859-4B2B-9B58-E75C9A66D04B.html",
							"GUID-C28059AE-E01B-4F83-9DDC-6E6397DD36F8.html",
							"GUID-C28059AE-E01B-4F83-9DDC-6E6397DD36F8.html",
							"GUID-C28059AE-E01B-4F83-9DDC-6E6397DD36F8.html",
							"GUID-C28059AE-E01B-4F83-9DDC-6E6397DD36F8.html",
							"GUID-C28059AE-E01B-4F83-9DDC-6E6397DD36F8.html",
							"GUID-1750537D-FAC6-4DE9-A207-7F92FCF38D72.html",
							"GUID-1750537D-FAC6-4DE9-A207-7F92FCF38D72.html",
							"GUID-1750537D-FAC6-4DE9-A207-7F92FCF38D72.html",
							"GUID-1750537D-FAC6-4DE9-A207-7F92FCF38D72.html",
							"GUID-1750537D-FAC6-4DE9-A207-7F92FCF38D72.html",
							"GUID-F2925ACF-B9D7-43CC-830D-549364A186D6.html",
							"GUID-F2925ACF-B9D7-43CC-830D-549364A186D6.html",
							"GUID-F2925ACF-B9D7-43CC-830D-549364A186D6.html",
							"GUID-F2925ACF-B9D7-43CC-830D-549364A186D6.html",
							"GUID-83EBAE84-CC25-4C58-9377-5B2D633E951D.html",
							"GUID-83EBAE84-CC25-4C58-9377-5B2D633E951D.html",
							"GUID-83EBAE84-CC25-4C58-9377-5B2D633E951D.html",
							"GUID-83EBAE84-CC25-4C58-9377-5B2D633E951D.html",
							"GUID-83EBAE84-CC25-4C58-9377-5B2D633E951D.html",
							"GUID-77BA9E16-C16A-44AB-9E1F-D3AB7430198A.html",
							"GUID-77BA9E16-C16A-44AB-9E1F-D3AB7430198A.html",
							"GUID-77BA9E16-C16A-44AB-9E1F-D3AB7430198A.html",
							"GUID-77BA9E16-C16A-44AB-9E1F-D3AB7430198A.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-3F0A0B53-ED4C-474E-8255-0416500DEB0B.html",
							"GUID-DCDFA2E5-435B-474F-9824-D4D6B42D70DF.html",
							"GUID-DCDFA2E5-435B-474F-9824-D4D6B42D70DF.html",
							"GUID-DCDFA2E5-435B-474F-9824-D4D6B42D70DF.html",
							"GUID-DCDFA2E5-435B-474F-9824-D4D6B42D70DF.html",
							"GUID-97410992-A415-4397-9F09-F55277DD3BF4.html",
							"GUID-97410992-A415-4397-9F09-F55277DD3BF4.html",
							"GUID-97410992-A415-4397-9F09-F55277DD3BF4.html",
							"GUID-97410992-A415-4397-9F09-F55277DD3BF4.html",
							"GUID-97410992-A415-4397-9F09-F55277DD3BF4.html",
							"GUID-559A006E-859E-45E8-BB5A-70CE63853872.html",
							"GUID-559A006E-859E-45E8-BB5A-70CE63853872.html",
							"GUID-559A006E-859E-45E8-BB5A-70CE63853872.html",
							"GUID-559A006E-859E-45E8-BB5A-70CE63853872.html",
							"GUID-559A006E-859E-45E8-BB5A-70CE63853872.html",
							"GUID-559A006E-859E-45E8-BB5A-70CE63853872.html",
							"GUID-559A006E-859E-45E8-BB5A-70CE63853872.html",
							"GUID-559A006E-859E-45E8-BB5A-70CE63853872.html",
							"GUID-559A006E-859E-45E8-BB5A-70CE63853872.html",
							"GUID-559A006E-859E-45E8-BB5A-70CE63853872.html",
							"GUID-2023FB1C-E7E7-4813-9BA3-480FEB57627B.html",
							"GUID-21C6829A-CB89-4FE2-A0B6-7467DEAB58C5.html",
							"GUID-21C6829A-CB89-4FE2-A0B6-7467DEAB58C5.html",
							"GUID-E64151E5-311B-4866-A4CC-6D01A162D076.html",
							"GUID-2356AE43-5731-46E5-8556-A282237A8145.html",
							"GUID-760CFE1C-CBE5-4B83-9F96-A1276BC1D5F6.html",
							"GUID-15B110AF-D87C-4DFC-A9B4-B32D12B324A0.html",
							"GUID-15B110AF-D87C-4DFC-A9B4-B32D12B324A0.html",
							"GUID-15B110AF-D87C-4DFC-A9B4-B32D12B324A0.html",
							"GUID-15B110AF-D87C-4DFC-A9B4-B32D12B324A0.html",
							"GUID-15B110AF-D87C-4DFC-A9B4-B32D12B324A0.html",
							"GUID-15B110AF-D87C-4DFC-A9B4-B32D12B324A0.html",
							"GUID-15B110AF-D87C-4DFC-A9B4-B32D12B324A0.html",
							"GUID-15B110AF-D87C-4DFC-A9B4-B32D12B324A0.html",
							"GUID-B4522710-73A2-4AC6-8FAA-A46B8AFEF0D3.html",
							"GUID-B4522710-73A2-4AC6-8FAA-A46B8AFEF0D3.html",
							"GUID-B4522710-73A2-4AC6-8FAA-A46B8AFEF0D3.html",
							"GUID-B4522710-73A2-4AC6-8FAA-A46B8AFEF0D3.html",
							"GUID-B4522710-73A2-4AC6-8FAA-A46B8AFEF0D3.html",
							"GUID-B4522710-73A2-4AC6-8FAA-A46B8AFEF0D3.html",
							"GUID-B4522710-73A2-4AC6-8FAA-A46B8AFEF0D3.html",
							"GUID-B4522710-73A2-4AC6-8FAA-A46B8AFEF0D3.html",
							"GUID-A33FE9DF-132B-4BE0-8D69-E474D59DAF49.html",
							"GUID-A33FE9DF-132B-4BE0-8D69-E474D59DAF49.html",
							"GUID-A33FE9DF-132B-4BE0-8D69-E474D59DAF49.html",
							"GUID-A33FE9DF-132B-4BE0-8D69-E474D59DAF49.html",
							"GUID-A33FE9DF-132B-4BE0-8D69-E474D59DAF49.html",
							"GUID-A33FE9DF-132B-4BE0-8D69-E474D59DAF49.html",
							"GUID-A33FE9DF-132B-4BE0-8D69-E474D59DAF49.html",
							"GUID-A33FE9DF-132B-4BE0-8D69-E474D59DAF49.html",
							"GUID-065E9B11-C994-458B-81A0-245A6DDCA060.html",
							"GUID-065E9B11-C994-458B-81A0-245A6DDCA060.html",
							"GUID-065E9B11-C994-458B-81A0-245A6DDCA060.html",
							"GUID-065E9B11-C994-458B-81A0-245A6DDCA060.html",
							"GUID-065E9B11-C994-458B-81A0-245A6DDCA060.html",
							"GUID-065E9B11-C994-458B-81A0-245A6DDCA060.html",
							"GUID-065E9B11-C994-458B-81A0-245A6DDCA060.html",
							"GUID-065E9B11-C994-458B-81A0-245A6DDCA060.html",
							"GUID-E8DB02F0-91A9-4650-AD55-7583FDCE6EF1.html",
							"GUID-E8DB02F0-91A9-4650-AD55-7583FDCE6EF1.html",
							"GUID-E8DB02F0-91A9-4650-AD55-7583FDCE6EF1.html",
							"GUID-E8DB02F0-91A9-4650-AD55-7583FDCE6EF1.html",
							"GUID-E8DB02F0-91A9-4650-AD55-7583FDCE6EF1.html",
							"GUID-E8DB02F0-91A9-4650-AD55-7583FDCE6EF1.html",
							"GUID-E8DB02F0-91A9-4650-AD55-7583FDCE6EF1.html",
							"GUID-E8DB02F0-91A9-4650-AD55-7583FDCE6EF1.html",
							"GUID-E8DB02F0-91A9-4650-AD55-7583FDCE6EF1.html",
							"GUID-000D4A61-94C6-4D5C-BCA3-4D0D98D90389.html",
							"GUID-000D4A61-94C6-4D5C-BCA3-4D0D98D90389.html",
							"GUID-000D4A61-94C6-4D5C-BCA3-4D0D98D90389.html",
							"GUID-000D4A61-94C6-4D5C-BCA3-4D0D98D90389.html",
							"GUID-000D4A61-94C6-4D5C-BCA3-4D0D98D90389.html",
							"GUID-000D4A61-94C6-4D5C-BCA3-4D0D98D90389.html",
							"GUID-000D4A61-94C6-4D5C-BCA3-4D0D98D90389.html",
							"GUID-000D4A61-94C6-4D5C-BCA3-4D0D98D90389.html",
							"GUID-7A6D3728-F774-40C8-A34F-893A562AB3FA.html",
							"GUID-7A6D3728-F774-40C8-A34F-893A562AB3FA.html",
							"GUID-7A6D3728-F774-40C8-A34F-893A562AB3FA.html",
							"GUID-7A6D3728-F774-40C8-A34F-893A562AB3FA.html",
							"GUID-7A6D3728-F774-40C8-A34F-893A562AB3FA.html",
							"GUID-7A6D3728-F774-40C8-A34F-893A562AB3FA.html",
							"GUID-7A6D3728-F774-40C8-A34F-893A562AB3FA.html",
							"GUID-7A6D3728-F774-40C8-A34F-893A562AB3FA.html",
							"GUID-AC680876-B0BE-403F-B362-21FD96EB06B3.html",
							"GUID-AC680876-B0BE-403F-B362-21FD96EB06B3.html",
							"GUID-AC680876-B0BE-403F-B362-21FD96EB06B3.html",
							"GUID-AC680876-B0BE-403F-B362-21FD96EB06B3.html",
							"GUID-AC680876-B0BE-403F-B362-21FD96EB06B3.html",
							"GUID-AC680876-B0BE-403F-B362-21FD96EB06B3.html",
							"GUID-AC680876-B0BE-403F-B362-21FD96EB06B3.html",
							"GUID-AC680876-B0BE-403F-B362-21FD96EB06B3.html",
							"GUID-2C3CD0E2-6C3D-459E-BFED-C275DBCEF3E1.html",
							"GUID-2C3CD0E2-6C3D-459E-BFED-C275DBCEF3E1.html",
							"GUID-2C3CD0E2-6C3D-459E-BFED-C275DBCEF3E1.html",
							"GUID-2C3CD0E2-6C3D-459E-BFED-C275DBCEF3E1.html",
							"GUID-2C3CD0E2-6C3D-459E-BFED-C275DBCEF3E1.html",
							"GUID-2C3CD0E2-6C3D-459E-BFED-C275DBCEF3E1.html",
							"GUID-2C3CD0E2-6C3D-459E-BFED-C275DBCEF3E1.html",
							"GUID-2C3CD0E2-6C3D-459E-BFED-C275DBCEF3E1.html",
							"GUID-C0265DE4-9BE3-4A22-A9C0-9E76AE1D1E61.html",
							"GUID-C0265DE4-9BE3-4A22-A9C0-9E76AE1D1E61.html",
							"GUID-C0265DE4-9BE3-4A22-A9C0-9E76AE1D1E61.html",
							"GUID-C0265DE4-9BE3-4A22-A9C0-9E76AE1D1E61.html",
							"GUID-C0265DE4-9BE3-4A22-A9C0-9E76AE1D1E61.html",
							"GUID-C0265DE4-9BE3-4A22-A9C0-9E76AE1D1E61.html",
							"GUID-C0265DE4-9BE3-4A22-A9C0-9E76AE1D1E61.html",
							"GUID-C0265DE4-9BE3-4A22-A9C0-9E76AE1D1E61.html",
							"GUID-A5A33003-F6F9-43F2-9625-337590CBC7E1.html",
							"GUID-A5A33003-F6F9-43F2-9625-337590CBC7E1.html",
							"GUID-A5A33003-F6F9-43F2-9625-337590CBC7E1.html",
							"GUID-A5A33003-F6F9-43F2-9625-337590CBC7E1.html",
							"GUID-A5A33003-F6F9-43F2-9625-337590CBC7E1.html",
							"GUID-A5A33003-F6F9-43F2-9625-337590CBC7E1.html",
							"GUID-A5A33003-F6F9-43F2-9625-337590CBC7E1.html",
							"GUID-A5A33003-F6F9-43F2-9625-337590CBC7E1.html",
							"GUID-A006380B-59B3-4102-8A27-00BA14ABEA64.html",
							"GUID-A006380B-59B3-4102-8A27-00BA14ABEA64.html",
							"GUID-A006380B-59B3-4102-8A27-00BA14ABEA64.html",
							"GUID-A006380B-59B3-4102-8A27-00BA14ABEA64.html",
							"GUID-A006380B-59B3-4102-8A27-00BA14ABEA64.html",
							"GUID-A006380B-59B3-4102-8A27-00BA14ABEA64.html",
							"GUID-A006380B-59B3-4102-8A27-00BA14ABEA64.html",
							"GUID-A006380B-59B3-4102-8A27-00BA14ABEA64.html",
							"GUID-14C662AB-69E2-4C87-9869-99B3A87461C8.html",
							"GUID-14C662AB-69E2-4C87-9869-99B3A87461C8.html",
							"GUID-14C662AB-69E2-4C87-9869-99B3A87461C8.html",
							"GUID-14C662AB-69E2-4C87-9869-99B3A87461C8.html",
							"GUID-14C662AB-69E2-4C87-9869-99B3A87461C8.html",
							"GUID-14C662AB-69E2-4C87-9869-99B3A87461C8.html",
							"GUID-14C662AB-69E2-4C87-9869-99B3A87461C8.html",
							"GUID-14C662AB-69E2-4C87-9869-99B3A87461C8.html",
							"GUID-067B7063-E94C-453E-AA51-9179785602C2.html",
							"GUID-067B7063-E94C-453E-AA51-9179785602C2.html",
							"GUID-067B7063-E94C-453E-AA51-9179785602C2.html",
							"GUID-067B7063-E94C-453E-AA51-9179785602C2.html",
							"GUID-067B7063-E94C-453E-AA51-9179785602C2.html",
							"GUID-067B7063-E94C-453E-AA51-9179785602C2.html",
							"GUID-067B7063-E94C-453E-AA51-9179785602C2.html",
							"GUID-067B7063-E94C-453E-AA51-9179785602C2.html",
							"GUID-4ED8B3F6-0288-41C8-BA4B-F0A0FEE81E7A.html",
							"GUID-4ED8B3F6-0288-41C8-BA4B-F0A0FEE81E7A.html",
							"GUID-4ED8B3F6-0288-41C8-BA4B-F0A0FEE81E7A.html",
							"GUID-4ED8B3F6-0288-41C8-BA4B-F0A0FEE81E7A.html",
							"GUID-4ED8B3F6-0288-41C8-BA4B-F0A0FEE81E7A.html",
							"GUID-4ED8B3F6-0288-41C8-BA4B-F0A0FEE81E7A.html",
							"GUID-4ED8B3F6-0288-41C8-BA4B-F0A0FEE81E7A.html",
							"GUID-4ED8B3F6-0288-41C8-BA4B-F0A0FEE81E7A.html",
							"GUID-5DD54744-A308-4CFC-9EC7-2A74AE260057.html",
							"GUID-5DD54744-A308-4CFC-9EC7-2A74AE260057.html",
							"GUID-5DD54744-A308-4CFC-9EC7-2A74AE260057.html",
							"GUID-5DD54744-A308-4CFC-9EC7-2A74AE260057.html",
							"GUID-5DD54744-A308-4CFC-9EC7-2A74AE260057.html",
							"GUID-5DD54744-A308-4CFC-9EC7-2A74AE260057.html",
							"GUID-5DD54744-A308-4CFC-9EC7-2A74AE260057.html",
							"GUID-5DD54744-A308-4CFC-9EC7-2A74AE260057.html",
							"GUID-42DAEFE9-160F-4E01-961A-6BA11105CD6F.html",
							"GUID-42DAEFE9-160F-4E01-961A-6BA11105CD6F.html",
							"GUID-42DAEFE9-160F-4E01-961A-6BA11105CD6F.html",
							"GUID-42DAEFE9-160F-4E01-961A-6BA11105CD6F.html",
							"GUID-42DAEFE9-160F-4E01-961A-6BA11105CD6F.html",
							"GUID-42DAEFE9-160F-4E01-961A-6BA11105CD6F.html",
							"GUID-42DAEFE9-160F-4E01-961A-6BA11105CD6F.html",
							"GUID-42DAEFE9-160F-4E01-961A-6BA11105CD6F.html",
							"GUID-B2ABF750-2622-4A16-BD06-60AF4EA9E6EA.html",
							"GUID-B2ABF750-2622-4A16-BD06-60AF4EA9E6EA.html",
							"GUID-B2ABF750-2622-4A16-BD06-60AF4EA9E6EA.html",
							"GUID-B2ABF750-2622-4A16-BD06-60AF4EA9E6EA.html",
							"GUID-B2ABF750-2622-4A16-BD06-60AF4EA9E6EA.html",
							"GUID-B2ABF750-2622-4A16-BD06-60AF4EA9E6EA.html",
							"GUID-B2ABF750-2622-4A16-BD06-60AF4EA9E6EA.html",
							"GUID-B2ABF750-2622-4A16-BD06-60AF4EA9E6EA.html",
							"GUID-D4D6B9B8-E622-43E0-8A4F-58303A16AB3C.html",
							"GUID-D4D6B9B8-E622-43E0-8A4F-58303A16AB3C.html",
							"GUID-D4D6B9B8-E622-43E0-8A4F-58303A16AB3C.html",
							"GUID-D4D6B9B8-E622-43E0-8A4F-58303A16AB3C.html",
							"GUID-D4D6B9B8-E622-43E0-8A4F-58303A16AB3C.html",
							"GUID-D4D6B9B8-E622-43E0-8A4F-58303A16AB3C.html",
							"GUID-D4D6B9B8-E622-43E0-8A4F-58303A16AB3C.html",
							"GUID-D4D6B9B8-E622-43E0-8A4F-58303A16AB3C.html",
							"GUID-2D4B1FB0-E202-4D55-BD07-801884E97291.html",
							"GUID-2D4B1FB0-E202-4D55-BD07-801884E97291.html",
							"GUID-2D4B1FB0-E202-4D55-BD07-801884E97291.html",
							"GUID-2D4B1FB0-E202-4D55-BD07-801884E97291.html",
							"GUID-2D4B1FB0-E202-4D55-BD07-801884E97291.html",
							"GUID-2D4B1FB0-E202-4D55-BD07-801884E97291.html",
							"GUID-2D4B1FB0-E202-4D55-BD07-801884E97291.html",
							"GUID-2D4B1FB0-E202-4D55-BD07-801884E97291.html",
							"GUID-D4AD27AE-02DA-494A-A32F-6574D5835235.html",
							"GUID-D4AD27AE-02DA-494A-A32F-6574D5835235.html",
							"GUID-D4AD27AE-02DA-494A-A32F-6574D5835235.html",
							"GUID-D4AD27AE-02DA-494A-A32F-6574D5835235.html",
							"GUID-D4AD27AE-02DA-494A-A32F-6574D5835235.html",
							"GUID-D4AD27AE-02DA-494A-A32F-6574D5835235.html",
							"GUID-D4AD27AE-02DA-494A-A32F-6574D5835235.html",
							"GUID-D4AD27AE-02DA-494A-A32F-6574D5835235.html",
							"GUID-9962617B-ABCC-44BA-AF1E-3BFC1B4D81F1.html",
							"GUID-9962617B-ABCC-44BA-AF1E-3BFC1B4D81F1.html",
							"GUID-9962617B-ABCC-44BA-AF1E-3BFC1B4D81F1.html",
							"GUID-9962617B-ABCC-44BA-AF1E-3BFC1B4D81F1.html",
							"GUID-9962617B-ABCC-44BA-AF1E-3BFC1B4D81F1.html",
							"GUID-9962617B-ABCC-44BA-AF1E-3BFC1B4D81F1.html",
							"GUID-9962617B-ABCC-44BA-AF1E-3BFC1B4D81F1.html",
							"GUID-9962617B-ABCC-44BA-AF1E-3BFC1B4D81F1.html",
							"GUID-8CEA8A9A-497B-4D34-BF20-91B6B4A704C5.html",
							"GUID-8CEA8A9A-497B-4D34-BF20-91B6B4A704C5.html",
							"GUID-8CEA8A9A-497B-4D34-BF20-91B6B4A704C5.html",
							"GUID-8CEA8A9A-497B-4D34-BF20-91B6B4A704C5.html",
							"GUID-8CEA8A9A-497B-4D34-BF20-91B6B4A704C5.html",
							"GUID-8CEA8A9A-497B-4D34-BF20-91B6B4A704C5.html",
							"GUID-8CEA8A9A-497B-4D34-BF20-91B6B4A704C5.html",
							"GUID-8CEA8A9A-497B-4D34-BF20-91B6B4A704C5.html",
							"GUID-EB8372C5-89A0-4063-B212-93D39E201E1C.html",
							"GUID-EB8372C5-89A0-4063-B212-93D39E201E1C.html",
							"GUID-EB8372C5-89A0-4063-B212-93D39E201E1C.html",
							"GUID-EB8372C5-89A0-4063-B212-93D39E201E1C.html",
							"GUID-EB8372C5-89A0-4063-B212-93D39E201E1C.html",
							"GUID-EB8372C5-89A0-4063-B212-93D39E201E1C.html",
							"GUID-EB8372C5-89A0-4063-B212-93D39E201E1C.html",
							"GUID-EB8372C5-89A0-4063-B212-93D39E201E1C.html",
							"GUID-CD6C930C-1CEF-40B2-A0BC-B284F0BB91E3.html",
							"GUID-CD6C930C-1CEF-40B2-A0BC-B284F0BB91E3.html",
							"GUID-CD6C930C-1CEF-40B2-A0BC-B284F0BB91E3.html",
							"GUID-CD6C930C-1CEF-40B2-A0BC-B284F0BB91E3.html",
							"GUID-CD6C930C-1CEF-40B2-A0BC-B284F0BB91E3.html",
							"GUID-CD6C930C-1CEF-40B2-A0BC-B284F0BB91E3.html",
							"GUID-CD6C930C-1CEF-40B2-A0BC-B284F0BB91E3.html",
							"GUID-CD6C930C-1CEF-40B2-A0BC-B284F0BB91E3.html",
							"GUID-40B6968C-BC5B-4834-B172-6037A8F86B4C.html",
							"GUID-40B6968C-BC5B-4834-B172-6037A8F86B4C.html",
							"GUID-40B6968C-BC5B-4834-B172-6037A8F86B4C.html",
							"GUID-40B6968C-BC5B-4834-B172-6037A8F86B4C.html",
							"GUID-40B6968C-BC5B-4834-B172-6037A8F86B4C.html",
							"GUID-40B6968C-BC5B-4834-B172-6037A8F86B4C.html",
							"GUID-40B6968C-BC5B-4834-B172-6037A8F86B4C.html",
							"GUID-40B6968C-BC5B-4834-B172-6037A8F86B4C.html",
							"GUID-8C5F5F6E-5B77-4AC5-9274-D0E6AE292759.html",
							"GUID-8C5F5F6E-5B77-4AC5-9274-D0E6AE292759.html",
							"GUID-8C5F5F6E-5B77-4AC5-9274-D0E6AE292759.html",
							"GUID-8C5F5F6E-5B77-4AC5-9274-D0E6AE292759.html",
							"GUID-6947C4CA-0A47-43CA-9928-DDC533406CBE.html",
							"GUID-6947C4CA-0A47-43CA-9928-DDC533406CBE.html",
							"GUID-6947C4CA-0A47-43CA-9928-DDC533406CBE.html",
							"GUID-6947C4CA-0A47-43CA-9928-DDC533406CBE.html",
							"GUID-B0D43890-3087-41AD-B694-E10EB97EB0D8.html",
							"GUID-B0D43890-3087-41AD-B694-E10EB97EB0D8.html",
							"GUID-B0D43890-3087-41AD-B694-E10EB97EB0D8.html",
							"GUID-B0D43890-3087-41AD-B694-E10EB97EB0D8.html",
							"GUID-B30E0A99-F577-4040-B9DB-4BF69AC7D3E8.html",
							"GUID-B30E0A99-F577-4040-B9DB-4BF69AC7D3E8.html",
							"GUID-B30E0A99-F577-4040-B9DB-4BF69AC7D3E8.html",
							"GUID-B30E0A99-F577-4040-B9DB-4BF69AC7D3E8.html",
							"GUID-B30E0A99-F577-4040-B9DB-4BF69AC7D3E8.html",
							"GUID-B30E0A99-F577-4040-B9DB-4BF69AC7D3E8.html",
							"GUID-B30E0A99-F577-4040-B9DB-4BF69AC7D3E8.html",
							"GUID-B30E0A99-F577-4040-B9DB-4BF69AC7D3E8.html",
							"GUID-C68E12F8-5625-420D-B82B-D586E15D9F3A.html",
							"GUID-C68E12F8-5625-420D-B82B-D586E15D9F3A.html",
							"GUID-C68E12F8-5625-420D-B82B-D586E15D9F3A.html",
							"GUID-C68E12F8-5625-420D-B82B-D586E15D9F3A.html",
							"GUID-43E7E120-2618-422D-AC8B-23E78FF268AE.html",
							"GUID-43E7E120-2618-422D-AC8B-23E78FF268AE.html",
							"GUID-43E7E120-2618-422D-AC8B-23E78FF268AE.html",
							"GUID-43E7E120-2618-422D-AC8B-23E78FF268AE.html",
							"GUID-FB4BC534-FE65-4396-85AA-33E97F8474F2.html",
							"GUID-FB4BC534-FE65-4396-85AA-33E97F8474F2.html",
							"GUID-FB4BC534-FE65-4396-85AA-33E97F8474F2.html",
							"GUID-FB4BC534-FE65-4396-85AA-33E97F8474F2.html",
							"GUID-1C383DE6-835B-43D8-812B-E35155090B0F.html",
							"GUID-1C383DE6-835B-43D8-812B-E35155090B0F.html",
							"GUID-1C383DE6-835B-43D8-812B-E35155090B0F.html",
							"GUID-1C383DE6-835B-43D8-812B-E35155090B0F.html",
							"GUID-1C383DE6-835B-43D8-812B-E35155090B0F.html",
							"GUID-18109125-3906-41A5-8221-A41436ADE4A4.html",
							"GUID-18109125-3906-41A5-8221-A41436ADE4A4.html",
							"GUID-18109125-3906-41A5-8221-A41436ADE4A4.html",
							"GUID-18109125-3906-41A5-8221-A41436ADE4A4.html",
							"GUID-18109125-3906-41A5-8221-A41436ADE4A4.html",
							"GUID-A92CAB0B-51F2-4706-938C-5E993E3CD6BD.html",
							"GUID-A92CAB0B-51F2-4706-938C-5E993E3CD6BD.html",
							"GUID-A92CAB0B-51F2-4706-938C-5E993E3CD6BD.html",
							"GUID-A92CAB0B-51F2-4706-938C-5E993E3CD6BD.html",
							"GUID-A92CAB0B-51F2-4706-938C-5E993E3CD6BD.html",
							"GUID-EDB3D0B3-3F3F-42A7-ABCB-F42A6AE36965.html",
							"GUID-EDB3D0B3-3F3F-42A7-ABCB-F42A6AE36965.html",
							"GUID-EDB3D0B3-3F3F-42A7-ABCB-F42A6AE36965.html",
							"GUID-EDB3D0B3-3F3F-42A7-ABCB-F42A6AE36965.html",
							"GUID-EDB3D0B3-3F3F-42A7-ABCB-F42A6AE36965.html",
							"GUID-DFA024DD-029D-43F9-A6C2-6D65EFA83011.html",
							"GUID-DFA024DD-029D-43F9-A6C2-6D65EFA83011.html",
							"GUID-DFA024DD-029D-43F9-A6C2-6D65EFA83011.html",
							"GUID-DFA024DD-029D-43F9-A6C2-6D65EFA83011.html",
							"GUID-1EB20D0D-FAB8-46CF-B99E-66BDD7CB6A0F.html",
							"GUID-1EB20D0D-FAB8-46CF-B99E-66BDD7CB6A0F.html",
							"GUID-1EB20D0D-FAB8-46CF-B99E-66BDD7CB6A0F.html",
							"GUID-1EB20D0D-FAB8-46CF-B99E-66BDD7CB6A0F.html",
							"GUID-1EB20D0D-FAB8-46CF-B99E-66BDD7CB6A0F.html",
							"GUID-87E6C7E7-6BA7-4E96-BA40-DD5CF7349793.html",
							"GUID-87E6C7E7-6BA7-4E96-BA40-DD5CF7349793.html",
							"GUID-87E6C7E7-6BA7-4E96-BA40-DD5CF7349793.html",
							"GUID-87E6C7E7-6BA7-4E96-BA40-DD5CF7349793.html",
							"GUID-87E6C7E7-6BA7-4E96-BA40-DD5CF7349793.html",
							"GUID-0E9A7DEF-904D-451D-A356-FACF9360BA4F.html",
							"GUID-0E9A7DEF-904D-451D-A356-FACF9360BA4F.html",
							"GUID-0E9A7DEF-904D-451D-A356-FACF9360BA4F.html",
							"GUID-0E9A7DEF-904D-451D-A356-FACF9360BA4F.html",
							"GUID-388C8E2A-F0FE-40EC-8115-8680F569945E.html",
							"GUID-388C8E2A-F0FE-40EC-8115-8680F569945E.html",
							"GUID-388C8E2A-F0FE-40EC-8115-8680F569945E.html",
							"GUID-388C8E2A-F0FE-40EC-8115-8680F569945E.html",
							"GUID-388C8E2A-F0FE-40EC-8115-8680F569945E.html",
							"GUID-3DBF4BBC-895F-4E64-901F-C76DB2918FDD.html",
							"GUID-80ABA2A7-287D-4A30-B31E-561FA3322D9A.html",
							"GUID-7CBC706E-193F-491A-88C3-356E7E7FDD5C.html",
							"GUID-7CBC706E-193F-491A-88C3-356E7E7FDD5C.html",
							"GUID-7CBC706E-193F-491A-88C3-356E7E7FDD5C.html",
							"GUID-7CBC706E-193F-491A-88C3-356E7E7FDD5C.html",
							"GUID-7CBC706E-193F-491A-88C3-356E7E7FDD5C.html",
							"GUID-7CBC706E-193F-491A-88C3-356E7E7FDD5C.html",
							"GUID-6AC86335-EDE5-40ED-8D96-800FFF8D9748.html",
							"GUID-F2B0A336-0750-45E6-84D5-95A673FC4271.html",
							"GUID-62BC0CAA-AB55-4B7B-851F-0B4888266296.html",
							"GUID-BAD839D0-DC99-40E6-B406-813928767344.html",
							"GUID-BAD839D0-DC99-40E6-B406-813928767344.html",
							"GUID-BAD839D0-DC99-40E6-B406-813928767344.html",
							"GUID-BAD839D0-DC99-40E6-B406-813928767344.html",
							"GUID-BAD839D0-DC99-40E6-B406-813928767344.html",
							"GUID-BAD839D0-DC99-40E6-B406-813928767344.html",
							"GUID-29D4D959-1677-4A62-8B08-BE81ECEAB8E6.html",
							"GUID-EF398ECF-CD01-4199-8C4D-0C410898C27C.html",
							"GUID-6A734799-58CF-486D-AEAF-6498317A903F.html",
							"GUID-6A734799-58CF-486D-AEAF-6498317A903F.html",
							"GUID-6A734799-58CF-486D-AEAF-6498317A903F.html",
							"GUID-6A734799-58CF-486D-AEAF-6498317A903F.html",
							"GUID-6A734799-58CF-486D-AEAF-6498317A903F.html",
							"GUID-6A734799-58CF-486D-AEAF-6498317A903F.html",
							"GUID-6A734799-58CF-486D-AEAF-6498317A903F.html",
							"GUID-6A734799-58CF-486D-AEAF-6498317A903F.html",
							"GUID-6A734799-58CF-486D-AEAF-6498317A903F.html",
							"GUID-F7F88BE2-2CCE-41EE-A028-2F8E7F231F59.html",
							"GUID-F7F88BE2-2CCE-41EE-A028-2F8E7F231F59.html",
							"GUID-F7F88BE2-2CCE-41EE-A028-2F8E7F231F59.html",
							"GUID-F7F88BE2-2CCE-41EE-A028-2F8E7F231F59.html",
							"GUID-F7F88BE2-2CCE-41EE-A028-2F8E7F231F59.html",
							"GUID-F7F88BE2-2CCE-41EE-A028-2F8E7F231F59.html",
							"GUID-F7F88BE2-2CCE-41EE-A028-2F8E7F231F59.html",
							"GUID-F7F88BE2-2CCE-41EE-A028-2F8E7F231F59.html",
							"GUID-F7F88BE2-2CCE-41EE-A028-2F8E7F231F59.html",
							"GUID-6ED1119A-7A55-4C17-9E56-5835926DD77B.html",
							"GUID-6ED1119A-7A55-4C17-9E56-5835926DD77B.html",
							"GUID-6ED1119A-7A55-4C17-9E56-5835926DD77B.html",
							"GUID-6ED1119A-7A55-4C17-9E56-5835926DD77B.html",
							"GUID-6ED1119A-7A55-4C17-9E56-5835926DD77B.html",
							"GUID-6ED1119A-7A55-4C17-9E56-5835926DD77B.html",
							"GUID-6ED1119A-7A55-4C17-9E56-5835926DD77B.html",
							"GUID-6ED1119A-7A55-4C17-9E56-5835926DD77B.html",
							"GUID-6ED1119A-7A55-4C17-9E56-5835926DD77B.html",
							"GUID-B74CFBEC-2049-4087-B361-12EAE0A6D2D5.html",
							"GUID-B74CFBEC-2049-4087-B361-12EAE0A6D2D5.html",
							"GUID-B74CFBEC-2049-4087-B361-12EAE0A6D2D5.html",
							"GUID-B74CFBEC-2049-4087-B361-12EAE0A6D2D5.html",
							"GUID-B74CFBEC-2049-4087-B361-12EAE0A6D2D5.html",
							"GUID-B74CFBEC-2049-4087-B361-12EAE0A6D2D5.html",
							"GUID-B74CFBEC-2049-4087-B361-12EAE0A6D2D5.html",
							"GUID-B74CFBEC-2049-4087-B361-12EAE0A6D2D5.html",
							"GUID-B74CFBEC-2049-4087-B361-12EAE0A6D2D5.html",
							"GUID-EC8301E5-93D5-4777-8700-FDEB4DBEB360.html",
							"GUID-EC8301E5-93D5-4777-8700-FDEB4DBEB360.html",
							"GUID-EC8301E5-93D5-4777-8700-FDEB4DBEB360.html",
							"GUID-EC8301E5-93D5-4777-8700-FDEB4DBEB360.html",
							"GUID-EC8301E5-93D5-4777-8700-FDEB4DBEB360.html",
							"GUID-1B2EA98D-2D73-4430-B618-98A85A520318.html",
							"GUID-1B2EA98D-2D73-4430-B618-98A85A520318.html",
							"GUID-1B2EA98D-2D73-4430-B618-98A85A520318.html",
							"GUID-1B2EA98D-2D73-4430-B618-98A85A520318.html",
							"GUID-1B2EA98D-2D73-4430-B618-98A85A520318.html",
							"GUID-08A6DB8F-C8BE-470F-A8C9-FA1021C398C0.html",
							"GUID-EE46783A-E2A0-48C2-B479-6436C638C41B.html",
							"GUID-EE46783A-E2A0-48C2-B479-6436C638C41B.html",
							"GUID-EE46783A-E2A0-48C2-B479-6436C638C41B.html",
							"GUID-EE46783A-E2A0-48C2-B479-6436C638C41B.html",
							"GUID-EE46783A-E2A0-48C2-B479-6436C638C41B.html",
							"GUID-EE46783A-E2A0-48C2-B479-6436C638C41B.html",
							"GUID-EE46783A-E2A0-48C2-B479-6436C638C41B.html",
							"GUID-EE46783A-E2A0-48C2-B479-6436C638C41B.html",
							"GUID-EE46783A-E2A0-48C2-B479-6436C638C41B.html",
							"GUID-F053AFD0-4BA9-4ACE-B7CB-7C7A48FB0E0F.html",
							"GUID-F053AFD0-4BA9-4ACE-B7CB-7C7A48FB0E0F.html",
							"GUID-F053AFD0-4BA9-4ACE-B7CB-7C7A48FB0E0F.html",
							"GUID-F053AFD0-4BA9-4ACE-B7CB-7C7A48FB0E0F.html",
							"GUID-F053AFD0-4BA9-4ACE-B7CB-7C7A48FB0E0F.html",
							"GUID-F053AFD0-4BA9-4ACE-B7CB-7C7A48FB0E0F.html",
							"GUID-F053AFD0-4BA9-4ACE-B7CB-7C7A48FB0E0F.html",
							"GUID-F053AFD0-4BA9-4ACE-B7CB-7C7A48FB0E0F.html",
							"GUID-F053AFD0-4BA9-4ACE-B7CB-7C7A48FB0E0F.html",
							"GUID-A74E4416-E7F9-4A02-8A29-FC1F2A00BF93.html",
							"GUID-A74E4416-E7F9-4A02-8A29-FC1F2A00BF93.html",
							"GUID-A74E4416-E7F9-4A02-8A29-FC1F2A00BF93.html",
							"GUID-A74E4416-E7F9-4A02-8A29-FC1F2A00BF93.html",
							"GUID-A74E4416-E7F9-4A02-8A29-FC1F2A00BF93.html",
							"GUID-A74E4416-E7F9-4A02-8A29-FC1F2A00BF93.html",
							"GUID-A74E4416-E7F9-4A02-8A29-FC1F2A00BF93.html",
							"GUID-A74E4416-E7F9-4A02-8A29-FC1F2A00BF93.html",
							"GUID-A74E4416-E7F9-4A02-8A29-FC1F2A00BF93.html",
							"GUID-3778B1C9-F454-4097-93C1-EB63083FD1AD.html",
							"GUID-3778B1C9-F454-4097-93C1-EB63083FD1AD.html",
							"GUID-3778B1C9-F454-4097-93C1-EB63083FD1AD.html",
							"GUID-3778B1C9-F454-4097-93C1-EB63083FD1AD.html",
							"GUID-3778B1C9-F454-4097-93C1-EB63083FD1AD.html",
							"GUID-BF84994F-1D02-4912-91AB-DCB62487A732.html",
							"GUID-81475CB9-3097-4C2B-BA9F-D58AF46781CC.html",
							"GUID-81475CB9-3097-4C2B-BA9F-D58AF46781CC.html",
							"GUID-81475CB9-3097-4C2B-BA9F-D58AF46781CC.html",
							"GUID-81475CB9-3097-4C2B-BA9F-D58AF46781CC.html",
							"GUID-81475CB9-3097-4C2B-BA9F-D58AF46781CC.html",
							"GUID-81475CB9-3097-4C2B-BA9F-D58AF46781CC.html",
							"GUID-81475CB9-3097-4C2B-BA9F-D58AF46781CC.html",
							"GUID-81475CB9-3097-4C2B-BA9F-D58AF46781CC.html",
							"GUID-329198A1-BC49-4122-B71D-BEF5575E0C6E.html",
							"GUID-1279B3B1-7AC6-4986-8E88-539CBCEF5F52.html",
							"GUID-DC136775-2C6D-44AC-810C-0CD7057E42EF.html",
							"GUID-16D2166F-F65C-431C-951A-2C4B18120281.html",
							"GUID-16D2166F-F65C-431C-951A-2C4B18120281.html",
							"GUID-16D2166F-F65C-431C-951A-2C4B18120281.html",
							"GUID-16D2166F-F65C-431C-951A-2C4B18120281.html",
							"GUID-16D2166F-F65C-431C-951A-2C4B18120281.html",
							"GUID-16D2166F-F65C-431C-951A-2C4B18120281.html",
							"GUID-16D2166F-F65C-431C-951A-2C4B18120281.html",
							"GUID-16D2166F-F65C-431C-951A-2C4B18120281.html",
							"GUID-16D2166F-F65C-431C-951A-2C4B18120281.html",
							"GUID-FAC7780A-68D6-4C70-AC4B-25FCF620B196.html",
							"GUID-FAC7780A-68D6-4C70-AC4B-25FCF620B196.html",
							"GUID-FAC7780A-68D6-4C70-AC4B-25FCF620B196.html",
							"GUID-FAC7780A-68D6-4C70-AC4B-25FCF620B196.html",
							"GUID-FAC7780A-68D6-4C70-AC4B-25FCF620B196.html",
							"GUID-FAC7780A-68D6-4C70-AC4B-25FCF620B196.html",
							"GUID-FAC7780A-68D6-4C70-AC4B-25FCF620B196.html",
							"GUID-FAC7780A-68D6-4C70-AC4B-25FCF620B196.html",
							"GUID-FAC7780A-68D6-4C70-AC4B-25FCF620B196.html",
							"GUID-1D2064DA-2F59-46DC-8B62-9D61B1B299DD.html",
							"GUID-1D2064DA-2F59-46DC-8B62-9D61B1B299DD.html",
							"GUID-1D2064DA-2F59-46DC-8B62-9D61B1B299DD.html",
							"GUID-1D2064DA-2F59-46DC-8B62-9D61B1B299DD.html",
							"GUID-1D2064DA-2F59-46DC-8B62-9D61B1B299DD.html",
							"GUID-1D2064DA-2F59-46DC-8B62-9D61B1B299DD.html",
							"GUID-1D2064DA-2F59-46DC-8B62-9D61B1B299DD.html",
							"GUID-1D2064DA-2F59-46DC-8B62-9D61B1B299DD.html",
							"GUID-1D2064DA-2F59-46DC-8B62-9D61B1B299DD.html",
							"GUID-8F2BCC2D-088B-4489-893D-ADFFCB710E47.html",
							"GUID-8F2BCC2D-088B-4489-893D-ADFFCB710E47.html",
							"GUID-8F2BCC2D-088B-4489-893D-ADFFCB710E47.html",
							"GUID-8F2BCC2D-088B-4489-893D-ADFFCB710E47.html",
							"GUID-8F2BCC2D-088B-4489-893D-ADFFCB710E47.html",
							"GUID-8F2BCC2D-088B-4489-893D-ADFFCB710E47.html",
							"GUID-8F2BCC2D-088B-4489-893D-ADFFCB710E47.html",
							"GUID-8F2BCC2D-088B-4489-893D-ADFFCB710E47.html",
							"GUID-8F2BCC2D-088B-4489-893D-ADFFCB710E47.html",
							"GUID-8FCCE1DA-FD25-42C5-9C36-243E1E14CDFF.html",
							"GUID-8FCCE1DA-FD25-42C5-9C36-243E1E14CDFF.html",
							"GUID-8FCCE1DA-FD25-42C5-9C36-243E1E14CDFF.html",
							"GUID-8FCCE1DA-FD25-42C5-9C36-243E1E14CDFF.html",
							"GUID-8FCCE1DA-FD25-42C5-9C36-243E1E14CDFF.html",
							"GUID-8FCCE1DA-FD25-42C5-9C36-243E1E14CDFF.html",
							"GUID-8FCCE1DA-FD25-42C5-9C36-243E1E14CDFF.html",
							"GUID-8FCCE1DA-FD25-42C5-9C36-243E1E14CDFF.html",
							"GUID-8FCCE1DA-FD25-42C5-9C36-243E1E14CDFF.html",
							"GUID-1C3755D7-2C24-4854-B5B1-9F335BA0389D.html",
							"GUID-1C3755D7-2C24-4854-B5B1-9F335BA0389D.html",
							"GUID-1C3755D7-2C24-4854-B5B1-9F335BA0389D.html",
							"GUID-1C3755D7-2C24-4854-B5B1-9F335BA0389D.html",
							"GUID-1C3755D7-2C24-4854-B5B1-9F335BA0389D.html",
							"GUID-1C3755D7-2C24-4854-B5B1-9F335BA0389D.html",
							"GUID-1C3755D7-2C24-4854-B5B1-9F335BA0389D.html",
							"GUID-1C3755D7-2C24-4854-B5B1-9F335BA0389D.html",
							"GUID-1C3755D7-2C24-4854-B5B1-9F335BA0389D.html",
							"GUID-BCB28663-4E3B-4C51-8F7D-A9495FB0A16A.html",
							"GUID-BCB28663-4E3B-4C51-8F7D-A9495FB0A16A.html",
							"GUID-BCB28663-4E3B-4C51-8F7D-A9495FB0A16A.html",
							"GUID-BCB28663-4E3B-4C51-8F7D-A9495FB0A16A.html",
							"GUID-BCB28663-4E3B-4C51-8F7D-A9495FB0A16A.html",
							"GUID-BCB28663-4E3B-4C51-8F7D-A9495FB0A16A.html",
							"GUID-BCB28663-4E3B-4C51-8F7D-A9495FB0A16A.html",
							"GUID-BCB28663-4E3B-4C51-8F7D-A9495FB0A16A.html",
							"GUID-BCB28663-4E3B-4C51-8F7D-A9495FB0A16A.html",
							"GUID-033E46F6-14A5-4DD2-9BFC-BDA2AE973092.html",
							"GUID-033E46F6-14A5-4DD2-9BFC-BDA2AE973092.html",
							"GUID-033E46F6-14A5-4DD2-9BFC-BDA2AE973092.html",
							"GUID-033E46F6-14A5-4DD2-9BFC-BDA2AE973092.html",
							"GUID-033E46F6-14A5-4DD2-9BFC-BDA2AE973092.html",
							"GUID-033E46F6-14A5-4DD2-9BFC-BDA2AE973092.html",
							"GUID-033E46F6-14A5-4DD2-9BFC-BDA2AE973092.html",
							"GUID-033E46F6-14A5-4DD2-9BFC-BDA2AE973092.html",
							"GUID-033E46F6-14A5-4DD2-9BFC-BDA2AE973092.html",
							"GUID-D4A95F17-FA6E-47C8-9FE4-ED986264B809.html",
							"GUID-D4A95F17-FA6E-47C8-9FE4-ED986264B809.html",
							"GUID-D4A95F17-FA6E-47C8-9FE4-ED986264B809.html",
							"GUID-D4A95F17-FA6E-47C8-9FE4-ED986264B809.html",
							"GUID-D4A95F17-FA6E-47C8-9FE4-ED986264B809.html",
							"GUID-9CCE1919-6FB5-41BE-90E8-9A12F57D6D61.html",
							"GUID-1A5C5506-BEF0-4666-9A96-8C3D7C51211A.html",
							"GUID-1A5C5506-BEF0-4666-9A96-8C3D7C51211A.html",
							"GUID-1A5C5506-BEF0-4666-9A96-8C3D7C51211A.html",
							"GUID-1A5C5506-BEF0-4666-9A96-8C3D7C51211A.html",
							"GUID-9FC71CD9-27EF-4136-8708-58075AE0B905.html",
							"GUID-76D58185-B456-47A8-BE17-D5824D22CF3F.html",
							"GUID-94D8AC75-963A-4D7A-965C-FF88F06BB635.html",
							"GUID-A276143A-DF95-4D51-ADE9-7B7B0157694A.html",
							"GUID-A276143A-DF95-4D51-ADE9-7B7B0157694A.html",
							"GUID-A276143A-DF95-4D51-ADE9-7B7B0157694A.html",
							"GUID-A276143A-DF95-4D51-ADE9-7B7B0157694A.html",
							"GUID-A276143A-DF95-4D51-ADE9-7B7B0157694A.html",
							"GUID-A276143A-DF95-4D51-ADE9-7B7B0157694A.html",
							"GUID-A276143A-DF95-4D51-ADE9-7B7B0157694A.html",
							"GUID-A276143A-DF95-4D51-ADE9-7B7B0157694A.html",
							"GUID-A276143A-DF95-4D51-ADE9-7B7B0157694A.html",
							"GUID-9FF36725-3200-489F-8E5A-08E6DA599D4E.html",
							"GUID-9FF36725-3200-489F-8E5A-08E6DA599D4E.html",
							"GUID-9FF36725-3200-489F-8E5A-08E6DA599D4E.html",
							"GUID-9FF36725-3200-489F-8E5A-08E6DA599D4E.html",
							"GUID-9FF36725-3200-489F-8E5A-08E6DA599D4E.html",
							"GUID-9FF36725-3200-489F-8E5A-08E6DA599D4E.html",
							"GUID-9FF36725-3200-489F-8E5A-08E6DA599D4E.html",
							"GUID-9FF36725-3200-489F-8E5A-08E6DA599D4E.html",
							"GUID-9FF36725-3200-489F-8E5A-08E6DA599D4E.html",
							"GUID-1B8BAD12-85A8-4E0E-87A8-CE8E4D5867C9.html",
							"GUID-1B8BAD12-85A8-4E0E-87A8-CE8E4D5867C9.html",
							"GUID-1B8BAD12-85A8-4E0E-87A8-CE8E4D5867C9.html",
							"GUID-1B8BAD12-85A8-4E0E-87A8-CE8E4D5867C9.html",
							"GUID-1B8BAD12-85A8-4E0E-87A8-CE8E4D5867C9.html",
							"GUID-1B8BAD12-85A8-4E0E-87A8-CE8E4D5867C9.html",
							"GUID-1B8BAD12-85A8-4E0E-87A8-CE8E4D5867C9.html",
							"GUID-1B8BAD12-85A8-4E0E-87A8-CE8E4D5867C9.html",
							"GUID-1B8BAD12-85A8-4E0E-87A8-CE8E4D5867C9.html",
							"GUID-8F94C089-C2AF-4EEF-8599-616DBF8F18E8.html",
							"GUID-8F94C089-C2AF-4EEF-8599-616DBF8F18E8.html",
							"GUID-8F94C089-C2AF-4EEF-8599-616DBF8F18E8.html",
							"GUID-8F94C089-C2AF-4EEF-8599-616DBF8F18E8.html",
							"GUID-8F94C089-C2AF-4EEF-8599-616DBF8F18E8.html",
							"GUID-8F94C089-C2AF-4EEF-8599-616DBF8F18E8.html",
							"GUID-8F94C089-C2AF-4EEF-8599-616DBF8F18E8.html",
							"GUID-8F94C089-C2AF-4EEF-8599-616DBF8F18E8.html",
							"GUID-8F94C089-C2AF-4EEF-8599-616DBF8F18E8.html",
							"GUID-6662B9A5-918C-40DB-8E2E-167EB1CCEEC3.html",
							"GUID-6662B9A5-918C-40DB-8E2E-167EB1CCEEC3.html",
							"GUID-6662B9A5-918C-40DB-8E2E-167EB1CCEEC3.html",
							"GUID-6662B9A5-918C-40DB-8E2E-167EB1CCEEC3.html",
							"GUID-6662B9A5-918C-40DB-8E2E-167EB1CCEEC3.html",
							"GUID-6662B9A5-918C-40DB-8E2E-167EB1CCEEC3.html",
							"GUID-6662B9A5-918C-40DB-8E2E-167EB1CCEEC3.html",
							"GUID-6662B9A5-918C-40DB-8E2E-167EB1CCEEC3.html",
							"GUID-6662B9A5-918C-40DB-8E2E-167EB1CCEEC3.html",
							"GUID-00C1F23A-49A2-48A7-B812-4CAD4C73DD23.html",
							"GUID-00C1F23A-49A2-48A7-B812-4CAD4C73DD23.html",
							"GUID-00C1F23A-49A2-48A7-B812-4CAD4C73DD23.html",
							"GUID-00C1F23A-49A2-48A7-B812-4CAD4C73DD23.html",
							"GUID-00C1F23A-49A2-48A7-B812-4CAD4C73DD23.html",
							"GUID-00C1F23A-49A2-48A7-B812-4CAD4C73DD23.html",
							"GUID-00C1F23A-49A2-48A7-B812-4CAD4C73DD23.html",
							"GUID-00C1F23A-49A2-48A7-B812-4CAD4C73DD23.html",
							"GUID-00C1F23A-49A2-48A7-B812-4CAD4C73DD23.html",
							"GUID-81092C4F-2D4E-475B-B44E-39B30242F764.html",
							"GUID-81092C4F-2D4E-475B-B44E-39B30242F764.html",
							"GUID-81092C4F-2D4E-475B-B44E-39B30242F764.html",
							"GUID-81092C4F-2D4E-475B-B44E-39B30242F764.html",
							"GUID-81092C4F-2D4E-475B-B44E-39B30242F764.html",
							"GUID-81092C4F-2D4E-475B-B44E-39B30242F764.html",
							"GUID-81092C4F-2D4E-475B-B44E-39B30242F764.html",
							"GUID-81092C4F-2D4E-475B-B44E-39B30242F764.html",
							"GUID-81092C4F-2D4E-475B-B44E-39B30242F764.html",
							"GUID-8B025891-809C-47BF-B1DF-95AFBFCD6D6C.html",
							"GUID-8B025891-809C-47BF-B1DF-95AFBFCD6D6C.html",
							"GUID-8B025891-809C-47BF-B1DF-95AFBFCD6D6C.html",
							"GUID-8B025891-809C-47BF-B1DF-95AFBFCD6D6C.html",
							"GUID-8B025891-809C-47BF-B1DF-95AFBFCD6D6C.html",
							"GUID-8B025891-809C-47BF-B1DF-95AFBFCD6D6C.html",
							"GUID-8B025891-809C-47BF-B1DF-95AFBFCD6D6C.html",
							"GUID-8B025891-809C-47BF-B1DF-95AFBFCD6D6C.html",
							"GUID-8B025891-809C-47BF-B1DF-95AFBFCD6D6C.html",
							"GUID-A2A1EDAC-3C1D-4A42-AC6F-E7CD237D90E4.html",
							"GUID-A2A1EDAC-3C1D-4A42-AC6F-E7CD237D90E4.html",
							"GUID-A2A1EDAC-3C1D-4A42-AC6F-E7CD237D90E4.html",
							"GUID-A2A1EDAC-3C1D-4A42-AC6F-E7CD237D90E4.html",
							"GUID-A95FDE79-4A31-43E5-B7E2-A923B08DBEFA.html",
							"GUID-220B3861-36A8-4139-8554-F40D11E3C262.html",
							"GUID-8EFAC845-3358-4B69-A3C6-8207013B9727.html",
							"GUID-1CC5DBE3-7849-4F27-B8F6-C13BB5E48EB1.html",
							"GUID-60271DE1-2B32-4ED7-8DB8-613930EFDA20.html",
							"GUID-FBA5ADF9-861F-4690-AAE9-9188BCD3A6AE.html",
							"GUID-FBA5ADF9-861F-4690-AAE9-9188BCD3A6AE.html",
							"GUID-FBA5ADF9-861F-4690-AAE9-9188BCD3A6AE.html",
							"GUID-FBA5ADF9-861F-4690-AAE9-9188BCD3A6AE.html",
							"GUID-D8B8B187-7B26-4827-9D56-D5876A55BAD2.html",
							"GUID-D8B8B187-7B26-4827-9D56-D5876A55BAD2.html",
							"GUID-D8B8B187-7B26-4827-9D56-D5876A55BAD2.html",
							"GUID-D8B8B187-7B26-4827-9D56-D5876A55BAD2.html",
							"GUID-D8B8B187-7B26-4827-9D56-D5876A55BAD2.html",
							"GUID-D8B8B187-7B26-4827-9D56-D5876A55BAD2.html",
							"GUID-D8B8B187-7B26-4827-9D56-D5876A55BAD2.html",
							"GUID-CA6DD1FB-AAB0-49BC-ABCB-EC6E66CA731C.html",
							"GUID-CA6DD1FB-AAB0-49BC-ABCB-EC6E66CA731C.html",
							"GUID-CA6DD1FB-AAB0-49BC-ABCB-EC6E66CA731C.html",
							"GUID-CA6DD1FB-AAB0-49BC-ABCB-EC6E66CA731C.html",
							"GUID-CA6DD1FB-AAB0-49BC-ABCB-EC6E66CA731C.html",
							"GUID-CA6DD1FB-AAB0-49BC-ABCB-EC6E66CA731C.html",
							"GUID-CA6DD1FB-AAB0-49BC-ABCB-EC6E66CA731C.html",
							"GUID-EE9DB5C9-8049-4860-B068-54DD0CFFDBA8.html",
							"GUID-EE9DB5C9-8049-4860-B068-54DD0CFFDBA8.html",
							"GUID-EE9DB5C9-8049-4860-B068-54DD0CFFDBA8.html",
							"GUID-EE9DB5C9-8049-4860-B068-54DD0CFFDBA8.html",
							"GUID-EE9DB5C9-8049-4860-B068-54DD0CFFDBA8.html",
							"GUID-EE9DB5C9-8049-4860-B068-54DD0CFFDBA8.html",
							"GUID-EE9DB5C9-8049-4860-B068-54DD0CFFDBA8.html",
							"GUID-EE9DB5C9-8049-4860-B068-54DD0CFFDBA8.html",
							"GUID-018CC3A0-CE2F-4BE6-AC40-66721317171E.html",
							"GUID-018CC3A0-CE2F-4BE6-AC40-66721317171E.html",
							"GUID-018CC3A0-CE2F-4BE6-AC40-66721317171E.html",
							"GUID-018CC3A0-CE2F-4BE6-AC40-66721317171E.html",
							"GUID-018CC3A0-CE2F-4BE6-AC40-66721317171E.html",
							"GUID-018CC3A0-CE2F-4BE6-AC40-66721317171E.html",
							"GUID-018CC3A0-CE2F-4BE6-AC40-66721317171E.html",
							"GUID-018CC3A0-CE2F-4BE6-AC40-66721317171E.html",
							"GUID-8CB24C47-AD8B-40C0-BF24-1D43127B48D2.html",
							"GUID-8CB24C47-AD8B-40C0-BF24-1D43127B48D2.html",
							"GUID-8CB24C47-AD8B-40C0-BF24-1D43127B48D2.html",
							"GUID-8CB24C47-AD8B-40C0-BF24-1D43127B48D2.html",
							"GUID-8CB24C47-AD8B-40C0-BF24-1D43127B48D2.html",
							"GUID-8CB24C47-AD8B-40C0-BF24-1D43127B48D2.html",
							"GUID-8CB24C47-AD8B-40C0-BF24-1D43127B48D2.html",
							"GUID-8CB24C47-AD8B-40C0-BF24-1D43127B48D2.html",
							"GUID-4E896D85-86B1-4721-880B-214CEE3819BE.html",
							"GUID-8B486B65-413F-4727-A2DE-721EA859AA8D.html",
							"GUID-E1E29C95-7504-4508-8208-101D4234420E.html",
							"GUID-9F92936D-DEC9-4403-BC8D-8CAF14F19639.html",
							"GUID-A9D08F5B-A721-44F2-9668-448E48C8192C.html",
							"GUID-95B97160-5425-444C-A258-8746A620D3F9.html",
							"GUID-95B97160-5425-444C-A258-8746A620D3F9.html",
							"GUID-95B97160-5425-444C-A258-8746A620D3F9.html",
							"GUID-95B97160-5425-444C-A258-8746A620D3F9.html",
							"GUID-95B97160-5425-444C-A258-8746A620D3F9.html",
							"GUID-95B97160-5425-444C-A258-8746A620D3F9.html",
							"GUID-95B97160-5425-444C-A258-8746A620D3F9.html",
							"GUID-95B97160-5425-444C-A258-8746A620D3F9.html",
							"GUID-95B97160-5425-444C-A258-8746A620D3F9.html",
							"GUID-8B41FF7D-0488-4893-9701-BDF32DB8BBDA.html",
							"GUID-8B41FF7D-0488-4893-9701-BDF32DB8BBDA.html",
							"GUID-8B41FF7D-0488-4893-9701-BDF32DB8BBDA.html",
							"GUID-8B41FF7D-0488-4893-9701-BDF32DB8BBDA.html",
							"GUID-8B41FF7D-0488-4893-9701-BDF32DB8BBDA.html",
							"GUID-8B41FF7D-0488-4893-9701-BDF32DB8BBDA.html",
							"GUID-8B41FF7D-0488-4893-9701-BDF32DB8BBDA.html",
							"GUID-8B41FF7D-0488-4893-9701-BDF32DB8BBDA.html",
							"GUID-8B41FF7D-0488-4893-9701-BDF32DB8BBDA.html",
							"GUID-CD78B395-BA9B-4279-B2D4-BD3C9E156205.html",
							"GUID-CD78B395-BA9B-4279-B2D4-BD3C9E156205.html",
							"GUID-CD78B395-BA9B-4279-B2D4-BD3C9E156205.html",
							"GUID-CD78B395-BA9B-4279-B2D4-BD3C9E156205.html",
							"GUID-7C8F8FE0-76A1-4138-81CD-E2A7D3533A92.html",
							"GUID-7C8F8FE0-76A1-4138-81CD-E2A7D3533A92.html",
							"GUID-7C8F8FE0-76A1-4138-81CD-E2A7D3533A92.html",
							"GUID-7C8F8FE0-76A1-4138-81CD-E2A7D3533A92.html",
							"GUID-F2657150-3DEB-4EEC-B99F-22FCD8A400C0.html",
							"GUID-0C282E5D-31BB-452A-B8CB-BEF5DDA61428.html",
							"GUID-0C282E5D-31BB-452A-B8CB-BEF5DDA61428.html",
							"GUID-0C282E5D-31BB-452A-B8CB-BEF5DDA61428.html",
							"GUID-0C282E5D-31BB-452A-B8CB-BEF5DDA61428.html",
							"GUID-0C282E5D-31BB-452A-B8CB-BEF5DDA61428.html",
							"GUID-B12673FB-2A40-402F-A99F-3B767C712E77.html",
							"GUID-A3663EE4-FB02-4CF3-BD0E-2BE3FED24123.html",
							"GUID-84FD9F74-C47E-483C-BC6D-6C0F486D7D7D.html",
							"GUID-621D854B-54BF-4473-91C6-B37A25840333.html",
							"GUID-621D854B-54BF-4473-91C6-B37A25840333.html",
							"GUID-621D854B-54BF-4473-91C6-B37A25840333.html",
							"GUID-621D854B-54BF-4473-91C6-B37A25840333.html",
							"GUID-621D854B-54BF-4473-91C6-B37A25840333.html",
							"GUID-621D854B-54BF-4473-91C6-B37A25840333.html",
							"GUID-621D854B-54BF-4473-91C6-B37A25840333.html",
							"GUID-621D854B-54BF-4473-91C6-B37A25840333.html",
							"GUID-7464B9B1-E30E-4C83-BFF4-C8FBC8AE2B97.html",
							"GUID-7464B9B1-E30E-4C83-BFF4-C8FBC8AE2B97.html",
							"GUID-7464B9B1-E30E-4C83-BFF4-C8FBC8AE2B97.html",
							"GUID-7464B9B1-E30E-4C83-BFF4-C8FBC8AE2B97.html",
							"GUID-7464B9B1-E30E-4C83-BFF4-C8FBC8AE2B97.html",
							"GUID-7464B9B1-E30E-4C83-BFF4-C8FBC8AE2B97.html",
							"GUID-7464B9B1-E30E-4C83-BFF4-C8FBC8AE2B97.html",
							"GUID-7464B9B1-E30E-4C83-BFF4-C8FBC8AE2B97.html",
							"GUID-7464B9B1-E30E-4C83-BFF4-C8FBC8AE2B97.html",
							"GUID-B3A181FF-1B0E-4CF1-8EBB-0D9000DB82EF.html",
							"GUID-B3A181FF-1B0E-4CF1-8EBB-0D9000DB82EF.html",
							"GUID-B3A181FF-1B0E-4CF1-8EBB-0D9000DB82EF.html",
							"GUID-B3A181FF-1B0E-4CF1-8EBB-0D9000DB82EF.html",
							"GUID-B3A181FF-1B0E-4CF1-8EBB-0D9000DB82EF.html",
							"GUID-B3A181FF-1B0E-4CF1-8EBB-0D9000DB82EF.html",
							"GUID-B3A181FF-1B0E-4CF1-8EBB-0D9000DB82EF.html",
							"GUID-B3A181FF-1B0E-4CF1-8EBB-0D9000DB82EF.html",
							"GUID-B3A181FF-1B0E-4CF1-8EBB-0D9000DB82EF.html",
							"GUID-AEB8DFE3-0BED-4D89-98D8-78F367814AA1.html",
							"GUID-AEB8DFE3-0BED-4D89-98D8-78F367814AA1.html",
							"GUID-AEB8DFE3-0BED-4D89-98D8-78F367814AA1.html",
							"GUID-AEB8DFE3-0BED-4D89-98D8-78F367814AA1.html",
							"GUID-AEB8DFE3-0BED-4D89-98D8-78F367814AA1.html",
							"GUID-AEB8DFE3-0BED-4D89-98D8-78F367814AA1.html",
							"GUID-AEB8DFE3-0BED-4D89-98D8-78F367814AA1.html",
							"GUID-AEB8DFE3-0BED-4D89-98D8-78F367814AA1.html",
							"GUID-AEB8DFE3-0BED-4D89-98D8-78F367814AA1.html",
							"GUID-C0B40EB5-8C77-4961-8932-C0C247B4FA29.html",
							"GUID-C0B40EB5-8C77-4961-8932-C0C247B4FA29.html",
							"GUID-C0B40EB5-8C77-4961-8932-C0C247B4FA29.html",
							"GUID-C0B40EB5-8C77-4961-8932-C0C247B4FA29.html",
							"GUID-C0B40EB5-8C77-4961-8932-C0C247B4FA29.html",
							"GUID-C0B40EB5-8C77-4961-8932-C0C247B4FA29.html",
							"GUID-C0B40EB5-8C77-4961-8932-C0C247B4FA29.html",
							"GUID-C0B40EB5-8C77-4961-8932-C0C247B4FA29.html",
							"GUID-C0B40EB5-8C77-4961-8932-C0C247B4FA29.html",
							"GUID-E0E5E6A7-18F0-4315-B9C1-E4D3011230A8.html",
							"GUID-E0E5E6A7-18F0-4315-B9C1-E4D3011230A8.html",
							"GUID-E0E5E6A7-18F0-4315-B9C1-E4D3011230A8.html",
							"GUID-E0E5E6A7-18F0-4315-B9C1-E4D3011230A8.html",
							"GUID-E0E5E6A7-18F0-4315-B9C1-E4D3011230A8.html",
							"GUID-E0E5E6A7-18F0-4315-B9C1-E4D3011230A8.html",
							"GUID-E0E5E6A7-18F0-4315-B9C1-E4D3011230A8.html",
							"GUID-E0E5E6A7-18F0-4315-B9C1-E4D3011230A8.html",
							"GUID-E0E5E6A7-18F0-4315-B9C1-E4D3011230A8.html",
							"GUID-0A58D291-CDCA-4C22-BAE0-D55E4517D530.html",
							"GUID-0A58D291-CDCA-4C22-BAE0-D55E4517D530.html",
							"GUID-0A58D291-CDCA-4C22-BAE0-D55E4517D530.html",
							"GUID-0A58D291-CDCA-4C22-BAE0-D55E4517D530.html",
							"GUID-0A58D291-CDCA-4C22-BAE0-D55E4517D530.html",
							"GUID-0A58D291-CDCA-4C22-BAE0-D55E4517D530.html",
							"GUID-0A58D291-CDCA-4C22-BAE0-D55E4517D530.html",
							"GUID-0A58D291-CDCA-4C22-BAE0-D55E4517D530.html",
							"GUID-0A58D291-CDCA-4C22-BAE0-D55E4517D530.html",
							"GUID-0C07CB6E-5CF9-4C7E-AC48-965198152AAF.html",
							"GUID-0C07CB6E-5CF9-4C7E-AC48-965198152AAF.html",
							"GUID-0C07CB6E-5CF9-4C7E-AC48-965198152AAF.html",
							"GUID-0C07CB6E-5CF9-4C7E-AC48-965198152AAF.html",
							"GUID-0C07CB6E-5CF9-4C7E-AC48-965198152AAF.html",
							"GUID-FA6D55E0-FFF4-4BE5-A80C-C57E20F20172.html",
							"GUID-FA6D55E0-FFF4-4BE5-A80C-C57E20F20172.html",
							"GUID-FA6D55E0-FFF4-4BE5-A80C-C57E20F20172.html",
							"GUID-FA6D55E0-FFF4-4BE5-A80C-C57E20F20172.html",
							"GUID-FA6D55E0-FFF4-4BE5-A80C-C57E20F20172.html",
							"GUID-9C3076C9-0171-469B-B059-048A45B45047.html",
							"GUID-9C3076C9-0171-469B-B059-048A45B45047.html",
							"GUID-9C3076C9-0171-469B-B059-048A45B45047.html",
							"GUID-9C3076C9-0171-469B-B059-048A45B45047.html",
							"GUID-9C3076C9-0171-469B-B059-048A45B45047.html",
							"GUID-ABD93EB0-3099-42B8-9559-30F072F02739.html",
							"GUID-ABD93EB0-3099-42B8-9559-30F072F02739.html",
							"GUID-ABD93EB0-3099-42B8-9559-30F072F02739.html",
							"GUID-ABD93EB0-3099-42B8-9559-30F072F02739.html",
							"GUID-ABD93EB0-3099-42B8-9559-30F072F02739.html",
							"GUID-48BB87BF-AAC0-4DE0-A21F-6F00E5B1FF24.html",
							"GUID-48BB87BF-AAC0-4DE0-A21F-6F00E5B1FF24.html",
							"GUID-48BB87BF-AAC0-4DE0-A21F-6F00E5B1FF24.html",
							"GUID-48BB87BF-AAC0-4DE0-A21F-6F00E5B1FF24.html",
							"GUID-48BB87BF-AAC0-4DE0-A21F-6F00E5B1FF24.html",
							"GUID-48BB87BF-AAC0-4DE0-A21F-6F00E5B1FF24.html",
							"GUID-48BB87BF-AAC0-4DE0-A21F-6F00E5B1FF24.html",
							"GUID-48BB87BF-AAC0-4DE0-A21F-6F00E5B1FF24.html",
							"GUID-95D6239D-4487-418B-ADEC-587C659BFEE0.html",
							"GUID-95D6239D-4487-418B-ADEC-587C659BFEE0.html",
							"GUID-95D6239D-4487-418B-ADEC-587C659BFEE0.html",
							"GUID-95D6239D-4487-418B-ADEC-587C659BFEE0.html",
							"GUID-95D6239D-4487-418B-ADEC-587C659BFEE0.html",
							"GUID-2155582A-0939-41A5-91DE-53D1FC6F1003.html",
							"GUID-2155582A-0939-41A5-91DE-53D1FC6F1003.html",
							"GUID-2155582A-0939-41A5-91DE-53D1FC6F1003.html",
							"GUID-2155582A-0939-41A5-91DE-53D1FC6F1003.html",
							"GUID-2155582A-0939-41A5-91DE-53D1FC6F1003.html",
							"GUID-85AB674B-2F1D-4636-87B5-36ACBE66A8BE.html"];

var SearchTitles = ["MPLAB® Harmony Smart Energy Library",
"Driver Libraries",
"PLC PHY Driver",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"DRV_PLC_PHY_Initialize Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_Open Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_TxRequest Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"DRV_PLC_PHY_PIBGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_PIBSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_TxCfmCallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_DataIndCallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_ExceptionCallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_SleepDisableCallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_ExternalInterruptHandler Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_Status Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_Tasks Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_Sleep Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_EnableTX Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_INIT Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_PLC_HAL_INTERFACE Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_PLC_PLIB_INTERFACE Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_PLC_PHY_TX_CFM_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_DATA_IND_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_SLEEP_IND_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_EXCEPTION_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_PLC_PHY_EXCEPTION Enum",
"C",
"Summary",
"Description",
"G3 Data types and constants",
"DRV_PLC_PHY_ID Enum",
"C",
"Summary",
"Description",
"DRV_PLC_PHY_IDs",
"PLC_ID_HOST_DESCRIPTION_ID (0x0100)",
"PLC_ID_HOST_MODEL_ID (0x010A)",
"PLC_ID_HOST_PHY_ID (0x010C)",
"PLC_ID_HOST_PRODUCT_ID (0x0110)",
"PLC_ID_HOST_VERSION_ID (0x0112)",
"PLC_ID_HOST_BAND_ID (0x0116)",
"PLC_ID_TIME_REF_ID (0x0200)",
"PLC_ID_PRODID (0x4000)",
"PLC_ID_MODEL (0x4001)",
"PLC_ID_VERSION_STR (0x4002)",
"PLC_ID_VERSION_NUM (0x4003)",
"PLC_ID_TONE_MASK (0x4004)",
"PLC_ID_TONE_MAP_RSP_DATA (0x4005)",
"PLC_ID_TX_TOTAL (0x4006)",
"PLC_ID_TX_TOTAL_BYTES (0x4007)",
"PLC_ID_TX_TOTAL_ERRORS (0x4008)",
"PLC_ID_TX_BAD_BUSY_TX (0x4009)",
"PLC_ID_TX_BAD_BUSY_CHANNEL (0x400A)",
"PLC_ID_TX_BAD_LEN (0x400B)",
"PLC_ID_TX_BAD_FORMAT (0x400C)",
"PLC_ID_TX_TIMEOUT (0x400D)",
"PLC_ID_RX_TOTAL (0x400E)",
"PLC_ID_RX_TOTAL_BYTES (0x400F)",
"PLC_ID_RX_RS_ERRORS (0x4010)",
"PLC_ID_RX_EXCEPTIONS (0x4011)",
"PLC_ID_RX_BAD_LEN (0x4012)",
"PLC_ID_RX_BAD_CRC_FCH (0x4013)",
"PLC_ID_RX_FALSE_POSITIVE (0x4014)",
"PLC_ID_RX_BAD_FORMAT (0x4015)",
"PLC_ID_ENABLE_AUTO_NOISE_CAPTURE (0x4016)",
"PLC_ID_TIME_BETWEEN_NOISE_CAPTURES (0x4017)",
"PLC_ID_DELAY_NOISE_CAPTURE_AFTER_RX (0x4018)",
"PLC_ID_RRC_NOTCH_ACTIVE (0x4019)",
"PLC_ID_RRC_NOTCH_INDEX (0x401A)",
"PLC_ID_NOISE_PEAK_POWER (0x401B)",
"PLC_ID_CRC_TX_RX_CAPABILITY (0x401C)",
"PLC_ID_RX_BAD_CRC_PAY (0x401D)",
"PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x401E)",
"PLC_ID_CFG_IMPEDANCE (0x401F)",
"PLC_ID_ZC_PERIOD (0x4020)",
"PLC_ID_FCH_SYMBOLS (0x4021)",
"PLC_ID_PAY_SYMBOLS_TX (0x4022)",
"PLC_ID_PAY_SYMBOLS_RX (0x4023)",
"PLC_ID_RRC_NOTCH_AUTODETECT (0x4024)",
"PLC_ID_MAX_RMS_TABLE_HI (0x4025)",
"PLC_ID_MAX_RMS_TABLE_VLO (0x4026)",
"PLC_ID_THRESHOLDS_TABLE_HI (0x4027)",
"PLC_ID_THRESHOLDS_TABLE_LO (0x4028)",
"PLC_ID_THRESHOLDS_TABLE_VLO (0x4029)",
"PLC_ID_PREDIST_COEF_TABLE_HI (0x402A)",
"PLC_ID_PREDIST_COEF_TABLE_LO (0x402B)",
"PLC_ID_PREDIST_COEF_TABLE_VLO (0x402C)",
"PLC_ID_GAIN_TABLE_HI (0x402D)",
"PLC_ID_GAIN_TABLE_LO (0x402E)",
"PLC_ID_GAIN_TABLE_VLO (0x402F)",
"PLC_ID_DACC_TABLE_CFG (0x4030)",
"PLC_ID_NUM_TX_LEVELS (0x4032)",
"PLC_ID_CORRECTED_RMS_CALC (0x4033)",
"PLC_ID_RRC_NOTCH_THR_ON (0x4034)",
"PLC_ID_RRC_NOTCH_THR_OFF (0x4035)",
"PLC_ID_CURRENT_GAIN (0x4036)",
"PLC_ID_ZC_CONF_INV (0x4037)",
"PLC_ID_ZC_CONF_FREQ (0x4038)",
"PLC_ID_ZC_CONF_DELAY (0x4039)",
"PLC_ID_NOISE_PER_CARRIER (0x403A)",
"PLC_ID_SYNC_XCORR_THRESHOLD (0x403B)",
"PLC_ID_SYNC_XCORR_PEAK_VALUE (0x403C)",
"PLC_ID_SYNC_SYNCM_THRESHOLD (0x403D)",
"PLC_ID_TONE_MAP_RSP_ENABLED_MODS (0x403E)",
"PLC_ID_PPM_CALIB_ON (0x403F)",
"PLC_ID_SFO_ESTIMATION_LAST_RX (0x4040)",
"PLC_ID_PDC_LAST_RX (0x4041)",
"PLC_ID_MAX_PSDU_LEN_PARAMS (0x4042)",
"PLC_ID_MAX_PSDU_LEN (0x4043)",
"PLC_ID_RESET_STATS (0x4044)",
"PLC_ID_IC_DRIVER_CFG (0x4045)",
"PLC_ID_RX_CHN_EST_REAL (0x4046)",
"PLC_ID_RX_CHN_EST_IMAG (0x4047)",
"PLC_ID_TX_DISABLE (0x4048)",
"PLC_ID_TX_HIGH_TEMP_120 (0x4049)",
"PLC_ID_TX_CANCELLED (0x404A)",
"PLC_ID_ZC_VALUE (0x404B)",
"PLC_ID_PDC_RX_LAST_RX (0x404C)",
"PLC_ID_PDC_ZC_TIME_LAST_RX (0x404D)",
"PLC_ID_PDC_ZC_PERIOD_LAST_RX (0x404E)",
"PLC_ID_PREAMBLE_NUM_SYNCP (0x404F)",
"DRV_PLC_PHY_MOD_TYPE Enum",
"C",
"Summary",
"Description",
"DRV_PLC_PHY_MOD_TYPE Enum",
"C",
"Summary",
"Description",
"DRV_PLC_PHY_DEL_TYPE Enum",
"C",
"Summary",
"Description",
"DRV_PLC_PHY_TX_RESULT Enum",
"C",
"Summary",
"Description",
"DRV_PLC_PHY_TONE_MAP_RSP Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_PLC_PHY_MAX_PSDU_LEN_PARAMS Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_PLC_PHY_TRANSMISSION_OBJ Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_PLC_PHY_TRANSMISSION_CFM_OBJ Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_PLC_PHY_RECEPTION_OBJ Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_PLC_PHY_PIB_OBJ Struct",
"C",
"Summary",
"Description",
"Remarks",
"PRIME Data types and constants",
"DRV_PLC_PHY_ID Enum",
"C",
"Summary",
"Description",
"DRV_PLC_PHY_IDs",
"PLC_ID_HOST_DESCRIPTION_ID (0x0100)",
"PLC_ID_HOST_MODEL_ID (0x010A)",
"PLC_ID_HOST_PHY_ID (0x010C)",
"PLC_ID_HOST_PRODUCT_ID (0x0110)",
"PLC_ID_HOST_VERSION_ID (0x0112)",
"PLC_ID_HOST_BAND_ID (0x0116)",
"PLC_ID_TIME_REF_ID (0x0200)",
"PLC_ID_PRODID (0x4000)",
"PLC_ID_MODEL (0x4001)",
"PLC_ID_VERSION_STR (0x4002)",
"PLC_ID_VERSION_NUM (0x4003)",
"PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x4004)",
"PLC_ID_CFG_IMPEDANCE (0x4005)",
"PLC_ID_ZC_TIME (0x406)",
"PLC_ID_RX_PAY_SYMBOLS (0x4007)",
"PLC_ID_TX_PAY_SYMBOLS (0x4008)",
"PLC_ID_MAX_RMS_TABLE_HI (0x400A)",
"PLC_ID_MAX_RMS_TABLE_VLO (0x400B)",
"PLC_ID_THRESHOLDS_TABLE_HI (0x400C)",
"PLC_ID_THRESHOLDS_TABLE_LO (0x400D)",
"PLC_ID_THRESHOLDS_TABLE_VLO (0x400E)",
"PLC_ID_PREDIST_COEF_TABLE_HI (0x400F)",
"PLC_ID_PREDIST_COEF_TABLE_LO (0x4010)",
"PLC_ID_PREDIST_COEF_TABLE_VLO (0x4011)",
"PLC_ID_GAIN_TABLE_HI (0x4012)",
"PLC_ID_GAIN_TABLE_LO (0x4013)",
"PLC_ID_GAIN_TABLE_VLO (0x4014)",
"PLC_ID_DACC_TABLE_CFG (0x4015)",
"PLC_ID_CHANNEL_CFG (0x4016)",
"PLC_ID_NUM_TX_LEVELS (0x4017)",
"PLC_ID_CORRECTED_RMS_CALC (0x4018)",
"PLC_ID_CURRENT_GAIN (0x4019)",
"PLC_ID_ZC_CONF_INV (0x401A)",
"PLC_ID_ZC_CONF_FREQ (0x401B)",
"PLC_ID_ZC_CONF_DELAY (0x401C)",
"PLC_ID_SIGNAL_CAPTURE_START (0x401D)",
"PLC_ID_SIGNAL_CAPTURE_STATUS (0x401E)",
"PLC_ID_SIGNAL_CAPTURE_FRAGMENT (0x401F)",
"PLC_ID_SIGNAL_CAPTURE_DATA (0x4020)",
"PLC_ID_ENABLE_AUTO_NOISE_CAPTURE (0x4021)",
"PLC_ID_TIME_BETWEEN_NOISE_CAPTURES (0x4022)",
"PLC_ID_DELAY_NOISE_CAPTURE_AFTER_RX (0x4023)",
"PLC_ID_RRC_NOTCH_ACTIVE (0x4024)",
"PLC_ID_RRC_NOTCH_INDEX (0x4025)",
"PLC_ID_NOISE_PEAK_POWER (0x4026)",
"PLC_ID_RRC_NOTCH_AUTODETECT (0x4027)",
"PLC_ID_RRC_NOTCH_THR_ON (0x4028)",
"PLC_ID_RRC_NOTCH_THR_OFF (0x4029)",
"PLC_ID_TX_TOTAL (0x402A)",
"PLC_ID_TX_TOTAL_BYTES (0x402B)",
"PLC_ID_TX_TOTAL_ERRORS (0x402C)",
"PLC_ID_TX_BAD_BUSY_TX (0x402D)",
"PLC_ID_TX_BAD_BUSY_CHANNEL (0x402E)",
"PLC_ID_TX_BAD_LEN (0x402F)",
"PLC_ID_TX_BAD_FORMAT (0x4030)",
"PLC_ID_TX_TIMEOUT (0x4031)",
"PLC_ID_RX_TOTAL (0x4032)",
"PLC_ID_RX_TOTAL_BYTES (0x4033)",
"PLC_ID_RX_EXCEPTIONS (0x4034)",
"PLC_ID_RX_BAD_LEN (0x4035)",
"PLC_ID_RX_BAD_CRC_FCH (0x4036)",
"PLC_ID_RX_FALSE_POSITIVE (0x4037)",
"PLC_ID_RX_BAD_FORMAT (0x4038)",
"PLC_ID_NOISE_PER_CARRIER (0x4039)",
"PLC_ID_PPM_CALIB_ON (0x403A)",
"PLC_ID_ZC_PERIOD (0x403B)",
"PLC_ID_SYNC_XCORR_THRESHOLD (0x403C)",
"PLC_ID_NUM_CHANNELS (0x403D)",
"PLC_ID_MAX_NUM_CHANNELS (0x403E)",
"PLC_ID_PREDIST_COEF_TABLE_HI_2 (0x403F)",
"PLC_ID_PREDIST_COEF_TABLE_LO_2 (0x4040)",
"PLC_ID_PREDIST_COEF_TABLE_VLO_2 (0x4041)",
"PLC_ID_NOISE_PER_CARRIER_2 (0x4042)",
"PLC_ID_RESET_STATS (0x4043)",
"PLC_ID_IC_DRIVER_CFG (0x4044)",
"PLC_ID_RX_CHN_EST_REAL (0x4045)",
"PLC_ID_RX_CHN_EST_IMAG (0x4046)",
"PLC_ID_RX_CHN_EST_REAL_2 (0x4047)",
"PLC_ID_RX_CHN_EST_IMAG_2 (0x4048)",
"PLC_ID_TX_DISABLE (0x4049)",
"PLC_ID_TX_HIGH_TEMP_120 (0x404A)",
"PLC_ID_TX_CANCELLED (0x404B)",
"PLC_ID_RX_CD_INFO (0x404C)",
"PLC_ID_SFO_ESTIMATION_LAST_RX (0x404D)",
"DRV_PLC_PHY_SCH Enum",
"C",
"Summary",
"Description",
"DRV_PLC_PHY_FRAME_TYPE Enum",
"C",
"Summary",
"Description",
"DRV_PLC_PHY_HEADER Enum",
"C",
"Summary",
"Description",
"DRV_PLC_PHY_CHANNEL Enum",
"C",
"Summary",
"Description",
"DRV_PLC_PHY_BUFFER_ID Enum",
"C",
"Summary",
"Description",
"DRV_PLC_PHY_TX_RESULT Enum",
"C",
"Summary",
"Description",
"DRV_PLC_PHY_SIGNAL_CAPTURE_STATE Enum",
"C",
"Summary",
"Description",
"DRV_PLC_PHY_SIGNAL_CAPTURE_INFO Enum",
"C",
"Summary",
"Description",
"DRV_PLC_PHY_TRANSMISSION_OBJ Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_PLC_PHY_TRANSMISSION_CFM_OBJ Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_PLC_PHY_RECEPTION_OBJ Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_PLC_PHY_PIB_OBJ Struct",
"C",
"Summary",
"Description",
"Remarks",
"G3 MAC RT Driver",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"DRV_G3_MACRT_Initialize Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_Open Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_TxRequest Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_PIBGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_PIBSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_GetTimerReference Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_TxCfmCallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_DataIndCallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_RxParamsIndCallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_MacSnifferCallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_CommStatusCallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_PhySnifferCallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_ExceptionCallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_ExternalInterruptHandler Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_Status Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_Tasks Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_SleepIndCallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_Sleep Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_EnableTX Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_EXCEPTION Enum",
"C",
"Summary",
"Description",
"DRV_G3_MACRT_TX_CFM_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_DATA_IND_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_RX_PARAMS_IND_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_MAC_SNIFFER_IND_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_COMM_STATUS_IND_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_PHY_SNIFFER_IND_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_EXCEPTION_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_G3_MACRT_SLEEP_IND_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"MAC_RT_TX_CFM_OBJ Struct",
"C",
"Summary",
"Description",
"Remarks",
"MAC_RT_RX_PARAMETERS_OBJ Struct",
"C",
"Summary",
"Description",
"Remarks",
"MAC_RT_STATUS Enum",
"C",
"Summary",
"Description",
"MAC_RT_PIB_OBJ Struct",
"C",
"Summary",
"Description",
"Remarks",
"MAC_RT_PIB Enum",
"C",
"Summary",
"Description",
"G3 MAC RT IBs",
"MAC_RT_PIB_MAX_BE (0x00000047)",
"MAC_RT_PIB_BSN (0x00000049)",
"MAC_RT_PIB_DSN (0x0000004C)",
"MAC_RT_PIB_MAX_CSMA_BACKOFFS (0x0000004E)",
"MAC_RT_PIB_MIN_BE (0x0000004F)",
"MAC_RT_PIB_PAN_ID (0x00000050)",
"MAC_RT_PIB_PROMISCUOUS_MODE (0x00000051)",
"MAC_RT_PIB_SHORT_ADDRESS (0x00000053)",
"MAC_RT_PIB_MAX_FRAME_RETRIES (0x00000059)",
"MAC_RT_PIB_DUPLICATE_DETECTION_TTL (0x00000078)",
"MAC_RT_PIB_HIGH_PRIORITY_WINDOW_SIZE (0x00000100)",
"MAC_RT_PIB_CSMA_NO_ACK_COUNT (0x00000106)",
"MAC_RT_PIB_BAD_CRC_COUNT (0x00000109)",
"MAC_RT_PIB_NEIGHBOUR_TABLE (0x0000010A)",
"MAC_RT_PIB_CSMA_FAIRNESS_LIMIT (0x0000010C)",
"MAC_RT_PIB_TMR_TTL (0x0000010D)",
"MAC_RT_PIB_POS_TABLE_ENTRY_TTL (0x0000010E)",
"MAC_RT_PIB_RC_COORD (0x0000010F)",
"MAC_RT_PIB_TONE_MASK (0x00000110)",
"MAC_RT_PIB_BEACON_RANDOMIZATION_WINDOW_LENGTH (0x00000111)",
"MAC_RT_PIB_A (0x00000112)",
"MAC_RT_PIB_K (0x00000113)",
"MAC_RT_PIB_MIN_CW_ATTEMPTS (0x00000114)",
"MAC_RT_PIB_CENELEC_LEGACY_MODE (0x00000115)",
"MAC_RT_PIB_FCC_LEGACY_MODE (0x00000116)",
"MAC_RT_PIB_BROADCAST_MAX_CW_ENABLE (0x0000011E)",
"MAC_RT_PIB_TRANSMIT_ATTEN (0x0000011F)",
"MAC_RT_PIB_POS_TABLE (0x00000120)",
"MAC_RT_PIB_POS_RECENT_ENTRY_THRESHOLD (0x00000121)",
"MAC_RT_PIB_POS_RECENT_ENTRIES (0x00000122)",
"MAC_RT_PIB_MANUF_EXTENDED_ADDRESS (0x08000001)",
"MAC_RT_PIB_MANUF_NEIGHBOUR_TABLE_ELEMENT (0x08000002)",
"MAC_RT_PIB_MANUF_BAND_INFORMATION (0x08000003)",
"MAC_RT_PIB_MANUF_FORCED_MOD_SCHEME (0x08000007)",
"MAC_RT_PIB_MANUF_FORCED_MOD_TYPE (0x08000008)",
"MAC_RT_PIB_MANUF_FORCED_TONEMAP (0x08000009)",
"MAC_RT_PIB_MANUF_FORCED_MOD_SCHEME_ON_TMRESPONSE (0x0800000A)",
"MAC_RT_PIB_MANUF_FORCED_MOD_TYPE_ON_TMRESPONSE (0x0800000B)",
"MAC_RT_PIB_MANUF_FORCED_TONEMAP_ON_TMRESPONSE (0x0800000C)",
"MAC_RT_PIB_MANUF_LBP_FRAME_RECEIVED (0x0800000F)",
"MAC_RT_PIB_MANUF_LNG_FRAME_RECEIVED (0x08000010)",
"MAC_RT_PIB_MANUF_NEIGHBOUR_TABLE_COUNT (0x08000012)",
"MAC_RT_PIB_MANUF_RX_OTHER_DESTINATION_COUNT (0x08000013)",
"MAC_RT_PIB_MANUF_RX_MAC_REPETITION_COUNT (0x08000015)",
"MAC_RT_PIB_MANUF_RX_SEGMENT_DECODE_ERROR_COUNT (0x0800001C)",
"MAC_RT_PIB_MANUF_ENABLE_MAC_SNIFFER (0x0800001D)",
"MAC_RT_PIB_MANUF_POS_TABLE_COUNT (0x0800001E)",
"MAC_RT_PIB_MANUF_RETRIES_LEFT_TO_FORCE_ROBO (0x0800001F)",
"MAC_RT_PIB_MANUF_MAC_RT_INTERNAL_VERSION (0x08000022)",
"MAC_RT_PIB_SLEEP_MODE (0x08000024)",
"MAC_RT_PIB_DEBUG_SET (0x08000025)",
"MAC_RT_PIB_DEBUG_READ (0x08000026)",
"MAC_RT_PIB_MANUF_POS_TABLE_ELEMENT (0x08000027)",
"MAC_RT_PIB_MANUF_TRICKLE_MIN_LQI (0x08000028)",
"MAC_RT_PIB_MANUF_NEIGHBOUR_LQI (0x08000029)",
"MAC_RT_PIB_MANUF_BEST_LQI (0x0800002A)",
"MAC_RT_PIB_TX_HIGH_PRIORITY (0x0800002B)",
"MAC_RT_PIB_GET_SET_ALL_MIB (0x08000100)",
"MAC_RT_PIB_MANUF_PHY_PARAM (0x08000020)",
"MAC_RT_PHY_PIB Enum",
"C",
"Summary",
"Description",
"DRV_G3_MACRT_INIT Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_PLC_HAL_INTERFACE Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_PLC_HAL_INTERFACE Struct",
"C",
"Summary",
"Description",
"Remarks",
"Metrology Driver",
"How the Metrology driver library works",
"Initialization process",
"Using The Library",
"Metrology driver Configurations",
"Library Interface",
"DRV_METROLOGY_Initialize Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_Open Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_Close Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_Start Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_IntegrationCallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_GetState Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_GetControl Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_GetStatus Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_GetAccData Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_GetHarData Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_GetCalibrationData Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_GetControlByDefault Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_SetControl Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_UpdateMeasurements Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_GetEnergyValue Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_GetRMSValue Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_GetRMSSign Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_GetEventsData Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_SetConfiguration Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"APP_METROLOGY_StartCalibration Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_UpdateCalibration Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_CalibrationIsCompleted Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_GetCalibrationResult Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_StartHarmonicAnalysis Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_HarmonicAnalysisIsRun Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_GetHarmonicAnalysisResult Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_RESULT Enum",
"C",
"Summary",
"Description",
"DRV_METROLOGY_START_MODE Enum",
"C",
"Summary",
"Description",
"DRV_METROLOGY_RMS_SIGN Enum",
"C",
"Summary",
"Description",
"DRV_METROLOGY_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_METROLOGY_SENSOR_TYPE Enum",
"C",
"Summary",
"Description",
"DRV_METROLOGY_GAIN_TYPE Enum",
"C",
"Summary",
"Description",
"DRV_METROLOGY_PHASE_ID Enum",
"C",
"Summary",
"Description",
"DRV_METROLOGY_CALIBRATION_REFS Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_METROLOGY_CALIBRATION Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_METROLOGY_AFE_EVENTS Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_METROLOGY_HARMONIC Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_METROLOGY_RMS_TYPE Enum",
"C",
"Summary",
"Description",
"DRV_METROLOGY_AFE_DATA Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_METROLOGY_CONFIGURATION Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_METROLOGY_STATE Enum",
"C",
"Summary",
"Description",
"DRV_METROLOGY_INIT Struct",
"C",
"Summary",
"Description",
"Remarks",
"Service Libraries",
"PLC PHY Coupling Service",
"How the Library Works",
"PLC PHY Transmission Capabilities",
"Transmission Modes",
"Equalization",
"Dynamic adaptation",
"PLC PHY Coupling parameters",
"Using The Library",
"Using The Library (G3-PLC)",
"Using The Library (PRIME)",
"Configuring The Library",
"Configuring via MCC",
"G3 Configuration Options",
"PRIME Configuration Options",
"Common Configuration Options",
"Modifying Generated Source Code",
"Library Interface",
"Library Interface (G3-PLC)",
"SRV_PCOUP_Get_Config Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PCOUP_Set_Config Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PCOUP_Get_Default_Branch Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PCOUP_Get_Phy_Band Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PLC_PCOUP_BRANCH Enum",
"C",
"Summary",
"Description",
"Remarks",
"SRV_PLC_PCOUP_DATA Struct",
"C",
"Summary",
"Description",
"Remarks",
"Library Interface (PRIME)",
"SRV_PCOUP_Get_Default_Channel Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PCOUP_Get_Channel_Config Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PCOUP_Set_Channel_Config Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PLC_PCOUP_CHANNEL_DATA Struct",
"C",
"Summary",
"Description",
"Remarks",
"PLC PHY Sniffer Service",
"How the Library Works",
"PLC PHY Frames Serialization",
"Parameters Encoded with Frames for Serialization",
"G3 parameters",
"PRIME parameters",
"PLC PHY Sniffer Configuration",
"G3 configuration params",
"PRIME configuration params",
"Using The Library",
"Configuring The Library",
"Library Interface",
"SRV_PSNIFFER_GetCommand Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSNIFFER_SerialRxMessage Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSNIFFER_SerialCfmMessage Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSNIFFER_SetTxMessage Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSNIFFER_SetRxPayloadSymbols Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSNIFFER_SetTxPayloadSymbols Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSNIFFER_SetPLCChannel Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSNIFFER_ConvertToneMask Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSNIFFER_COMMAND Enum",
"C - PRIME Implementation",
"C - G3 Implementation",
"Summary",
"Description",
"PLC PHY Serial Service",
"How the Library Works",
"PLC PHY API Serialization",
"Commands Accepted by Library",
"Commands Generated by Library",
"Using The Library",
"Configuring The Library",
"Library Interface",
"SRV_PSERIAL_GetCommand Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSERIAL_ParseGetPIB Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSERIAL_SerialGetPIB Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSERIAL_ParseSetPIB Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSERIAL_SerialSetPIB Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSERIAL_ParseTxMessage Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSERIAL_SerialRxMessage Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSERIAL_SerialCfmMessage Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PSERIAL_COMMAND Enum",
"C",
"Summary",
"Description",
"PLC PVDD Monitor Service",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"SRV_PVDDMON_CMP_MODE Enum",
"C",
"Summary",
"Description",
"SRV_PVDDMON_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"SRV_PVDDMON_Initialize Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"SRV_PVDDMON_Start Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PVDDMON_Restart Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PVDDMON_CallbackRegister Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"PLC CRC Service",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"SRV_PCRC_GetValue Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_PCRC_SetSNAValue Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"PCRC_HEADER_TYPE Enum",
"C",
"Summary",
"Description",
"PCRC_CRC_TYPE Enum",
"C",
"Summary",
"Description",
"USI Service",
"How the Library Works",
"USI Frame Format",
"USI Protocols",
"PHY Sniffer",
"PLC PHY Serial",
"Using The Library",
"Configuring The Library",
"Library Interface",
"SRV_USI_Initialize Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_USI_Open Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_USI_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_USI_Status Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_USI_CallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_USI_Tasks Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_USI_Send_Message Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_USI_PROTOCOL_ID Enum",
"C",
"Summary",
"Description",
"Remarks",
"SRV_USI_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"SRV_USI_HANDLE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SRV_USI_HANDLE_INVALID Macro",
"C",
"Summary",
"Description",
"Remarks",
"SRV_USI_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SRV_USI_DEV_DESC Struct",
"C",
"Summary",
"Description",
"Remarks",
"SRV_USI_INIT Struct",
"C",
"Summary",
"Description",
"Remarks",
"Demo Meter Application"];

var SearchInfo = [" MPLAB® Harmony Smart Energy Library The Smart Energy Library provides access to Narrow Band Power Line Communications (PLC) It supports widely used narrow-band PLC standards such as ITU G 9903 ( G3-PLC® ) and ITU G 9904 ( PRIME ) These standards are supported at different levels: Standard PHY Access Support MAC Real Time Access Support MAC Access Support ADP Access Support IPv6 Access Support 4-32 Access Support G3-PLC Yes Yes - - - N/A PRIME Yes N/A - N/A - - ",
							" Driver Libraries PLC stands for Power Line Communications a communication technology that enables sending data over existing AC or DC power cables The Smart Energy PLC Drivers are software components designed to act as interface between the Host MCU where it is running and a PLC transceiver (PL360 or PL460) MCU Host and PLC Transceiver Connected Blocks host_and_transceiver_connected_blocks PL360 and PL460 devices operate in the Narrowband segment (3-500 KHz) running a binary file which implements low layers of Standard Protocols Available binaries are: G3-PLC PHY layer G3-PLC PHY + MAC Real Time layers PRIME PHY layer HW resources used by PLC Driver Each PLC Driver requires some HW resources in order to control the slave PLC Transceiver These resources are: SPI Peripheral DMA Controller (XDMAC) or Peripheral DMA Controller (PDC) 4 GPIOs in case of PL360: An interrupt-capable input GPIO to receive interrupts from PL360 An input GPIO to receive Carrier Detect signal from PL360 An output GPIO to drive the LDO Enable pin of PL360 An output GPIO to drive the NRST pin of PL360 5 GPIOs in case of PL460: An interrupt-capable input GPIO to receive interrupts from PL460 An input GPIO to receive Thermal Monitor signal from PL460 An output GPIO to drive the TX Enable pin of PL460 An output GPIO to drive the LDO Enable pin of PL460 An output GPIO to drive the NRST pin of PL460 PL360 and Host Connection PL360_host_connection PL460 and Host Connection PL460_host_connection ",
							" PLC PHY Driver This driver provides a non-blocking interface with the external on-chip PLC transceiver The library uses the SPI peripheral library (PLIB) and the Direct Memory Access controller to interface with PL360/PL460 PLC devices Key Features: Supports a single instance of the PLC device (PL360 / PL460) and a single client to the driver Supports the internal firmware upload process Supports interrupt handling to read PLC events Supports write/read to/from the internal PLC information Base (PIB) Supports transmitting and receiving PLC frames The library can be used in both Bare-Metal and RTOS environments ",
							" How the Library Works The PLC PHY driver library is a single-client single-instance based driver interface Abstraction Model The PLC PHY library communicates with a PLC transceiver using an SPI port Direct Memory Access and the GPIO controller The PLC transceiver performs PHY duties of the communication protocol thus allowing a high latency attendance from the host MCU The PLC PHY library offers the necessary functions to control the transceiver which include: Library initialization Transmitting and Receiving PLC frames Accessing PLC Information Base to get/set configuration parameters Enabling/Disabling transceiver Sleep Mode Check warnings due to Thermal Monitor control The client can be: Application - Directly access the external PLC device (PL360/PL460) using the APIs provided by the PLC PHY Driver library G3 PAL layer - Application can run a PLC communication stack (G3/PRIME) by connecting it to the Platform Abstraction Layer (PAL) which can further be connected to the PLC PHY driver PLC_PHY_Library_works Working flow The library's state machine is driven from the interrupt context Once a transfer is complete a callback (if registered by the application) is given to the application from the interrupt context The library does not support queuing of more than one requests The application must check and ensure that any previous request is completed before submitting a new one This can be done by registering callback functions PLC Transceiver Interrupt mapping PLC transceiver events have to be notified to MCU in which PLC PHY Driver is running This is done using a physical connection between the transceiver and an interrupt-capable PIO in MCU The library implements DRV_PLC_PHY_ExternalInterruptHandler function which is set as callback to be invoked when the interrupt is triggered on PIO This function then reads information from the transceiver and performs the required operations Driver Initialization and instance opening First of all driver has to be initialized by calling DRV_PLC_PHY_Initialize to get a valid handle Then when an instance is opened by calling DRV_PLC_PHY_Open the library loads a binary file onto the PLC transceiver This is done using an internal transfer protocol through SPI port After binary loading the library manages the reset and startup of the transceiver This task is transparent to the user and the library is not available until binary file is transferred and thus PLC transceiver is ready to operate At this point driver is ready to be configured and used ",
							" Using The Library The PLC PHY library builds on top of an SPI peripheral library (PLIB) to communicate with a PLC transceiver in which G3-PLC lower MAC and PHY layers run However the underlying use of an SPI port is abstracted to the user and library provides a modem-like interface with Data transmission and reception functions and configuration parameters that can be read/written Data Service access is done in asynchronous mode requiring some callbacks to be set in order to let library provide communication events to the user Management Service access is done in synchronous mode and the different Get/Set functions provide the results as part of the returned/referenced parameters Example application to send data through PLC and wait for a response APP_PLC_DATA appPlc; bool txConfirmed; bool frameReceived; uint8_t txBuffer[MAC_RT_MAX_PAYLOAD_SIZE]; uint16_t txLength; static void APP_PLC_SendData ( uint8_t* pData uint16_t length ) { if ((length 0) (length = APP_PLC_BUFFER_SIZE)) { /* Set data length in Tx Parameters structure */ /* It should be equal or less than Maximum Data Length (see _get_max_psdu_len) */ /* Otherwise DRV_PLC_PHY_TX_RESULT_INV_LENGTH will be reported in Tx Confirm */ appPlcTx pl360Tx dataLength = length + 2; memcpy(appPlcTx pDataTx + 2 pData length); DRV_PLC_PHY_Send(appPlc drvPl360Handle appPlcTx pl360Tx); } } static void APP_PLC_DataCfmCb(DRV_PLC_PHY_TRANSMISSION_CFM_OBJ *cfmObj uintptr_t context ) { /* Update flag */ txConfirmed = true; } static void APP_PLC_DataIndCb( DRV_PLC_PHY_RECEPTION_OBJ *indObj uintptr_t context ) { /* Do whatever with received frame */ frameReceived = true; } void APP_PLC_Initialize ( void ) { /* Init PLC data buffers */ appPlcTx pTxFrame = appPlcTxFrameBuffer; appPlcTx pRxFrame = appPlcRxFrameBuffer; /* Set PLC state */ appPlc state = APP_PLC_STATE_IDLE; } void APP_PLC_Tasks ( void ) { /* Check the application's current state */ switch ( appPlc state ) { case APP_PLC_STATE_IDLE: { /* Initialize PLC driver */ appPlc state = APP_PLC_STATE_INIT; } break; case APP_PLC_STATE_INIT: { /* Open PLC driver */ appPlc drvPl360Handle = DRV_PLC_PHY_Open(DRV_PLC_PHY_INDEX_0 NULL); if (appPlc drvPl360Handle = DRV_HANDLE_INVALID) { appPlc state = APP_PLC_STATE_OPEN; } else { appPlc state = APP_PLC_STATE_ERROR; } break; } case APP_PLC_STATE_OPEN: { /* Check PLC transceiver */ if (DRV_PLC_PHY_Status(DRV_PLC_PHY_INDEX_0) == SYS_STATUS_READY) { /* Configure PLC callbacks */ DRV_PLC_PHY_DataCfmCallbackRegister(appPlc drvPl360Handle APP_PLC_DataCfmCb NULL); DRV_PLC_PHY_DataIndCallbackRegister(appPlc drvPl360Handle APP_PLC_DataIndCb NULL); /* Apply PLC initial configuration */ APP_PLC_SetInitialConfiguration(); /* Enable PLC Transmission */ DRV_PLC_PHY_EnableTX(appPlc drvPl360Handle true); /* Set PLC state to transmit a frame */ appPlc state = APP_PLC_STATE_TX_REQUEST; } } break; case APP_PLC_STATE_TX_REQUEST: { /* Build a frame in buffer and set length before calling SendData */ APP_PLC_SendData(txBuffer txLength); appPlc state = APP_PLC_STATE_WAITING_TX_CFM; break; } case APP_PLC_STATE_WAITING: { if (frameReceived) { frameReceived = false; /* Send another frame */ appPlc state = APP_PLC_STATE_TX_REQUEST; } break; } case APP_PLC_STATE_WAITING_TX_CFM: { if (txConfirmed) { frameReceived = false; appPlc state = APP_PLC_STATE_WAITING; } break; } /* The default state should never be executed */ default: { /* Handle error in application's state machine */ break; } } } ",
							" Configuring The Library PLC PHY Driver Specific User Configurations PLC PHY Driver library should be configured via MCC Below is the Snapshot of the MCC configuration window for PLC PHY driver and brief description PLC PHY Driver configuration options PLC_PHY_mcc_configuration Phy Driver Mode Used: Specifies the PLC device physically connected The pins in use will vary depending on the device selected Configuration for PL460 device PL460 configuration options PLC_PHY_mcc_pl460_pins Configuration for PL360 device PL360 configuration options PLC_PHY_mcc_pl360_pins Phy Driver Peripheral Used: Indicates the SPI peripheral instance used by the PLC PHY driver The name of the peripheral will vary from device to device Phy Driver External Interrupt Pin Used: GPIO Pin to be used as external interrupt interface (active low) This pin automatically indicates that the firmware running in the PLC device has one or more pending events to be consulted This pin must be configured as GPIO input in \"Pin Settings\" configuration Set Pull Down configuration PLC PIO Interrupt settings PLC_PHY_mcc_pl460_INT_pin_settings Phy Driver Reset Pin Used: GPIO Pin to be used as reset (active low) This pin must be configured as GPIO output in \"Pin Settings\" configuration This pin resets the core and the peripherals of the PLC device Phy Driver LDO Enable Pin Used: GPIO Pin to be used as LDO enable (active high) This pin must be configured as GPIO output in \"Pin Settings\" configuration This pin provides power to the core voltage regulator embedded in the PLC device Phy Driver TX Enable Pin Used (PL460 mode): GPIO Pin to allow PLC transmissions (active high) This pin must be configured as GPIO output in \"Pin Settings\" configuration Enable Sleep Mode: In Sleep mode the core of the device and the peripherals are reset reducing power consumption Phy Driver Standby Pin Used: GPIO Pin to be used as sleep mode enable (active high) This pin must be configured as GPIO output in \"Pin Settings\" configuration Enable Thermal Monitor (PL460 mode): Enable Thermal Monitor interface Phy Driver Thermal Monitor Pin Used (PL460 mode): GPIO Pin to check the status of the Thermal monitor This pin must be configured as GPIO output in \"Pin Settings\" configuration PLC Profile: This Option can be used to select the PLC standard to comply with such as ITU G 9903 (G3-PLC) or ITU G 9904 (PRIME) PLC Coupling Settings: PLC Driver mode must have been selected before to obtain a valid PLC coupling settings for each mode Used to establish the hardware configuration associated to the PLC frequency bands to use The options of this configuration will vary from the selected PLC profile G3 profile: The configuration will vary depending on the PLC Driver Mode selected PL460: Main Branch: PL460: Hardware blocks in a single band PLC_PHY_mcc_pl460_main_branch The main transmission branch uses the embedded class-D PLC line driver to optimize performance in terms of efficiency and EMC compliance while reducing BOM cost and PCB complexity This is the default branch for single-band applications either in CEN-A CEN-B or FCC bands G3 frequency table PLC_PHY_mcc_G3_frequencies FCC high attenuation branch: This option is visible only for FCC configured as the main branch The PL460 is capable of automatically managing two external filters in the filtering stage each filter associated to an ASOx line Multiband: PL460: Hardware blocks in multiband PLC_PHY_mcc_pl460_aux_branch This option is visible only for FCC as main branch Used to select CEN-A or CEN-B as the auxiliary PLC phy band Auxiliary Branch: The Auxiliary Transmission Branch can provide an additional output bit-stream if required The Auxiliary Transmission path cannot use the embedded PLC driver in the PL460 and requires an external circuit for signal amplification in addition to the standard filtering and coupling stages Set as default branch: Used to establish Auxiliary branch in the intialization of the PHY PLC driver PL360: Main Branch: PL360: Hardware blocks in a single band with external coupling PLC_PHY_mcc_pl360_main_branch This is the default branch for single-band applications either in CEN-A CEN-B or FCC bands FCC high attenuation branch: This option is visible only for FCC configured as the main branch Internal Driver: This option is visible only for PL360 driver mode G3 profile and CEN-B configured as the main branch PL360: Hardware blocks in a single band with internal coupling PLC_PHY_mcc_pl360_main_branch_internal In case of using a coupling with internal driver only one branch is allowed and all the four EMIT pins must be connected to the same point and transmission control is indicated by TXRX0 Multiband: PL360: Hardware blocks in multiband with external coupling PLC_PHY_mcc_pl360_aux_branch This option is visible only for FCC as main branch Used to select CEN-A or CEN-B as the auxiliary PLC phy band Auxiliary Branch: The Auxiliary Transmission Branch can provide an additional output bit-stream if required Set as default branch: Used to establish Auxiliary branch in the intialization of the PHY PLC driver PRIME profile: PRIME Frequency channels PLC_PHY_mcc_PRIME_frequencies PHY PLC driver can handle several communications channels the user can configure which set of channels the PLC device is allowed to operate on Single Channel PLC frames will be transmitted using 1-channel frequency range Channel \"i\" Enable Channel \"i\" to be used for a PLC frame Hardware configuration will vary depending on the selected configuration Channel 1 using the main branch Configuration for single channel using the main branch PLC_PHY_mcc_PRIME_single_chn_1 Channel from 3 to 8 using the main branch Configuration for single channel using channels 8 5 and 3 via the main branch PLC_PHY_mcc_PRIME_single_chn_358 Multiband using the auxiliary branch Configuration for multiband using channels 8 5 and 3 via the main branch and channel 1 via the auxiliary branch PLC_PHY_mcc_PRIME_single_multiband Double Channel PLC frames will be transmitted using 2-channel frequency range Channel \"i - j\" Enable Channels \"i\" and \"j\" to be used for a PLC frame This mode is only available for using the main branch Configuration for double channel using channels 5-6 and channels 7-8 PLC_PHY_mcc_PRIME_double_chn_56_78 Default Channel Used to establish the channel by default in which the PLC Driver is configured to transmit and receive High attenuation branch This option is visible only for PL460 and it takes effect in the main branch The PL460 is capable of automatically managing two external filters in the filtering stage each filter associated to an ASOx line NVIC Configurations The PLC Phy driver has a strong dependency on a delay function defined in the HAL module This delay function is called from the PIO Handler associated with the External Interrupt pin Applications designed in MCHP used as PLC examples use the Timer module as the delay interface so the priority of the Timer interrupt must be higher that the rest of interrupts in order to ensure the correct operation ",
							" Library Interface PLC PHY driver library provides the following interfaces: Functions Name Description DRV_PLC_PHY_Initialize Initializes the PLC PHY instance for the specified driver index DRV_PLC_PHY_Open Opens the specified PLC PHY driver instance and returns a handle to it DRV_PLC_PHY_Close Closes an opened instance of the PLC PHY driver given its handle DRV_PLC_PHY_TxRequest Allows a client to transmit PLC PHY data through Power Line DRV_PLC_PHY_PIBGet Allows a client to get information from PLC transceiver about PLC PHY and PHY information base (PIB) DRV_PLC_PHY_PIBSet Allows a client to set information to PLC transceiver on PLC PHY and PHY information base (PIB) DRV_PLC_PHY_TxCfmCallbackRegister Allows a client to set a data confirm event handling function for the driver to call back when the requested transmission has finished DRV_PLC_PHY_DataIndCallbackRegister Allows a client to set a data indication event handling function for the driver to call back when a data reception has finished DRV_PLC_PHY_SleepDisableCallbackRegister Allows a client to set an sleep mode disable event handling function for the driver to call back when the PLC driver is active again DRV_PLC_PHY_ExceptionCallbackRegister Allows a client to set an exception event handling function for the driver to call back when some error occurs through PLC transceiver communication DRV_PLC_PHY_ExternalInterruptHandler Allows application to register callback for PLC Interrupt pin DRV_PLC_PHY_Status Gets the current status of the PLC driver module DRV_PLC_PHY_Tasks Maintains the driver's state machine DRV_PLC_PHY_Sleep PLC driver Sleep mode management DRV_PLC_PHY_EnableTX Enables/Disables PLC transmission Data types and constants Name Type Description DRV_PLC_PHY_TX_CFM_CALLBACK Typedef Pointer to a PLC PHY Driver Transmission Confirm Event handler function DRV_PLC_PHY_DATA_IND_CALLBACK Typedef Pointer to a PLC PHY Driver Reception Event handler function DRV_PLC_PHY_SLEEP_CALLBACK Typedef Notifies when Sleep Mode is disabled and PLC PHY driver is available to be used again DRV_PLC_PHY_EXCEPTION_CALLBACK Typedef Pointer to a PLC PHY Driver Exceptions Event handler function DRV_PLC_PHY_EXCEPTION Enum Defines the type for PLC PHY Driver transfer errors G3 Data types and constants Name Type Description DRV_PLC_PHY_ID Enum List of available G3 PLC PHY Information Base objects DRV_PLC_PHY_MOD_TYPE Enum List of G3 modulations DRV_PLC_PHY_MOD_SCHEME Enum List of G3 modulations schemes DRV_PLC_PHY_DEL_TYPE Enum List of G3 delimiter types DRV_PLC_PHY_TX_RESULT Enum List of transmission results DRV_PLC_PHY_TONE_MAP_RSP Struct Includes modulation type modulation scheme and Tone Map data DRV_PLC_PHY_MAX_PSDU_LEN_PARAMS Struct Includes the parameters used to get the maximum PSDU length computation DRV_PLC_PHY_TRANSMISSION_OBJ Struct Includes PLC Transmission setup data DRV_PLC_PHY_TRANSMISSION_CFM_OBJ Struct Includes a transmission result and timestamp DRV_PLC_PHY_RECEPTION_OBJ Struct Includes PLC PHY Reception data and PHY parameters DRV_PLC_PHY_PIB_OBJ Struct Object to access the PLC PHY Information Base PRIME Data types and constants Name Type Description DRV_PLC_PHY_ID Enum List of available PRIME PLC PHY Information Base objects DRV_PLC_PHY_SCH Enum List of PRIME modulations schemes DRV_PLC_PHY_FRAME_TYPE Enum List of PRIME frame types DRV_PLC_PHY_HEADER Enum List of PRIME header types DRV_PLC_PHY_CHANNEL Enum List of PRIME channels DRV_PLC_PHY_BUFFER_ID Enum List of buffers ID to handle PLC communications DRV_PLC_PHY_TX_RESULT Enum List of transmission results DRV_PLC_PHY_SIGNAL_CAPTURE_STATE Enum Includes the Noise Capture States DRV_PLC_PHY_SIGNAL_CAPTURE_INFO Struct Includes information about Noise Capture DRV_PLC_PHY_TRANSMISSION_OBJ Struct Includes PLC Transmission setup data DRV_PLC_PHY_TRANSMISSION_CFM_OBJ Struct Includes a transmission result and timestamp DRV_PLC_PHY_RECEPTION_OBJ Struct Includes PLC PHY Reception data and PHY parameters DRV_PLC_PHY_PIB_OBJ Struct Object to access the PLC PHY Information Base ",
							" DRV_PLC_PHY_Initialize Function ",
							" C SYS_MODULE_OBJ DRV_PLC_PHY_Initialize ( const SYS_MODULE_INDEX index const SYS_MODULE_INIT * const init ); ",
							" Summary Initializes the PLC PHY instance for the specified driver index ",
							" Description This routine initializes the G3 PLC PHY driver making it ready for clients to open and use The initialization data is specified by the init parameter It is a single instance driver so this API should be called only once ",
							" Parameters Param Description index Index for the instance to be initialized As driver is single instance index '0' must always be used init Pointer to the init data structure containing any data necessary to initialize the driver ",
							" Returns If successful returns a valid handle to a driver instance object Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example SYS_MODULE_OBJ sysObjDrvPlcPhy; DRV_PLC_PLIB_INTERFACE drvPLCPlib = { spiPlibTransferSetup = (DRV_PLC_SPI_PLIB_TRANSFER_SETUP)SPI0_TransferSetup dmaChannelTx = SYS_DMA_CHANNEL_1 dmaChannelRx = SYS_DMA_CHANNEL_0 spiAddressTx = (void *) (SPI0_REGS- SPI_TDR) spiAddressRx = (void *) (SPI0_REGS- SPI_RDR) spiMR = (void *) (SPI0_REGS- SPI_MR) spiCSR = (void *) (SPI0_REGS- SPI_CSR) spiClockFrequency = DRV_PLC_SPI_CLK ldoPin = DRV_PLC_LDO_EN_PIN resetPin = DRV_PLC_RESET_PIN extIntPin = DRV_PLC_EXT_INT_PIN txEnablePin = DRV_PLC_TX_ENABLE_PIN stByPin = DRV_PLC_STBY_PIN thMonPin = DRV_PLC_THMON_PIN }; DRV_PLC_HAL_INTERFACE drvPLCHalAPI = { plcPlib = drvPLCPlib init = (DRV_PLC_HAL_INIT)DRV_PLC_HAL_Init setup = (DRV_PLC_HAL_SETUP)DRV_PLC_HAL_Setup reset = (DRV_PLC_HAL_RESET)DRV_PLC_HAL_Reset setStandBy = (DRV_PLC_HAL_SET_STBY)DRV_PLC_HAL_SetStandBy getThermalMonitor = (DRV_PLC_HAL_GET_THMON)DRV_PLC_HAL_GetThermalMonitor setTxEnable = (DRV_PLC_HAL_SET_TXENABLE)DRV_PLC_HAL_SetTxEnable enableExtInt = (DRV_PLC_HAL_ENABLE_EXT_INT)DRV_PLC_HAL_EnableInterrupts delay = (DRV_PLC_HAL_DELAY)DRV_PLC_HAL_Delay sendBootCmd = (DRV_PLC_HAL_SEND_BOOT_CMD)DRV_PLC_HAL_SendBootCmd sendWrRdCmd = (DRV_PLC_HAL_SEND_WRRD_CMD)DRV_PLC_HAL_SendWrRdCmd }; extern uint8_t plc_phy_bin_start; extern uint8_t plc_phy_bin_end; DRV_PLC_PHY_INIT drvPlcPhyInitData = { plcHal = drvPLCHalAPI numClients = DRV_PLC_PHY_CLIENTS_NUMBER_IDX plcProfile = DRV_PLC_PHY_PROFILE binStartAddress = (uint32_t) plc_phy_bin_start binEndAddress = (uint32_t) plc_phy_bin_end secure = DRV_PLC_SECURE }; sysObjDrvPlcPhy = DRV_PLC_PHY_Initialize(DRV_PLC_PHY_INDEX (SYS_MODULE_INIT *) drvPlcPhyInitData); // Register Callback function is mandatory to handle PLC interruption PIO_PinInterruptCallbackRegister((PIO_PIN)DRV_PLC_EXT_INT_PIN DRV_PLC_PHY_ExternalInterruptHandler sysObj drvPlcPhy); ",
							" Remarks This routine must be called before any other DRV_PLC_PHY routine is called This routine should only be called once during system initialization This routine will block for hardware access ",
							" DRV_PLC_PHY_Open Function ",
							" C SYS_MODULE_OBJ DRV_PLC_PHY_Open ( const SYS_MODULE_INDEX index const DRV_PLC_BOOT_DATA_CALLBACK callback ); ",
							" Summary Opens the specified PLC PHY driver instance and returns a handle to it ",
							" Description This routine opens the specified PLC PHY driver instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the driver This driver is a single client driver so DRV_PLC_PHY_Open API should be called only once until driver is closed ",
							" Precondition Function DRV_PLC_PHY_Initialize must have been called before calling this function ",
							" Parameters Param Description index Index for the instance to be opened As driver is single instance index '0' must always be used callback Boot Data Callback Function Pointer In case of use NULL binStartAddress and binEndAddress fields must be configured in initialization data DRV_PLC_PHY_INIT  ",
							" Returns If successful the routine returns a valid open-instance handle (a number identifying both the caller and the module instance) As driver is single instance handle '0' is always returned If an error occurs the return value is DRV_HANDLE_INVALID Error can occur: if the driver has been already opened once and in use if the driver peripheral instance being opened is not initialized or is invalid ",
							" Example DRV_HANDLE handle; handle = DRV_PLC_PHY_Open(DRV_PLC_PHY_INDEX_0 NULL); if (handle == DRV_HANDLE_INVALID) { // Unable to open the driver // May be the driver is not initialized } ",
							" Remarks The handle returned is valid until the DRV_PLC_PHY_Close routine is called This routine will NEVER block waiting for hardware ",
							" DRV_PLC_PHY_Close Function ",
							" C void DRV_PLC_PHY_Close ( const DRV_HANDLE handle ); ",
							" Summary Closes an opened instance of the PLC PHY driver ",
							" Description This routine closes an opened instance of the PLC PHY driver invalidating the handle A new handle must be obtained by calling DRV_PLC_PHY_Open before the caller uses the driver again ",
							" Precondition DRV_PLC_PHY_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_PLC_PHY_Open routine ",
							" Returns None ",
							" Example // 'handle' returned from DRV_PLC_PHY_Open previously called DRV_PLC_PHY_Close(handle); ",
							" Remarks None ",
							" DRV_PLC_PHY_TxRequest Function ",
							" C void DRV_PLC_PHY_TxRequest ( const DRV_HANDLE handle DRV_PLC_PHY_TRANSMISSION_OBJ *transmitObj ); ",
							" Summary Allows a client to transmit PLC PHY data through Power Line (PLC) ",
							" Description This routine sends a new data message through PLC using the PLC PHY driver ",
							" Precondition DRV_PLC_PHY_Open must have been called to obtain a valid opened device handle DRV_PLC_PHY_TRANSMISSION_OBJ must be configured before to send any data message ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_PLC_PHY_Open routine transmitObj Pointer to the object to transmit ",
							" Returns None ",
							" Example // 'handle' returned from DRV_PLC_PHY_Open previously called // Local function implemented in the user application _setupTransmissionParameters(); memcpy(transmitObj data src_buf data_len); transmitObj length = data_len; DRV_PLC_PHY_TxRequest(handle transmitObj); ",
							" DRV_PLC_PHY_PIBGet Function ",
							" C void DRV_PLC_PHY_PIBGet ( const DRV_HANDLE handle DRV_PLC_PHY_PIB_OBJ *pibObj ); ",
							" Summary Allows a client to get information from PLC transceiver about PHY information base (PIB) ",
							" Description This routine gets PHY data information from the PLC transceiver ",
							" Precondition DRV_PLC_PHY_Open must have been called to obtain a valid opened device handle DRV_PLC_PHY_PIB_OBJ must be configured before getting information ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_PLC_PHY_Open routine pibObj Pointer to the PIB object to get ",
							" Returns None ",
							" Example // 'handle' returned from DRV_PLC_PHY_Open previously called DRV_PLC_PHY_PIB_OBJ pibObj; uint32_t phyVersion; pibObj pData = phyVersion; pibObj length = 4; pibObj id = PLC_ID_VERSION_NUM; pibObj sync = true; DRV_PLC_PHY_PIBGet(handle pibObj); ",
							" Remarks None ",
							" DRV_PLC_PHY_PIBSet Function ",
							" C void DRV_PLC_PHY_PIBSet ( const DRV_HANDLE handle DRV_PLC_PHY_PIB_OBJ *pibObj ); ",
							" Summary Allows a client to set information to PLC transceiver on PHY information base (PIB) ",
							" Description This routine sets PHY data information to the PLC transceiver ",
							" Precondition DRV_PLC_PHY_Open must have been called to obtain a valid opened device handle DRV_PLC_PHY_PIB_OBJ must be configured before setting information ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_PLC_PHY_Open routine pibObj Pointer to the PIB object to set ",
							" Returns None ",
							" Example // 'handle' returned from DRV_PLC_PHY_Open previously called DRV_PLC_PHY_PIB_OBJ pibObj; uint8_t autoMode uint8_t impedance; // Disable AUTODETECT impedance mode autoMode = 0; // Set VLO impedance mode impedance = VLO_STATE; pibObj pData = autoMode; pibObj length = 1; pibObj id = PLC_ID_CFG_AUTODETECT_IMPEDANCE; DRV_PLC_PHY_PIBSet(handle pibObj); pibObj pData = impedance; pibObj length = 1; pibObj id = PLC_ID_CFG_IMPEDANCE; DRV_PLC_PHY_PIBSet(handle pibObj); ",
							" Remarks None ",
							" DRV_PLC_PHY_TxCfmCallbackRegister Function ",
							" C void DRV_PLC_PHY_TxCfmCallbackRegister ( const DRV_HANDLE handle const DRV_PLC_PHY_TX_CFM_CALLBACK callback const uintptr_t context ); ",
							" Summary Allows a client to set a data confirm event handling function for the driver to call back when the requested transmission has finished ",
							" Description This function allows a client to register a PLC data confirm event handling function with the driver to call back when a data confirmation PLC event occurs The event handler should be set before the client submits any transmission requests that could generate events The callback once set persists until the client closes the driver or sets another callback (which could be a NULL pointer to indicate no callback) ",
							" Precondition DRV_PLC_PHY_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_PLC_PHY_Open routine callback Pointer to the callback function context The value of parameter will be passed back to the client unchanged when the callback function is called ",
							" Returns None ",
							" Example // Event is received when the transmission is finished void APP_PLC_Data_Cfm_callback(DRV_PLC_PHY_DATA_CFM_OBJ *cfmObj uintptr_t context) { // The context handle was set to an application specific // object It is now retrievable easily in the event handler MY_APP_OBJ myAppObj = (MY_APP_OBJ *) context; if (cfmObj- result == DRV_PLC_PHY_TX_RESULT_PROCESS) { // This means the data was transferred successfully } else { // Error handling here } } // myAppObj is an application specific state data object MY_APP_OBJ myAppObj; DRV_PLC_PHY_TRANSMISSION_OBJ myTransmissionObj; // myHandle is the handle returned from DRV_PLC_PHY_Open API // Client registers a data confirm callback with driver This is done once DRV_PLC_PHY_TxCfmCallbackRegister( myHandle APP_PLC_Data_Cfm_callback (uintptr_t) myAppObj ); DRV_PLC_PHY_TxRequest(myHandle myTransmissionObj) == false); ",
							" Remarks None ",
							" DRV_PLC_PHY_DataIndCallbackRegister Function ",
							" C void DRV_PLC_PHY_DataIndCallbackRegister ( const DRV_HANDLE handle const DRV_PLC_PHY_DATA_IND_CALLBACK callback const uintptr_t context ); ",
							" Summary Allows a client to set a data indication event handling function for the driver to call back when a packet reception has finished ",
							" Description This function allows a client to register a MAC RT data indication event handling function with the driver to call back when a PLC data reception event occurs Before this callback is set any received frame by the PLC transceiver will not be notified The callback once set persists until the client closes the driver or sets another callback (which could be a NULL pointer to indicate no callback) ",
							" Precondition DRV_PLC_PHY_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_PLC_PHY_Open routine callback Pointer to the callback function context The value of parameter will be passed back to the client unchanged when the callback function is called ",
							" Returns None ",
							" Example // Event is received when a frame is received void APP_PLC_Data_Ind_callback(DRV_PLC_PHY_DATA_IND_OBJ *indObj uintptr_t context) { // The context handle was set to an application specific // object It is now retrievable easily in the event handler MY_APP_OBJ myAppObj = (MY_APP_OBJ *) context; // Reception handling here } // myAppObj is an application specific state data object MY_APP_OBJ myAppObj; // myHandle is the handle returned from DRV_PLC_PHY_Open API // Client registers a data confirm callback with driver This is done once DRV_PLC_PHY_DataIndCallbackRegister( myHandle APP_PLC_Data_Ind_callback (uintptr_t) myAppObj ); // Event is received when PLC data is receiving ",
							" Remarks None ",
							" DRV_PLC_PHY_ExceptionCallbackRegister Function ",
							" C void DRV_PLC_PHY_ExceptionCallbackRegister ( const DRV_HANDLE handle const DRV_PLC_PHY_EXCEPTION_CALLBACK callback const uintptr_t context ); ",
							" Summary Allows a client to set an exception event handling function for the driver to call back when some error occurs through PLC transceiver communication ",
							" Description This function allows a client to register a PLC exception event handling function with the driver to call back when a communication SPI error occurs The event handler should be set before using the PLC transceiver in order to capture error events The callback once set persists until the client closes the driver or sets another callback (which could be a NULL pointer to indicate no callback) ",
							" Precondition DRV_PLC_PHY_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_PLC_PHY_Open routine callback Pointer to the callback function context The value of parameter will be passed back to the client unchanged when the callback function is called ",
							" Returns None ",
							" Example void APP_PLC_Exception_callback(DRV_PLC_PHY_EXCEPTION_OBJ *exceptionObj uintptr_t context) { // The context handle was set to an application specific // object It is now retrievable easily in the event handler MY_APP_OBJ myAppObj = (MY_APP_OBJ *) context; // Exception handling here } // myAppObj is an application specific state data object MY_APP_OBJ myAppObj; // myHandle is the handle returned from DRV_PLC_PHY_Open API // Client registers a data confirm callback with driver This is done once DRV_PLC_PHY_ExceptionCallbackRegister( myHandle APP_PLC_Exception_callback (uintptr_t) myAppObj ); ",
							" Remarks None ",
							" DRV_PLC_PHY_SleepDisableCallbackRegister Function ",
							" C void DRV_PLC_PHY_SleepDisableCallbackRegister ( const DRV_HANDLE handle const DRV_PLC_PHY_SLEEP_IND_CALLBACK callback const uintptr_t context ); ",
							" Summary Allows a client to set an sleep mode disable event handling function for the driver to call back when the PLC driver is active again ",
							" Description This function allows a client to register a PLC sleep mode disable event handling function with the driver to call back when sleep mode is disabled and PLC driver has been restarted The callback once set persists until the client closes the driver or sets another callback (which could be a NULL pointer to indicate no callback) ",
							" Precondition DRV_PLC_PHY_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_PLC_PHY_Open routine callback Pointer to the callback function context The value of parameter will be passed back to the client unchanged when the callback function is called ",
							" Returns None ",
							" Example void APP_PLC_SleepModeDisableCb( uintptr_t context ) { // The context handle was set to an application specific // object It is now retrievable easily in the event handler MY_APP_OBJ myAppObj = (MY_APP_OBJ *) context; // Sleep Disable handling here } // myAppObj is an application specific state data object MY_APP_OBJ myAppObj; // myHandle is the handle returned from DRV_PLC_PHY_Open API // Client registers a data confirm callback with driver This is done once DRV_PLC_PHY_SleepDisableCallbackRegister( myHandle APP_PLC_SleepModeDisableCb (uintptr_t) myAppObj ); ",
							" Remarks None ",
							" DRV_PLC_PHY_ExternalInterruptHandler Function ",
							" C void DRV_PLC_PHY_ExternalInterruptHandler ( const PIO_PIN pin const uintptr_t context ); ",
							" Summary Allows application to register callback for PLC Interrupt pin ",
							" Description This function allows a client to register a callback function to handle PLC interrupt ",
							" Precondition DRV_PLC_PHY_Initialize must have been called to obtain a valid system object ",
							" Parameters Param Description pin PIO pin where interrupt source is connected context Pointer to parameters to be passed to Handler function ",
							" Returns None ",
							" Example // Initialize PLC Driver Instance sysObj drvPLC = DRV_PLC_PHY_Initialize(DRV_PLC_PHY_INDEX (SYS_MODULE_INIT *) drvPlcPhyInitData); // Register Callback function to handle PLC interruption PIO_PinInterruptCallbackRegister(DRV_PLC_EXT_INT_PIN DRV_PLC_PHY_ExternalInterruptHandler sysObj drvPLC); ",
							" Remarks See plib_pio h for more details ",
							" DRV_PLC_PHY_Status Function ",
							" C SYS_STATUS DRV_PLC_PHY_Status ( const SYS_MODULE_INDEX index ); ",
							" Summary Gets the current status of the PLC driver module ",
							" Description This routine provides the current status of the PLC driver module ",
							" Precondition DRV_PLC_PHY_Initialize should have been called before calling this function ",
							" Parameters Param Description index Identifier for the instance used to initialize driver ",
							" Returns Status Description SYS_STATUS_READY Driver is ready to accept requests for new operations SYS_STATUS_UNINITIALIZED Driver is not initialized SYS_STATUS_ERROR Driver is not initialized correctly SYS_STATUS_BUSY Driver is initializing ",
							" Example SYS_STATUS status; // 'DRV_PLC_PHY_INDEX' is the one used before for Driver Initialization status = DRV_PLC_PHY_Status(DRV_PLC_PHY_INDEX); ",
							" Remarks None ",
							" DRV_PLC_PHY_Tasks Function ",
							" C void DRV_PLC_PHY_Tasks ( SYS_MODULE_OBJ object ); ",
							" Summary Maintains the driver's state machine ",
							" Description This function is used to maintain the driver's internal state machine ",
							" Precondition DRV_PLC_PHY_Initialize must have been called before calling this function ",
							" Parameters Param Description object Object handle for the specified driver instance (returned from DRV_PLC_PHY_Initialize ) ",
							" Returns None ",
							" Example SYS_MODULE_OBJ object; // Returned from DRV_PLC_PHY_Initialize while (true) { DRV_PLC_PHY_Tasks (object); // Do other tasks } ",
							" Remarks This function is normally not called directly by an application It is called by the system's Tasks routine (SYS_Tasks) This function will never block or access any resources that may cause it to block ",
							" DRV_PLC_PHY_Sleep Function ",
							" C void DRV_PLC_PHY_Sleep ( const DRV_HANDLE handle bool enable ); ",
							" Summary PLC Sleep mode management ",
							" Description This function disables PLC interrupts before going to sleep and will leave them disabled upon return If there is any PLC transmission in progress this transmission will be discarded ",
							" Precondition DRV_PLC_PHY_Initialize must have been called before calling this function ",
							" Parameters Param Description handle Object handle for the specified driver instance (returned from DRV_PLC_PHY_Initialize ) enable Set True to enter in sleep mode Set False to exit from sleep mode ",
							" Returns None ",
							" Example SYS_MODULE_OBJ object; // Returned from DRV_PLC_PHY_Initialize while (true) { if (sleep_condition) { DRV_PLC_PHY_Sleep (object true); } } ",
							" Remarks This function will never block or access any resources that may cause it to block ",
							" DRV_PLC_PHY_EnableTX Function ",
							" C void DRV_PLC_PHY_EnableTX ( const DRV_HANDLE handle bool enable ); ",
							" Summary Enables/Disables PLC transmission ",
							" Description This function allows a client to enable or disable the PLC transmission If there is any transmission on going it will be cancelled and notified through the TX confirm callback ",
							" Precondition DRV_PLC_PHY_Initialize must have been called before calling this function ",
							" Parameters Param Description handle Object handle for the specified driver instance (returned from DRV_PLC_PHY_Initialize ) enable Set True to enable PLC transmission Set False to disable it ",
							" Returns None ",
							" Example SYS_MODULE_OBJ object; // Returned from DRV_PLC_PHY_Initialize while (true) { // if (cancel_tx) { DRV_PLC_PHY_EnableTX (object false); } else { DRV_PLC_PHY_EnableTX (object true); } // } ",
							" Remarks None ",
							" DRV_PLC_PHY_INIT Struct ",
							" C typedef struct { /* Identifies the HAL API set to be used by the driver to access * peripherals */ DRV_PLC_HAL_INTERFACE *plcHal; /* Number of clients */ size_t numClients; /* PLC Profile */ uint8_t plcProfile; /* Start Address where PLC binary file is located */ uint32_t binStartAddress; /* End Address where PLC binary file is located */ uint32_t binEndAddress; /* Secure mode */ bool secure; } DRV_PLC_PHY_INIT; ",
							" Summary Contains the data required to initialize the PLC driver ",
							" Description This structure contains the objects needed to initialize the PLC driver It is passed as parameter (casted as SYS_MODULE_INIT ) to DRV_PLC_PHY_Initialize function Field description: plcHal Pointer to DRV_PLC_HAL_INTERFACE Struct which defines the way driver accesses to PLC transceiver plcProfile Not used reserved for future use binStartAddress Memory address where the first byte of transceiver's binary file is located binEndAddress Memory address where the last byte of transceiver's binary file is located secure Flag to indicate whether binary file is encrypted not supported on current version ",
							" Remarks None ",
							" DRV_PLC_HAL_INTERFACE Struct ",
							" C typedef struct { /* PLC PLIB Interface */ DRV_PLC_PLIB_INTERFACE *plcPlib; /* PLC HAL init */ DRV_PLC_HAL_INIT init; /* PLC HAL setup */ DRV_PLC_HAL_SETUP setup; /* PLC HAL reset device */ DRV_PLC_HAL_RESET reset; /* PLC low power management */ DRV_PLC_HAL_SET_STBY setStandBy; /* Only visible if SLEEP MODE is enabled on Driver Configuration */ /* PLC Temperature Monitor */ DRV_PLC_HAL_GET_THMON getThermalMonitor; /* Only visible if PL460 Driver is used and THERMAL MONITOR is enabled on Driver Configuration */ /* PLC HAL Set Tx Enable pin */ DRV_PLC_HAL_SET_TXENABLE setTxEnable; /* Only visible if PL460 Driver is used */ /* PLC HAL Enable/Disable external interrupt */ DRV_PLC_HAL_ENABLE_EXT_INT enableExtInt; /* PLC HAL delay function */ DRV_PLC_HAL_DELAY delay; /* PLC HAL Transfer Bootloader Command */ DRV_PLC_HAL_SEND_BOOT_CMD sendBootCmd; /* PLC HAL Transfer Write/Read Command */ DRV_PLC_HAL_SEND_WRRD_CMD sendWrRdCmd; } DRV_PLC_HAL_INTERFACE; ",
							" Summary Contains the data required to initialize the PLC driver HAL Interface ",
							" Description This structure contains the objects needed to initialize the driver access to PLC transceiver Field description: plcPlib Pointer to DRV_PLC_PLIB_INTERFACE Struct which defines the SPI and Control Lines to access PLC transceiver init Pointer to Hardware Initialization function setup Pointer to transceiver Setup function reset Pointer to transceiver Reset function setStandBy Pointer to transceiver Standby (Sleep) management function Only available if SLEEP MODE is enabled on Driver Configuration getThermalMonitor Pointer to transceiver Thermal Monitor status function Only available if PL460 Driver is used and THERMAL MONITOR is enabled on Driver Configuration setTxEnable Pointer to transceiver Tx Enable control function Only available if PL460 Driver is used enableExtInt Pointer to external interrupt (triggered by transceiver) management function delay Pointer to driver's implementation of Delay function sendBootCmd Pointer to driver's function to send a Boot Command to transceiver sendWrRdCmd Pointer to driver's function to send a Read/write Command to transceiver ",
							" Remarks None ",
							" DRV_PLC_PLIB_INTERFACE Struct ",
							" C typedef struct { /* PLC SPI PLIB Transfer Setup */ DRV_PLC_SPI_PLIB_TRANSFER_SETUP spiPlibTransferSetup; /* SPI transmit DMA channel */ SYS_DMA_CHANNEL dmaChannelTx; /* Only visible if used SPI supports DMA */ /* SPI receive DMA channel */ SYS_DMA_CHANNEL dmaChannelRx; /* Only visible if used SPI supports DMA */ /* SPI transmit register address used for DMA operation */ void *spiAddressTx; /* Only visible if used SPI supports DMA */ /* SPI receive register address used for DMA operation */ void *spiAddressRx; /* Only visible if used SPI supports DMA */ /* SPI MR register address */ uint32_t *spiMR; /* Only visible if used SPI supports DMA */ /* SPI MR register address */ uint32_t *spiCSR; /* Only visible if used SPI supports DMA */ /* SPI Write/Read */ DRV_PLC_SPI_WRITE_READ spiWriteRead; /* Only visible if used SPI uses PDC instead of DMA */ /* SPI Is Busy */ DRV_PLC_SPI_ISBUSY spiIsBusy; /* Only visible if used SPI uses PDC instead of DMA */ /* SPI clock frequency */ uint32_t spiClockFrequency; /* PLC LDO enable pin */ SYS_PORT_PIN ldoPin; /* PLC reset pin */ SYS_PORT_PIN resetPin; /* PLC external interrupt pin */ SYS_PORT_PIN extIntPin; /* PLC Tx Enable pin */ SYS_PORT_PIN txEnablePin; /* Only visible if PL460 Driver is used */ /* PLC StandBy Pin */ SYS_PORT_PIN stByPin; /* Only visible if SLEEP MODE is enabled on Driver Configuration */ /* PLC Thermal Monitor pin */ SYS_PORT_PIN thMonPin; /* Only visible if PL460 Driver is used and THERMAL MONITOR is enabled on Driver Configuration */ } DRV_PLC_PLIB_INTERFACE; ",
							" Summary Contains the data required to initialize the PLC driver PLIB Interface ",
							" Description This structure contains the objects needed to initialize the driver access SPI and Control Lines to manage PLC transceiver Field description: spiPlibTransferSetup Pointer to SPI Transfer Setup function dmaChannelTx DMA Tx channel selection Only available if used SPI supports DMA dmaChannelRx DMA Rx channel selection Only available if used SPI supports DMA spiAddressTx Address of SPI Tx buffer register Only available if used SPI supports DMA spiAddressRx Address of SPI Rx buffer register Only available if used SPI supports DMA spiMR Address of SPI Mode Register Only available if used SPI supports DMA spiCSR Address of SPI Chip Select Register Only available if used SPI supports DMA spiWriteRead SPI Write/read configuration flag Only available if used SPI uses PDC instead of DMA spiIsBusy SPI Busy information flag Only available if used SPI uses PDC instead of DMA spiClockFrequency SPI Clock frequency to use with PLC transceiver ldoPin Port connected to LDO pin of PLC transceiver resetPin Port connected to Reset pin of PLC transceiver extIntPin Port connected to External Interrupt pin of PLC transceiver txEnablePin Port connected to Tx Enable pin of PLC transceiver Only available if PL460 Driver is used stByPin Port connected to Standby (Sleep) pin of PLC transceiver Only available if SLEEP MODE is enabled on Driver Configuration thMonPin Port connected to Thermal Monitor pin of PLC transceiver Only available if PL460 Driver is used and THERMAL MONITOR is enabled on Driver Configuration ",
							" Remarks None ",
							" DRV_PLC_PHY_TX_CFM_CALLBACK Typedef ",
							" C typedef void ( *DRV_PLC_PHY_TX_CFM_CALLBACK )( DRV_PLC_PHY_TRANSMISSION_CFM_OBJ *cfmObj uintptr_t context ); ",
							" Summary Pointer to a PLC Driver Transmission Confirm Event handler function ",
							" Description A client must register a pointer using the callback register function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver ",
							" Parameters Param Description cfmObj Pointer to the object containing any data necessary to identify the result of the last transmission context Value identifying the context of the application that registered the event handling function ",
							" Returns None ",
							" Example void APP_MyTXCfmEventHandler( DRV_PLC_PHY_TRANSMISSION_CFM_OBJ *cfmObj uintptr_t context ) { MY_APP_DATA_STRUCT pAppData = (MY_APP_DATA_STRUCT) context; switch(cfmObj- result) { case DRV_PLC_PHY_TX_RESULT_PROCESS: // Transmission result: already in process break; case DRV_PLC_PHY_TX_RESULT_SUCCESS: // Transmission result: end successfully break; case DRV_PLC_PHY_TX_RESULT_INV_LENGTH: // Transmission result: invalid length error break; case DRV_PLC_PHY_TX_RESULT_BUSY_CH: // Transmission result: busy channel error break; case DRV_PLC_PHY_TX_RESULT_BUSY_TX: // Transmission result: busy in transmission error break; case DRV_PLC_PHY_TX_RESULT_BUSY_RX: // Transmission result: busy in reception error break; case DRV_PLC_PHY_TX_RESULT_INV_SCHEME: // Transmission result: invalid modulation scheme error break; case DRV_PLC_PHY_TX_RESULT_TIMEOUT: // Transmission result: timeout error break; case DRV_PLC_PHY_TX_RESULT_INV_TONEMAP: // Transmission result: invalid tone map error break; case DRV_PLC_PHY_TX_RESULT_INV_MODE: // Transmission result: invalid G3 Mode error break; case DRV_PLC_PHY_TX_RESULT_NO_TX: // Transmission result: No transmission ongoing break; } } ",
							" Remarks If the status field is DRV_PLC_PHY_TX_RESULT_SUCCESS data was transmitted successfully Otherwise it contains the transmission failure code ",
							" DRV_PLC_PHY_DATA_IND_CALLBACK Typedef ",
							" C typedef void ( *DRV_PLC_PHY_DATA_IND_CALLBACK )( DRV_PLC_PHY_RECEPTION_OBJ *indObj uintptr_t context ); ",
							" Summary Pointer to a PLC Driver Reception Event handler function ",
							" Description This data type defines the required function signature for the PLC PHY driver reception event handling callback function A client must register a pointer using the callback register function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver ",
							" Parameters Param Description indObj Pointer to the object containing any data necessary to describe the new received message context Value identifying the context of the application that registered the event handling function ",
							" Returns None ",
							" Example void APP_MyRxEventHandler( DRV_PLC_PHY_RECEPTION_OBJ *indObj uintptr_t context ) { MY_APP_DATA_STRUCT pAppData = (MY_APP_DATA_STRUCT) context; // Check length of the new message if (indObj- dataLength) { // extract data from received message memcpy(appData pDataRx indObj- pReceivedData indObj- dataLength); } } ",
							" Remarks Check DRV_PLC_PHY_RECEPTION_OBJ struct to identify other intereseting parameters about reception such as LQI Tonemap Modulation scheme etc ",
							" DRV_PLC_PHY_SLEEP_IND_CALLBACK Typedef ",
							" C typedef void ( *DRV_PLC_PHY_SLEEP_IND_CALLBACK )( void ); ",
							" Summary Pointer to notification when Sleep Mode is disabled and PLC PHY driver is available to be used again ",
							" Description This data type defines the required function signature for the PLC PHY driver sleep mode disable event handling callback function A client must register a pointer using the callback register function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver ",
							" Parameters None ",
							" Returns None ",
							" Example void APP_MySleepDisableEventHandler( void ) { // Do initial configuration of the application if needed appData plc_sleep = false; } ",
							" Remarks None ",
							" DRV_PLC_PHY_EXCEPTION_CALLBACK Typedef ",
							" C typedef void ( *DRV_PLC_PHY_EXCEPTION_CALLBACK )( DRV_PLC_PHY_EXCEPTION exception ); ",
							" Summary Pointer to a G3 MAC RT Driver Exceptions Event handler function ",
							" Description This data type defines the required function signature for the MAC RT driver exceptions event handling callback function A client must register a pointer using the callback register function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver ",
							" Parameters Param Description exception Value (of type DRV_PLC_PHY_EXCEPTION Enum) identifying the exception code which occurs during SPI transfer ",
							" Returns None ",
							" Example void APP_MyExceptionEventHandler( DRV_PLC_PHY_EXCEPTION exception ) { switch (exceptionObj) { case DRV_PLC_PHY_EXCEPTION_UNEXPECTED_KEY: // SPI has detected an unexpected status reset is recommended break; case DRV_PLC_PHY_EXCEPTION_CRITICAL_ERROR: // SPI critical error in last transfer Bootloader task has failured break; case DRV_PLC_PHY_EXCEPTION_DEBUG: // PLC transceiver has been reset by Debugging tool break; case DRV_PLC_PHY_EXCEPTION_RESET: // PLC transceiver has been reset break; default: // SPI has detected an unexpected status reset is recommended } appData- macrt_exception = true; } ",
							" Remarks None ",
							" DRV_PLC_PHY_EXCEPTION Enum ",
							" C typedef enum { /* SPI has detected an unexpected status reset is recommended */ DRV_PLC_PHY_EXCEPTION_UNEXPECTED_KEY /* SPI critical error */ DRV_PLC_PHY_EXCEPTION_CRITICAL_ERROR /* Device has been reseted by Debugging tool */ DRV_PLC_PHY_EXCEPTION_DEBUG /* Device has been reseted */ DRV_PLC_PHY_EXCEPTION_RESET } DRV_PLC_PHY_EXCEPTION; ",
							" Summary Defines the data type for G3 MAC RT Driver transfer errors ",
							" Description This type is used to indicate the error (if any) of the last SPI transfer ",
							" G3 Data types and constants G3 Data types and constants ",
							" DRV_PLC_PHY_ID Enum ",
							" C typedef enum { PLC_ID_HOST_DESCRIPTION_ID = 0x0100 PLC_ID_HOST_MODEL_ID = 0x010A PLC_ID_HOST_PHY_ID = 0x010C PLC_ID_HOST_PRODUCT_ID = 0x0110 PLC_ID_HOST_VERSION_ID = 0x0112 PLC_ID_HOST_BAND_ID = 0x0116 PLC_ID_TIME_REF_ID = 0x0200 PLC_ID_PRODID = 0x4000 PLC_ID_MODEL PLC_ID_VERSION_STR PLC_ID_VERSION_NUM PLC_ID_TONE_MASK PLC_ID_TONE_MAP_RSP_DATA PLC_ID_TX_TOTAL PLC_ID_TX_TOTAL_BYTES PLC_ID_TX_TOTAL_ERRORS PLC_ID_TX_BAD_BUSY_TX PLC_ID_TX_BAD_BUSY_CHANNEL PLC_ID_TX_BAD_LEN PLC_ID_TX_BAD_FORMAT PLC_ID_TX_TIMEOUT PLC_ID_RX_TOTAL PLC_ID_RX_TOTAL_BYTES PLC_ID_RX_RS_ERRORS PLC_ID_RX_EXCEPTIONS PLC_ID_RX_BAD_LEN PLC_ID_RX_BAD_CRC_FCH PLC_ID_RX_FALSE_POSITIVE PLC_ID_RX_BAD_FORMAT PLC_ID_ENABLE_AUTO_NOISE_CAPTURE PLC_ID_TIME_BETWEEN_NOISE_CAPTURES PLC_ID_DELAY_NOISE_CAPTURE_AFTER_RX PLC_ID_RRC_NOTCH_ACTIVE PLC_ID_RRC_NOTCH_INDEX PLC_ID_NOISE_PEAK_POWER PLC_ID_CRC_TX_RX_CAPABILITY PLC_ID_RX_BAD_CRC_PAY PLC_ID_CFG_AUTODETECT_IMPEDANCE PLC_ID_CFG_IMPEDANCE PLC_ID_ZC_PERIOD PLC_ID_FCH_SYMBOLS PLC_ID_TX_PAY_SYMBOLS PLC_ID_RX_PAY_SYMBOLS PLC_ID_RRC_NOTCH_AUTODETECT PLC_ID_MAX_RMS_TABLE_HI PLC_ID_MAX_RMS_TABLE_VLO PLC_ID_THRESHOLDS_TABLE_HI PLC_ID_THRESHOLDS_TABLE_LO PLC_ID_THRESHOLDS_TABLE_VLO PLC_ID_PREDIST_COEF_TABLE_HI PLC_ID_PREDIST_COEF_TABLE_LO PLC_ID_PREDIST_COEF_TABLE_VLO PLC_ID_GAIN_TABLE_HI PLC_ID_GAIN_TABLE_LO PLC_ID_GAIN_TABLE_VLO PLC_ID_DACC_TABLE_CFG PLC_ID_RSV0 PLC_ID_NUM_TX_LEVELS PLC_ID_CORRECTED_RMS_CALC PLC_ID_RRC_NOTCH_THR_ON PLC_ID_RRC_NOTCH_THR_OFF PLC_ID_CURRENT_GAIN PLC_ID_ZC_CONF_INV PLC_ID_ZC_CONF_FREQ PLC_ID_ZC_CONF_DELAY PLC_ID_NOISE_PER_CARRIER PLC_ID_SYNC_XCORR_THRESHOLD PLC_ID_SYNC_XCORR_PEAK_VALUE PLC_ID_SYNC_SYNCM_THRESHOLD PLC_ID_TONE_MAP_RSP_ENABLED_MODS PLC_ID_PPM_CALIB_ON PLC_ID_SFO_ESTIMATION_LAST_RX PLC_ID_PDC_LAST_RX PLC_ID_MAX_PSDU_LEN_PARAMS PLC_ID_MAX_PSDU_LEN PLC_ID_RESET_STATS PLC_ID_IC_DRIVER_CFG PLC_ID_RX_CHN_EST_REAL PLC_ID_RX_CHN_EST_IMAG PLC_ID_TX_DISABLE PLC_ID_TX_HIGH_TEMP_120 PLC_ID_TX_CANCELLED PLC_ID_ZC_VALUE PLC_ID_PDC_RX_LAST_RX PLC_ID_PDC_ZC_TIME_LAST_RX PLC_ID_PDC_ZC_PERIOD_LAST_RX PLC_ID_PREAMBLE_NUM_SYNCP PLC_ID_END_ID } DRV_PLC_PHY_ID; ",
							" Summary List of G3 PLC PHY IBs ",
							" Description This Enum contains every accessible objet in G3 PLC PHY Information Base A detailed description of these objects is available in G3 DRV_PLC_PHY_IDs  ",
							" DRV_PLC_PHY_IDs ",
							" PLC_ID_HOST_DESCRIPTION_ID (0x0100) Description: Name of MCU in string format where PL360 Host Controller is running Access: Read-only Value Range: 10 bytes Default Value: \"SAME70\" or \"PIC32CX\" ",
							" PLC_ID_HOST_MODEL_ID (0x010A) Description: Model identification number of the PL360 Host Controller Access: Read-only Value Range: 2 bytes Default Value: 0x0002 ",
							" PLC_ID_HOST_PHY_ID (0x010C) Description: Physical identification number of the PL360 Host Controller It is composed of PLC_ID_HOST_VERSION_ID (0x0112) + PLC_ID_HOST_BAND_ID (0x0116) Access: Read-only Value Range: 4 bytes Default Value: 0x36010104 (CENELEC-A) 0x36020104 (FCC) or 0x36040104 (CENELEC-B) ",
							" PLC_ID_HOST_PRODUCT_ID (0x0110) Description: Product identification number of the PL360 Host Controller Access: Read-only Value Range: 2 bytes Default Value: 0x3601 ",
							" PLC_ID_HOST_VERSION_ID (0x0112) Description: Version number of the PL360 Host Controller Access: Read-only Value Range: 4 bytes Default Value: 0x36010200 ",
							" PLC_ID_HOST_BAND_ID (0x0116) Description: Workband identification number of the PL360 Host Controller Access: Read-only Value Range: 1 byte Default Value: 1: CENELEC A 2: FCC 4: CENELEC B ",
							" PLC_ID_TIME_REF_ID (0x0200) Description: Time reference in microseconds from the last reset of the PL360 device Access: Read-only Value Range: 4 bytes Default Value: Not applicable ",
							" PLC_ID_PRODID (0x4000) Description: Product Identifier of firmware embedded in PL360 device Access: Read-only Value Range: 8 bytes Default Value: \"ATPL360B\" ",
							" PLC_ID_MODEL (0x4001) Description: Model Identifier of firmware embedded in PL360 device Access: Read-only Value Range: 2 bytes Default Value: 0x3601 ",
							" PLC_ID_VERSION_STR (0x4002) Description: Version number of PL360 PHY embedded firmware in string format The format is \"AA BB CC DD\" where: AA: Corresponds to device model (\"36\") BB: Corresponds to G3 band CC: Major version number DD: Minor version number Access: Read-only Value Range: 11 bytes Example Value: \"36 01 05 04\" ",
							" PLC_ID_VERSION_NUM (0x4003) Description: Version number of PL360 PHY embedded firmware in hexadecimal format The format is 0xAABBCCDD where: AA: Corresponds to device model (0x36) BB: Corresponds to G3 band CC: Major version number DD: Minor version number Access: Read-only Value Range: 4 bytes Example Value: 0x36010504 ",
							" PLC_ID_TONE_MASK (0x4004) Description: Configure Tone Mask (Static Notching) For each carrier in the corresponding G3-PLC band there is one byte indicating whether the carrier is used or masked The minimum number of used carriers is 6 Access: Read-write Value Range: 36 bytes (CENELEC-A) 72 bytes (FCC) or 16 bytes (CENELEC-B) Default Value: All 0s ",
							" PLC_ID_TONE_MAP_RSP_DATA (0x4005) Description: Tone Map response data is the best modulation and Tone Map combination to maximize baud rate and minimize frame error rate It is calculated by the selection algorithm based on the signal quality of the last received message See PLC_ID_TONE_MAP_RSP_ENABLED_MODS (0x403E) to enable/disable the different modulations for the selection algorithm The format is defined by the structure shown below: typedef struct { // Modulation type DRV_PLC_PHY_MOD_TYPE modType; // Modulation scheme DRV_PLC_PHY_MOD_SCHEME modScheme; // Tone Map uint8_t toneMap[TONE_MAP_SIZE_MAX]; } DRV_PLC_PHY_TONE_MAP_RSP; Access: Read-only Value Range: 5 bytes Default Value: BPSK Robust modulation type (0x04) differential modulation scheme (0x00) and full tone map (0x3F0000 in CENELEC-A; 0x0F0000 in CENELEC-B; 0xFFFFFF in FCC) ",
							" PLC_ID_TX_TOTAL (0x4006) Description: Number of successfully transmitted PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_TX_TOTAL_BYTES (0x4007) Description: Number of bytes in successfully transmitted PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_TX_TOTAL_ERRORS (0x4008) Description: Number of unsuccessfully transmitted PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_TX_BAD_BUSY_TX (0x4009) Description: Number of times when the PL360 device received new data to transmit (send_data) and there is already data in the TX chain Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_TX_BAD_BUSY_CHANNEL (0x400A) Description: Number of times when the PL360 device received new data to transmit (send_data) and the PLC channel is busy Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_TX_BAD_LEN (0x400B) Description: Number of times when the PL360 device received new data to transmit (send_data) and the specified length in transmission parameters is invalid Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_TX_BAD_FORMAT (0x400C) Description: Number of times when the PL360 device received new data to transmit (send_data) and the transmission parameters are not valid Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_TX_TIMEOUT (0x400D) Description: Number of times when the PL360 device received new data to transmit (send_data) and it cannot transmit data in the specified time provided by the transmission parameters Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RX_TOTAL (0x400E) Description: Number of successfully received PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RX_TOTAL_BYTES (0x400F) Description: Number of bytes in successfully received PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RX_RS_ERRORS (0x4010) Description: Number of corrected errors by RS block in received PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RX_EXCEPTIONS (0x4011) Description: Number of time-out errors in received PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RX_BAD_LEN (0x4012) Description: Number of errors in FCH length in received PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RX_BAD_CRC_FCH (0x4013) Description: Number of errors in FCH CRC in received PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RX_FALSE_POSITIVE (0x4014) Description: Number of errors in PDU synchronization phase Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RX_BAD_FORMAT (0x4015) Description: Number of errors in modulation type field included in FCH of received PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_ENABLE_AUTO_NOISE_CAPTURE (0x4016) Description: Flag to indicate if automatic noise analyzer is enabled in the reception chain If Auto-mode is enabled notch filter parameters (PLC_ID_RRC_NOTCH_ACTIVE (0x4019) PLC_ID_RRC_NOTCH_INDEX (0x401A)) cannot be modified by the user See PLC_ID_TIME_BETWEEN_NOISE_CAPTURES (0x4017) PLC_ID_RRC_NOTCH_THR_ON (0x4034) PLC_ID_RRC_NOTCH_THR_OFF (0x4035) to configure parameters related to the Auto-mode Access: Read-write Value Range: 1 byte  Default Value: 1 ",
							" PLC_ID_TIME_BETWEEN_NOISE_CAPTURES (0x4017) Description: Time in milliseconds between noise captures Access: Read-write Value Range: 4 bytes Default Value: 1000 (1 second) CAUTION: It is recommended that the default value of this parameter be kept If reduced the power consumption could increase The default value is optimum for power consumption and performance of noise detection ",
							" PLC_ID_DELAY_NOISE_CAPTURE_AFTER_RX (0x4018) Description: Time in microseconds to start a new noise capture after PDU reception/transmission Access: Read-write Value Range: 4 bytes  Default Value: 3000 (3 milliseconds) ",
							" PLC_ID_RRC_NOTCH_ACTIVE (0x4019) Description: Number of notched frequencies with RRC notch filter For CENELEC-A and FCC bands up to 5 notched frequencies are allowed For CENELEC-B band only one notched frequency is allowed Access: Depends on noise analyzer mode PLC_ID_ENABLE_AUTO_NOISE_CAPTURE (0x4016) value: Auto-mode (1): Read-only Manual-mode (0): Read-write Value Range: 1 byte  Default Value: 0 (No notched frequencies) ",
							" PLC_ID_RRC_NOTCH_INDEX (0x401A) Description: Array of RRC notch filter index values There is one index for each notched frequency The format of each index is uQ7 8 (2 bytes where MSB must be 0) The 7 integer bits indicate the carrier index for which the notch filter is applied The 8 decimal bits can apply the notch filter to a frequency that is between two consecutive carriers To convert the notch index to frequency (in Hz) the following formula is applied: F = INDEX * Fs / 65536 where Fs is the sampling rate in Hz: CENELEC-A CENELEC-B bands: Fs = 400000 Hz FCC band: Fs = 1200000 Hz For example: CENELEC-A INDEX = 8192 (0x2000): F = 8192 * 400000 / 65536 = 50000 Hz FCC INDEX = 20544 (0x5040): F = 20544 * 1200000 / 65536 = 376172 Hz Access: Depends on noise analyzer mode PLC_ID_ENABLE_AUTO_NOISE_CAPTURE (0x4016) value: 1 (Auto-mode): Read-only 0 (Manual-mode): Read-write Value Range: 10 bytes (CENELEC-A FCC bands) or 2 bytes (CENELEC-B band) Each group of 2 bytes corresponds to one notched frequency (Integer part: 0 - 127 Decimal part: 0-255) Number of valid values depends on PLC_ID_RRC_NOTCH_ACTIVE (0x4019) Default Value: 0 ",
							" PLC_ID_NOISE_PEAK_POWER (0x401B) Description: Estimation of noise level in dBµV for the carrier with highest noise power It is actually the maximum value of the PIB described in PLC_ID_NOISE_PER_CARRIER (0x403A) The value is updated only if noise analyzer Auto-mode is enabled (PLC_ID_ENABLE_AUTO_NOISE_CAPTURE (0x4016)) or if noise capture is triggered manually (PLC_ID_RRC_NOTCH_AUTODETECT (0x4024)) Access: Read-only Value Range: 2 bytes Default Value: 0 ",
							" PLC_ID_CRC_TX_RX_CAPABILITY (0x401C) Description: CRC computation capability If it is enabled 16-bit CRC is computed in transmitted and received PDUs The CRC format is the same that uses the G3-PLC stack which is described in the IEEE 802 15 4 standard In transmission when it is enabled padding and CRC are added to the data automatically In order to ensure that all OFDM symbols are filled with data a zero-padding is inserted after data payload (if it is needed) The padding guarantees that the last 16 bits in reception correspond to the 16-bit CRC The 16-bit CRC is added after the padding In reception when it is enabled CRC is computed over the received PDU and it is compared to the last 16 bits of the data (corresponding to the CRC of the message) to check the integrity of the message These two bytes are not included in the data buffer containing the received frame reported in DRV_PLC_PHY_RECEPTION_OBJ The field crcOk in DRV_PLC_PHY_RECEPTION_OBJ shows whether the CRC is correct or not Microchip G3-PLC stack implementation does not use this functionality since CRC is computed in MAC layer instead of PHY layer The aim of this PIB is to make it easier for customers to build applications over PHY layer Access: Read-write Value Range: 1 byte  Default Value: 0 ",
							" PLC_ID_RX_BAD_CRC_PAY (0x401D) Description: Number of errors in payload CRC in received PDUs It is only updated if CRC capability is enabled (see PLC_ID_CRC_TX_RX_CAPABILITY (0x401C)) Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x401E) Description: Auto-Detect Impedance Mode Transmission Automatic Gain Control (Tx AGC) and Automatic Transmission Mode Control (ATMC) can be enabled/disabled There are 3 available modes: OFF : Tx AGC disabled ATMC disabled ON : Tx AGC enabled ATMC enabled AGC : Tx AGC enabled ATMC disabled Access: Read-write Value Range: 1 byte  Default Value: 1 ",
							" PLC_ID_CFG_IMPEDANCE (0x401F) Description: Transmission Mode (HIGH LOW VERY_LOW) It is automatically updated if ATMC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x401E)) Access: Read-write Value Range: 1 byte  Default Value: 0 ",
							" PLC_ID_ZC_PERIOD (0x4020) Description: Last estimation of the mains Zero-Crossing period in microseconds Access: Read-only Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_FCH_SYMBOLS (0x4021) Description: Number of symbols in Frame Control Header Depends on the G3 band in use and Tone Mask (see PLC_ID_TONE_MASK (0x4004)) Access: Read-only Value Range: 1 byte  Default Value: 13 (CENELEC-A) 12 (FCC) 30 (CENELEC-B) ",
							" PLC_ID_PAY_SYMBOLS_TX (0x4022) Description: Number of payload symbols in the last requested transmission Access: Read-only Value Range: 2 bytes  Default Value: 0 ",
							" PLC_ID_PAY_SYMBOLS_RX (0x4023) Description: Number of payload symbols in last received message Access: Read-only Value Range: 2 bytes  Default Value: 0 ",
							" PLC_ID_RRC_NOTCH_AUTODETECT (0x4024) Description: Trigger to start noise analysis If noise analyzer Manual-mode is enabled (see PLC_ID_ENABLE_AUTO_NOISE_CAPTURE (0x4016)) noise capture can be triggered through this PIB by writing 1 Writing 0 has no effect If noise analyzer Auto-mode is enabled writing any value has no effect Access: Write-only Value Range: 1 byte Default Value: 0 ",
							" PLC_ID_MAX_RMS_TABLE_HI (0x4025) Description: Target value of RMS_CALC in HIGH Tx Mode (see PLC_ID_CFG_IMPEDANCE (0x401F)) RMS_CALC will tend to this value by automatically adjusting the gain after every transmission (see PLC_ID_CURRENT_GAIN (0x4036)) These parameters are only used if Tx AGC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x401E)) Access: Read-write Value Range: 32 bytes Byte 0-3 Byte 4-7 Byte 8-11 Byte 12-15 Byte 16-19 Byte 20-24 Byte 25-27 Byte 28-31 RMS_HI_0 RMS_HI_1 RMS_HI_2 RMS_HI_3 RMS_HI_4 RMS_HI_5 RMS_HI_6 RMS_HI_7 where RMS_HI_x: Target value of RMS_CALC in mode of transmission HIGH for the attenuation level x (attenuation levels in 3dB steps) Default Value: G3 BAND RMS_HI_0 RMS_HI_1 RMS_HI_2 RMS_HI_3 RMS_HI_4 RMS_HI_5 RMS_HI_6 RMS_HI_7 CEN-A 1991 1381 976 695 495 351 250 179 FCC 1355 960 681 485 345 246 177 129 CEN-B 1133 793 559 396 280 199 143 108 ",
							" PLC_ID_MAX_RMS_TABLE_VLO (0x4026) Description: Target value of RMS_CALC in VERY_LOW Tx Mode (see PLC_ID_CFG_IMPEDANCE (0x401F)) RMS_CALC will tend to this value by automatically adjusting the gain after every transmission (see PLC_ID_CURRENT_GAIN (0x4036)) These parameters are only used if Tx AGC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x401E)) Access: Read-write Value Range: 32 bytes Byte 0-3 Byte 4-7 Byte 8-11 Byte 12-15 Byte 16-19 Byte 20-24 Byte 25-27 Byte 28-31 RMS_VLO_0 RMS_VLO_1 RMS_VLO_2 RMS_VLO_3 RMS_VLO_4 RMS_VLO_5 RMS_VLO_6 RMS_VLO_7 where: RMS_HI_x: Target value of RMS_CALC in mode of transmission VERY_LOW for the attenuation level x (attenuation levels in 3dB steps) Default Value: G3 BAND RMS_VLO_0 RMS_VLO_1 RMS_VLO_2 RMS_VLO_3 RMS_VLO_4 RMS_VLO_5 RMS_VLO_6 RMS_VLO_7 CEN-A 6356 4706 3317 2308 1602 1112 778 546 FCC 5656 4174 2877 1987 1413 1020 736 532 CEN-B 2871 2120 1498 1054 740 519 366 259 ",
							" PLC_ID_THRESHOLDS_TABLE_HI (0x4027) Description: Table of thresholds to automatically update Tx Mode (see PLC_ID_CFG_IMPEDANCE (0x401F)) from HIGH mode These parameters are only used if ATMC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x401E)) Corrected RMS_CALC (see PLC_ID_CORRECTED_RMS_CALC (0x4033)) is compared with these thresholds after every transmission to select Tx Mode for next transmission The decision is taken following the steps shown below: If corrected RMS_CALC is below TH_HI_VLO_x Tx Mode will be updated to VERY_LOW mode Else if corrected RMS_CALC is below TH_HI_LO_x Tx Mode will be updated to LOW mode Else Tx Mode will remain in HIGH mode where: TH_HI_VLO_x: Threshold to change from HIGH to VERY_LOW mode for Tx attenuation level x (3 dB steps) TH_HI_LO_x: Threshold to change from HIGH to LOW mode for Tx attenuation level x (3 dB steps) Access: Read-write Value Range: 64 bytes Byte 0-3 Byte 4-7 Byte 8-11 Byte 12-15 Byte 16-19 Byte 20-24 Byte 25-27 Byte 28-31 TH_HI_LO_0 TH_HI_LO_1 TH_HI_LO_2 TH_HI_LO_3 TH_HI_LO_4 TH_HI_LO_5 TH_HI_LO_6 TH_HI_LO_7 Byte 32-35 Byte 36-39 Byte 40-43 Byte 44-47 Byte 48-51 Byte 52-55 Byte 56-59 Byte 60-63 TH_HI_VLO_0 TH_HI_VLO_1 TH_HI_VLO_2 TH_HI_VLO_3 TH_HI_VLO_4 TH_HI_VLO_5 TH_HI_VLO_6 TH_HI_VLO_7 Default Value: G3 BAND TH_HI_LO_0 TH_HI_LO_1 TH_HI_LO_2 TH_HI_LO_3 TH_HI_LO_4 TH_HI_LO_5 TH_HI_LO_6 TH_HI_LO_7 CEN-A 0 0 0 0 0 0 0 0 FCC 0 0 0 0 0 0 0 0 CEN-B 0 0 0 0 0 0 0 0 G3 BAND TH_HI_VLO_0 TH_HI_VLO_1 TH_HI_VLO_2 TH_HI_VLO_3 TH_HI_VLO_4 TH_HI_VLO_5 TH_HI_VLO_6 TH_HI_VLO_7 CEN-A 1685 1173 828 589 419 298 212 151 FCC 1147 811 576 409 291 208 150 109 CEN-B 950 667 471 334 238 169 122 90 ",
							" PLC_ID_THRESHOLDS_TABLE_LO (0x4028) Description: Table of thresholds to automatically update Tx Mode (see PLC_ID_CFG_IMPEDANCE (0x401F)) from LOW mode These parameters are only used if ATMC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x401E)) Corrected RMS_CALC (see PLC_ID_CORRECTED_RMS_CALC (0x4033)) is compared with these thresholds after every transmission to select Tx Mode for next transmission The decision is taken following the steps shown below: If corrected RMS_CALC is below TH_LO_VLO_x Tx Mode will be updated to VERY_LOW mode Else if corrected RMS_CALC is above TH_LO_HI_x Tx Mode will be updated to HIGH mode Else Tx Mode will remain in LOW mode where: TH_LO_VLO_x: Threshold to change from LOW to VERY_LOW mode for Tx attenuation level x (3 dB steps) TH_LO_HI_x: Threshold to change from LOW to HIGH mode for Tx attenuation level x (3 dB steps) Access: Read-write Value Range: 64 bytes Byte 0-3 Byte 4-7 Byte 8-11 Byte 12-15 Byte 16-19 Byte 20-24 Byte 25-27 Byte 28-31 TH_LO_HI_0 TH_LO_HI_1 TH_LO_HI_2 TH_LO_HI_3 TH_LO_HI_4 TH_LO_HI_5 TH_LO_HI_6 TH_LO_HI_7 Byte 32-35 Byte 36-39 Byte 40-43 Byte 44-47 Byte 48-51 Byte 52-55 Byte 56-59 Byte 60-63 TH_LO_VLO_0 TH_LO_VLO_1 TH_LO_VLO_2 TH_LO_VLO_3 TH_LO_VLO_4 TH_LO_VLO_5 TH_LO_VLO_6 TH_LO_VLO_7 Default Value: G3 BAND TH_LO_HI_0 TH_LO_HI_1 TH_LO_HI_2 TH_LO_HI_3 TH_LO_HI_4 TH_LO_HI_5 TH_LO_HI_6 TH_LO_HI_7 CEN-A 0 0 0 0 0 0 0 0 FCC 0 0 0 0 0 0 0 0 CEN-B 0 0 0 0 0 0 0 0 G3 BAND TH_LO_VLO_0 TH_LO_VLO_1 TH_LO_VLO_2 TH_LO_VLO_3 TH_LO_VLO_4 TH_LO_VLO_5 TH_LO_VLO_6 TH_LO_VLO_7 CEN-A 0 0 0 0 0 0 0 0 FCC 0 0 0 0 0 0 0 0 CEN-B 0 0 0 0 0 0 0 0 ",
							" PLC_ID_THRESHOLDS_TABLE_VLO (0x4029) Description: Table of thresholds to automatically update Tx Mode (see PLC_ID_CFG_IMPEDANCE (0x401F)) from VERY_LOW mode These parameters are only used if ATMC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x401E)) Corrected RMS_CALC (see PLC_ID_CORRECTED_RMS_CALC (0x4033)) is compared with these thresholds after every transmission to select Tx Mode for next transmission The decision is taken following the steps shown below: If corrected RMS_CALC is below TH_VLO_VLO_x Tx Mode will remain in VERY_LOW mode Else if corrected RMS_CALC is above TH_VLO_HI_x Tx Mode will be updated to HIGH mode Else Tx Mode will be updated to LOW mode where: TH_VLO_VLO_x: Threshold to remain Tx mode in VERY_LOW mode for Tx attenuation level x (3 dB steps) TH_VLO_HI_x: Threshold to change from VERY_LOW to HIGH mode for Tx attenuation level x (3 dB steps) Access: Read-write Value Range: 64 bytes Byte 0-3 Byte 4-7 Byte 8-11 Byte 12-15 Byte 16-19 Byte 20-24 Byte 25-27 Byte 28-31 TH_VLO_HI_0 TH_VLO_HI_1 TH_VLO_HI_2 TH_VLO_HI_3 TH_VLO_HI_4 TH_VLO_HI_5 TH_VLO_HI_6 TH_VLO_HI_7 Byte 32-35 Byte 36-39 Byte 40-43 Byte 44-47 Byte 48-51 Byte 52-55 Byte 56-59 Byte 60-63 TH_VLO_VLO_0 TH_VLO_VLO_1 TH_VLO_VLO_2 TH_VLO_VLO_3 TH_VLO_VLO_4 TH_VLO_VLO_5 TH_VLO_VLO_6 TH_VLO_VLO_7 Default Value: G3 BAND TH_VLO_HI_0 TH_VLO_HI_1 TH_VLO_HI_2 TH_VLO_HI_3 TH_VLO_HI_4 TH_VLO_HI_5 TH_VLO_HI_6 TH_VLO_HI_7 CEN-A 0 0 0 0 0 0 0 0 FCC 0 0 0 0 0 0 0 0 CEN-B 0 0 0 0 0 0 0 0 G3 BAND TH_VLO_VLO_0 TH_VLO_VLO_1 TH_VLO_VLO_2 TH_VLO_VLO_3 TH_VLO_VLO_4 TH_VLO_VLO_5 TH_VLO_VLO_6 TH_VLO_VLO_7 CEN-A 8988 6370 4466 3119 2171 1512 1061 752 FCC 8153 5718 4007 2871 2080 1506 1083 778 CEN-B 3878 2749 1935 1362 965 686 493 353 ",
							" PLC_ID_PREDIST_COEF_TABLE_HI (0x402A) Description: Equalization Coefficients table in HIGH Tx mode There is one coefficient for each carrier in the used band The format of each coefficient is uQ0 16 (2 bytes) PL360 firmware compensates the total gain internally so modifying the digital gain (see PLC_ID_GAIN_TABLE_HI (0x402D)) is not needed when equalization is modified Access: Read-write Value Range: 72 bytes (CENELEC-A) 32 bytes (CENELEC-B) or 144 bytes (FCC) Default Value: CENELEC-A: {0x670A 0x660F 0x676A 0x6A6B 0x6F3F 0x7440 0x74ED 0x7792 0x762D 0x7530 0x7938 0x7C0A 0x7C2A 0x7B0E 0x7AF2 0x784B 0x7899 0x76F9 0x76D6 0x769F 0x775D 0x70C0 0x6EB9 0x6F18 0x6F1E 0x6FA2 0x6862 0x67C9 0x68F9 0x68A5 0x6CA3 0x7153 0x7533 0x750B 0x7B59 0x7FFF} FCC: {0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF} CENELEC-B: {0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF} ",
							" PLC_ID_PREDIST_COEF_TABLE_LO (0x402B) Description: Equalization Coefficients table in LOW Tx mode There is one coefficient for each carrier in the used band The format of each coefficient is uQ0 16 (2 bytes) PL360 firmware compensates the total gain internally so modifying the gain it is not needed (see PLC_ID_GAIN_TABLE_LO (0x402E)) when equalization is modified Access: Read-write Value Range: 72 bytes (CENELEC-A) 32 bytes (CENELEC-B) or 144 bytes (FCC) Default Value: CENELEC-A: {0x7FFF 0x7DB1 0x7CE6 0x7B36 0x772F 0x7472 0x70AA 0x6BC2 0x682D 0x6618 0x6384 0x6210 0x61D7 0x6244 0x6269 0x63A8 0x6528 0x65CC 0x67F6 0x693B 0x6B13 0x6C29 0x6D43 0x6E26 0x6D70 0x6C94 0x6BB5 0x6AC9 0x6A5F 0x6B65 0x6B8C 0x6A62 0x6CEC 0x6D5A 0x6F9D 0x6FD3} FCC: {0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF} CENELEC-B: {0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF} ",
							" PLC_ID_PREDIST_COEF_TABLE_VLO (0x402C) Description: Equalization Coefficients table in VERY_LOW Tx mode There is one coefficient for each carrier in the used band The format of each coefficient is uQ0 16 (2 bytes) PL360 firmware compensates the total gain internally so modifying the gain is not needed (see PLC_ID_GAIN_TABLE_VLO (0x402F)) when equalization is modified Access: Read-write Value Range: 72 bytes (CENELEC-A) 32 bytes (CENELEC-B) or 144 bytes (FCC) Default Value: CENELEC-A: {0x7FFF 0x7DB1 0x7CE6 0x7B36 0x772F 0x7472 0x70AA 0x6BC2 0x682D 0x6618 0x6384 0x6210 0x61D7 0x6244 0x6269 0x63A8 0x6528 0x65CC 0x67F6 0x693B 0x6B13 0x6C29 0x6D43 0x6E26 0x6D70 0x6C94 0x6BB5 0x6AC9 0x6A5F 0x6B65 0x6B8C 0x6A62 0x6CEC 0x6D5A 0x6F9D 0x6FD3} FCC: {0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF} CENELEC-B: {0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF} ",
							" PLC_ID_GAIN_TABLE_HI (0x402D) Description: Table of gain values for HIGH Tx Mode Access: Read-write Value Range: 6 bytes Byte 0-1 Byte 2-3 Byte 4-5 GAIN_HI_INI GAIN_HI_MIN GAIN_HI_MAX where: GAIN_HI_INI: Initial gain value in HIGH Tx Mode The minimum value is GAIN_HI_MIN GAIN_HI_MIN: Minimum gain value in HIGH Tx Mode The minimum value is 1 GAIN_HI_MAX: Maximum gain value in HIGH Tx Mode The minimum value is GAIN_HI_INI GAIN_HI_MIN and GAIN_HI_MAX are only used if Tx AGC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x401E)) Default Value: G3 BAND GAIN_HI_INI GAIN_HI_MIN GAIN_HI_MAX CENELEC-A 142 70 336 FCC 109 50 256 CENELEC-B 248 119 496 ",
							" PLC_ID_GAIN_TABLE_LO (0x402E) Description: Gain value in LOW Tx Mode Access: Read-write Value Range: 2 bytes The minimum value is 1 Default Value: CENELEC-A: 474; FCC: 364; CENELEC-B: 701 ",
							" PLC_ID_GAIN_TABLE_VLO (0x402F) Description: Table of gain values for VERY_LOW Tx Mode Access: Read-write Value Range: 6 bytes Byte 0-1 Byte 2-3 Byte 4-5 GAIN_VLO_INI GAIN_VLO_MIN GAIN_VLO_MAX where: GAIN_VLO_INI: Initial gain value in VERY_LOW Tx Mode The minimum value is GAIN_VLO_MIN GAIN_VLO_MIN: Minimum gain value in VERY_LOW Tx Mode The minimum value is 1 GAIN_VLO_MAX: Maximum gain value in VERY_LOW Tx Mode The minimum value is GAIN_VLO_INI GAIN_VLO_MIN and GAIN_VLO_MAX are only used if Tx AGC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x401E)) Default Value: G3 BAND GAIN_VLO_INI GAIN_VLO_MIN GAIN_VLO_MAX CENELEC-A 474 230 597 FCC 364 180 408 CENELEC-B 701 350 883 ",
							" PLC_ID_DACC_TABLE_CFG (0x4030) Description: Configuration values of DACC peripheral according to hardware configuration Access: Read-write Value Range: 68 bytes Default Value: CENELEC-A: {0x00000000 0x00002120 0x0000073F 0x00003F3F 0x00000333 0x00000000 0x610800FF 0x14141414 0x00002020 0x00000044 0x0FD20004 0x00000355 0x0F000000 0x001020F0 0x00000355 0x0F000000 0x001020FF} FCC: {0x00000000 0x10102120 0x033F073F 0x3F3F3F3F 0x00000FFF 0x00000000 0x2A3000FF 0x1B1B1B1B 0x10101010 0x00001111 0x04380006 0x000003AA 0xF0000000 0x001020F0 0x00000355 0x0F000000 0x001020FF} CENELEC-B: {0x00000000 0x00002120 0x0000073F 0x00003F3F 0x00000333 0x00000000 0x58CA00FF 0x19191919 0x00002020 0x00000044 0x0FD20004 0x00000355 0x0F000000 0x001020F0 0x00000355 0x0F000000 0x001020FF} ",
							" PLC_ID_NUM_TX_LEVELS (0x4032) Description: Number of Tx attenuation levels (3 dB steps) for normal transmission behavior When attenuation field (see DRV_PLC_PHY_TRANSMISSION_OBJ ) is higher than or equal to the number of Tx attenuation levels Tx Mode is internally forced by the PL360 device to LOW mode Access: Read-write Value Range: 1 byte  Default Value: 8 ",
							" PLC_ID_CORRECTED_RMS_CALC (0x4033) Description: RMS_CALC value obtained in the last transmitted message compensated with gain applied by Tx AGC algorithm (see PLC_ID_CURRENT_GAIN (0x4036)) This is the value which is actually compared with thresholds (PLC_ID_THRESHOLDS_TABLE_VLO (0x4029) PLC_ID_THRESHOLDS_TABLE_HI (0x4027)) to automatically update Tx Mode Access: Read-only Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RRC_NOTCH_THR_ON (0x4034) Description: Activation threshold for narrow/broad-band noise detection in dBµV with uQ14 2 format Access: Read-write Value Range: 2 bytes Default Value: 270 (67 5 dBµV; CENELEC-A) 281 (70 25 dBµV; CENELEC-B) or 258 (64 5 dBµV; FCC) ",
							" PLC_ID_RRC_NOTCH_THR_OFF (0x4035) Description: Deactivation threshold for narrow band noise (in dBμV quarters uQ14 2) Access: Read-write Value Range: 2 bytes Default Value: 254 (63 5 dBµV; CENELEC-A) 265 (66 25 dBµV; CENELEC-B) or 242 (60 5 dBµV; FCC) ",
							" PLC_ID_CURRENT_GAIN (0x4036) Description: Transmission Gain which will be used in the next transmitted message It can vary after every transmission if Tx AGC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x401E)) Maximum and minimum Gain values can be set in PLC_ID_GAIN_TABLE_HI (0x402D) and PLC_ID_GAIN_TABLE_VLO (0x402F) Access: Read-only Value Range: 2 bytes Default Value: 142 (CENELEC-A) 109 (FCC) or 248 (CENELEC-B) ",
							" PLC_ID_ZC_CONF_INV (0x4037) Description: Polarity of the pulse generated by the external Zero-Crossing detection circuit For further information refer to Zero-Crossing Configuration Access: Read-write Value Range: 1 byte  Default Value: 1 ",
							" PLC_ID_ZC_CONF_FREQ (0x4038) Description: Initial frequency in Hz for the mains Zero-Crossing detection algorithm For further information refer to Zero-Crossing Configuration Access: Read-write Value Range: 1 byte  Default Value: 50 ",
							" PLC_ID_ZC_CONF_DELAY (0x4039) Description: Time Delay in microseconds of the external mains Zero-Crossing Detection circuit For further information refer to Zero-Crossing Configuration Access: Read-write Value Range: 2 bytes Default Value: -350 ",
							" PLC_ID_NOISE_PER_CARRIER (0x403A) Description: Estimation of noise level in dBµV for each carrier in the working band This information is used internally by the PL360 PHY for narrow/broad-band noise detection and notch filter activation The value is updated only if Auto-mode is enabled (PLC_ID_ENABLE_AUTO_NOISE_CAPTURE (0x4016)) or noise capture is triggered through PLC_ID_RRC_NOTCH_AUTODETECT (0x4024) Access: Read only Value Range: 36 bytes (CENELEC-A) 16 bytes (CENELEC-B) or 72 bytes (FCC) Default Value: All 0s ",
							" PLC_ID_SYNC_XCORR_THRESHOLD (0x403B) Description: Correlation threshold for synchronization (preamble detection) The format is uQ0 16 It represents percentage with respect to the maximum ideal value of correlation (computed internally in PL360) Access: Read-write Value Range: 2 bytes Default Value: 0x7400 (45 3%) CAUTION It is recommended to keep the default value of this parameter in order to maintain expected reception performance ",
							" PLC_ID_SYNC_XCORR_PEAK_VALUE (0x403C) Description: Correlation value in last received PDU The format is the same described in PLC_ID_SYNC_XCORR_THRESHOLD (0x403B) Access: Read-only Value Range: 2 bytes Default Value: 0 ",
							" PLC_ID_SYNC_SYNCM_THRESHOLD (0x403D) Description: Threshold for SYNCM detection (once preamble is detected with correlation) Access: Read-write Value Range: 2 bytes Default Value: 15299 CAUTION It is recommended to keep the default value of this parameter in order to maintain expected reception performance ",
							" PLC_ID_TONE_MAP_RSP_ENABLED_MODS (0x403E) Description: Bitmask to enable/disable the available modulations for the algorithm to select modulation and Tone Map (see PLC_ID_TONE_MAP_RSP_DATA (0x4005)) Each bit corresponds to a combination of modulation type and modulation scheme The modulation is enabled if the corresponding bit is 1 Bit 7 (MSB) Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 (LSB) 8PSK_D 8PSK_C QPSK_D QPSK_C BPSK_D BPSK_C ROBO_D ROBO_C Access: Read-write Value Range: 1 byte (1-255) Default Value: 0xFF (All modulations enabled) ",
							" PLC_ID_PPM_CALIB_ON (0x403F) Description: Enable the oscillator clock signal to go out through TXRX1 pad This is useful to measure clock frequency deviation Access: Read-write Value Range: 1 byte  Default Value: 0 ",
							" PLC_ID_SFO_ESTIMATION_LAST_RX (0x4040) Description: Estimation of the double-sided (between transmitter and receiver) clock frequency deviation for the last received PDU The value is signed and the unit is 0 001 ppm To convert to ppm the read value has to be divided by 1000 Access: Read-only Value Range: 4 bytes  Default Value: 0 ",
							" PLC_ID_PDC_LAST_RX (0x4041) Description: PDC value coming in the FCH of the last received PDU Access: Read-only Value Range: 1 byte Default Value: 0 ",
							" PLC_ID_MAX_PSDU_LEN_PARAMS (0x4042) Description: Parameters used for the computation of the maximum PDU length (see PLC_ID_MAX_PSDU_LEN (0x4043)) The format is defined by the structure shown below: typedef struct { // Modulation type DRV_PLC_PHY_MOD_TYPE modType; // Modulation scheme DRV_PLC_PHY_MOD_SCHEME modScheme; // Flag to indicate whether 2 Reed-Solomon blocks have to be used (only used for FCC) uint8_t rs2Blocks; // Tone Map uint8_t toneMap[TONE_MAP_SIZE_MAX]; } DRV_PLC_PHY_MAX_PSDU_LEN_PARAMS; Access: Read-write Value Range: 6 bytes Default Value: BPSK Robust modulation type (0x04) differential modulation scheme (0x00) 1 Reed Solomon block (0x00) and full tone map (0x3F0000 in CENELEC-A; 0x0F0000 in CENELEC-B; 0xFFFFFF in FCC) ",
							" PLC_ID_MAX_PSDU_LEN (0x4043) Description: Maximum PDU length allowed by PHY layer depending on Modulation type Modulation scheme Tone map and number of Reed-Solomon blocks (see PLC_ID_MAX_PSDU_LEN_PARAMS (0x4042) to configure these parameters) If CRC capability is enabled (see PLC_ID_CRC_TX_RX_CAPABILITY (0x401C)) the final result does not include the 2 bytes of the 16-bit CRC computed by the PL360 Access: Read-only Value Range: 2 bytes (CENELEC-A CENELEC-B: 0-239; FCC: 0-494) Default Value: 133 (CENELEC-A); 54 (CENELEC-B); 247 (FCC) ",
							" PLC_ID_RESET_STATS (0x4044) Description: Writing any value (1 - 255) causes all PHY statistics (PLC_ID_TX_TOTAL PLC_ID_RX_TOTAL etc ) to be reset to 0 Access: Write-only Value Range: 1 byte Default Value: 0 ",
							" PLC_ID_IC_DRIVER_CFG (0x4045) Description: This parameter configures the Transmission PLC Driver It must be configured according to the PLC device used There are four available modes one for PL360 or PL485 and three for PL460: PL360 : Configured for PL360 or PL485 PL460_MAIN_BRANCH_1F : Configured for PL460 using Main Transmission Branch with a single external filter When transmitting both ASO pins are activated simultaneously for all Tx Modes PL460_MAIN_BRANCH_2F : Configured for PL460 using Main Transmission Branch with two external filters When transmitting ASO0 is activated if HIGH Tx mode and ASO1 is activated if LOW / VERY_LOW Tx mode (see PLC_ID_CFG_IMPEDANCE (0x401F)) PL460_AUX_BRANCH : Configured for PL460 using Auxiliary Transmission Branch For further information refer to the PL460 data sheet Access: Read-write Value Range: 1 byte  Default value: 0 ",
							" PLC_ID_RX_CHN_EST_REAL (0x4046) Description: Real part of Channel Estimation of the last received PDU For each carrier in the working band there is one 2-byte signed value The PL360 PHY layer computes the Channel Estimation from the preamble and FCH symbols which is used for the demodulation of payload symbols The value has no unit and the scale does not reflect the real received signal level although the RSSI ( rssi in DRV_PLC_PHY_RECEPTION_OBJ ) could be used to scale the Channel Estimation and obtain the RSSI per carrier in the working band Access: Read-only Value Range: 72 bytes (CENELEC-A) 32 bytes (CENELEC-B) or 144 bytes (FCC) Default value: All 0s ",
							" PLC_ID_RX_CHN_EST_IMAG (0x4047) Description: Imaginary part of Channel Estimation of the last received PDU For each carrier in the working band there is one 2-byte signed value See PLC_ID_RX_CHN_EST_REAL (0x4046) for more information Access: Read-only Value Range: 72 bytes (CENELEC-A) 32 bytes (CENELEC-B) or 144 bytes (FCC) Default value: All 0s ",
							" PLC_ID_TX_DISABLE (0x4048) Description: This parameter allows disabling of transmissions If disabled ongoing/programmed transmission (if any) will be aborted and subsequent requests will be denied reporting the transmission result DRV_PLC_PHY_TX_CANCELLED  Access: Read-write Value Range: 1 byte  Default value: 0 ",
							" PLC_ID_TX_HIGH_TEMP_120 (0x4049) Description: Number of unsuccessful transmissions because of high temperature ( 120ºC) error i e with transmission result DRV_PLC_PHY_TX_RESULT_HIGH_TEMP_120 This transmission error is only available in PL460 Access: Read-write Value Range: 4 bytes Default value: 0 ",
							" PLC_ID_TX_CANCELLED (0x404A) Description: Number of canceled transmissions i e with transmission result DRV_PLC_PHY_TX_CANCELLED Transmissions can be canceled by: TX_MODE_CANCEL bit in mode parameter (see DRV_PLC_PHY_TRANSMISSION_OBJ ) PLC_ID_TX_DISABLE (0x4048) Tx Enable pin only available in PL460 Access: Read-write Value Range: 4 bytes Default value: 0 ",
							" PLC_ID_ZC_VALUE (0x404B) Description: Gets last deteced Zero-Crossing value in microseconds Access: Read-only Value Range: 4 bytes Default value: 0 ",
							" PLC_ID_PDC_RX_LAST_RX (0x404C) Description: Gets computed Rx PDC for last received frame Access: Read-only Value Range: 1 byte Default value: 0 ",
							" PLC_ID_PDC_ZC_TIME_LAST_RX (0x404D) Description: Gets last measured Zero-Cross time when last frame was received Access: Read-only Value Range: 4 bytes Default value: 0 ",
							" PLC_ID_PDC_ZC_PERIOD_LAST_RX (0x404E) Description: Gets last estimated Zero-Cross period when last frame was received Access: Read-only Value Range: 4 bytes Default value: 0 ",
							" PLC_ID_PREAMBLE_NUM_SYNCP (0x404F) Description: Number of SYNCP symbols present on PLC frames preamble It is used on both Tx for generation and Rx for validation Access: Read-write Value Range: 1 byte  Default value: 8 ",
							" DRV_PLC_PHY_MOD_TYPE Enum ",
							" C typedef enum { MOD_TYPE_BPSK = 0 MOD_TYPE_QPSK = 1 MOD_TYPE_8PSK = 2 MOD_TYPE_BPSK_ROBO = 4 }DRV_PLC_PHY_MOD_TYPE; ",
							" Summary G3 Modulation types ",
							" Description This Enum contains every types of modulation supported by G3 spec ",
							" DRV_PLC_PHY_MOD_TYPE Enum ",
							" C typedef enum { MOD_SCHEME_DIFFERENTIAL = 0 MOD_SCHEME_COHERENT = 1 }DRV_PLC_PHY_MOD_TYPE; ",
							" Summary G3 Modulation schemes ",
							" Description This Enum contains every modulation schemes supported by G3 spec ",
							" DRV_PLC_PHY_DEL_TYPE Enum ",
							" C typedef enum { DT_SOF_NO_RESP = 0 DT_SOF_RESP = 1 DT_ACK = 2 DT_NACK = 3 }DRV_PLC_PHY_DEL_TYPE; ",
							" Summary G3 Delimiter types ",
							" Description This Enum contains every delimiter types supported by G3 spec ",
							" DRV_PLC_PHY_TX_RESULT Enum ",
							" C typedef enum { /* Transmission result: already in process */ DRV_PLC_PHY_TX_RESULT_PROCESS = 0 /* Transmission result: end successfully */ DRV_PLC_PHY_TX_RESULT_SUCCESS = 1 /* Transmission result: invalid length error */ DRV_PLC_PHY_TX_RESULT_INV_LENGTH = 2 /* Transmission result: busy channel error */ DRV_PLC_PHY_TX_RESULT_BUSY_CH = 3 /* Transmission result: busy in transmission error */ DRV_PLC_PHY_TX_RESULT_BUSY_TX = 4 /* Transmission result: busy in reception error */ DRV_PLC_PHY_TX_RESULT_BUSY_RX = 5 /* Transmission result: invalid modulation scheme error */ DRV_PLC_PHY_TX_RESULT_INV_SCHEME = 6 /* Transmission result: timeout error */ DRV_PLC_PHY_TX_RESULT_TIMEOUT = 7 /* Transmission result: invalid tone map error */ DRV_PLC_PHY_TX_RESULT_INV_TONEMAP = 8 /* Transmission result: invalid modulation type error */ DRV_PLC_PHY_TX_RESULT_INV_MODTYPE = 9 /* Transmission result: invalid delimiter type error */ DRV_PLC_PHY_TX_RESULT_INV_DT = 10 /* Transmission result: transmission cancelled */ DRV_PLC_PHY_TX_CANCELLED = 11 /* Transmission result: high temperature error */ DRV_PLC_PHY_TX_RESULT_HIGH_TEMP_120 = 12 /* Transmission result: high temperature warning */ DRV_PLC_PHY_TX_RESULT_HIGH_TEMP_110 = 13 /* Transmission result: No transmission ongoing */ DRV_PLC_PHY_TX_RESULT_NO_TX = 255 }DRV_PLC_PHY_TX_RESULT; ",
							" Summary Identifies the possible values that can result from a PLC transmission request ",
							" Description This Enum contains every transmission result supported by MCHP implementation ",
							" DRV_PLC_PHY_TONE_MAP_RSP Struct ",
							" C typedef struct { /* Modulation type */ DRV_PLC_PHY_MOD_TYPE modType; /* Modulation scheme */ DRV_PLC_PHY_MOD_SCHEME modScheme; /* Tone Map */ uint8_t toneMap[TONE_MAP_SIZE_MAX]; } DRV_PLC_PHY_TONE_MAP_RSP; ",
							" Summary Contains the G3 Tone map response data ",
							" Description This structure contains the information of modulation type modulation scheme and Tone Map data ",
							" Remarks None ",
							" DRV_PLC_PHY_MAX_PSDU_LEN_PARAMS Struct ",
							" C typedef struct { /* Modulation type */ DRV_PLC_PHY_MOD_TYPE modType; /* Modulation scheme */ DRV_PLC_PHY_MOD_SCHEME modScheme; /* Flag to indicate whether 2 Reed-Solomon blocks have to be used (only used for FCC) */ uint8_t rs2Blocks; /* Tone Map */ uint8_t toneMap[TONE_MAP_SIZE_MAX]; } DRV_PLC_PHY_MAX_PSDU_LEN_PARAMS; ",
							" Summary G3 maximum PSDU length parameters data ",
							" Description This structure includes the parameters used to get the maximum PSDU length computation ",
							" Remarks None ",
							" DRV_PLC_PHY_TRANSMISSION_OBJ Struct ",
							" C typedef struct __attribute__((packed aligned(1))) { /* Pointer to data buffer to transmit */ uint8_t *pTransmitData; /* Instant when transmission has to start referred to 1us PHY counter */ uint32_t time; /* Length of the data to transmit in bytes */ uint16_t dataLength; /* Preemphasis for transmission */ uint8_t preemphasis[NUM_SUBBANDS_MAX]; /* Tone Map to use on transmission */ uint8_t toneMap[TONE_MAP_SIZE_MAX]; /* Transmission Mode (absolute relative forced continuous cancel) Constants above */ uint8_t mode; /* Power to transmit */ uint8_t attenuation; /* Phase Detector Counter */ uint8_t pdc; /* Flag to indicate whether 2 Reed-Solomon blocks have to be used (only used for FCC) */ uint8_t rs2Blocks; /* Modulation type */ DRV_PLC_PHY_MOD_TYPE modType; /* Modulation scheme */ DRV_PLC_PHY_MOD_SCHEME modScheme; /* DT field to be used in header */ DRV_PLC_PHY_DEL_TYPE delimiterType; } DRV_PLC_PHY_TRANSMISSION_OBJ; ",
							" Summary G3 Transmission setup data ",
							" Description This structure contains the information of a transmission including parameters of transmission and data to be sent ",
							" Remarks None ",
							" DRV_PLC_PHY_TRANSMISSION_CFM_OBJ Struct ",
							" C typedef struct { /* Instant when frame transmission ended referred to 1us PHY counter */ uint32_t time; /* RMS_CALC it allows to estimate tx power injected */ uint32_t rmsCalc; /* Tx Result (see \"TX Result values\" above) */ DRV_PLC_PHY_TX_RESULT result; } DRV_PLC_PHY_TRANSMISSION_CFM_OBJ; ",
							" Summary G3 Result of a transmission ",
							" Description This structure contains the information of the last transmission its result timestamp and an estimation of the injected power ",
							" Remarks None ",
							" DRV_PLC_PHY_RECEPTION_OBJ Struct ",
							" C typedef struct __attribute__((packed aligned(1))) { /* Pointer to received data buffer */ uint8_t *pReceivedData; /* Instant when frame was received (end of message) referred to 1us PHY counter */ uint32_t time; /* Frame duration referred to 1us PHY counter (Preamble + FCH + Payload) */ uint32_t frameDuration; /* Length of the received data in bytes */ uint16_t dataLength; /* Reception RSSI in dBuV */ uint16_t rssi; /* ZCT info */ uint8_t zctDiff; /* Errors corrected by Reed-Solomon */ uint8_t rsCorrectedErrors; /* Modulation type */ DRV_PLC_PHY_MOD_TYPE modType; /* Modulation scheme */ DRV_PLC_PHY_MOD_SCHEME modScheme; /* DT field coming in header */ DRV_PLC_PHY_DEL_TYPE delimiterType; /* MAC CRC 1: OK; 0: BAD; 0xFE: Timeout Error; 0xFF: CRC capability disabled (PLC_ID_CRC_TX_RX_CAPABILITY) */ uint8_t crcOk; /* Test data information */ uint16_t agcFine; /* Test data information */ uint32_t agcFactor; /* Test data information */ int16_t agcOffsetMeas; /* Test data information */ uint8_t agcActive; /* Test data information */ uint8_t agcPgaValue; /* Test data information */ int16_t snrFch; /* Test data information */ int16_t snrPay; /* Number of corrupted carriers */ uint16_t payloadCorruptedCarriers; /* Number of noised symbols */ uint16_t payloadNoisedSymbols; /* SNR of the worst carrier */ uint8_t payloadSnrWorstCarrier; /* SNR of the worst symbol */ uint8_t payloadSnrWorstSymbol; /* SNR of impulsive noise */ uint8_t payloadSnrImpulsive; /* SNR of Narrowband noise */ uint8_t payloadSnrBand; /* Background SNR */ uint8_t payloadSnrBackground; /* Link Quality Indicator */ uint8_t lqi; /* Reception Tone Map */ uint8_t toneMap[TONE_MAP_SIZE_MAX]; /* SNR per carrier */ uint8_t carrierSnr[PROTOCOL_CARRIERS_MAX]; } DRV_PLC_PHY_RECEPTION_OBJ; ",
							" Summary Contains information related to a received message ",
							" Description This structure contains necessary information of a received frame such as quality modulation ",
							" Remarks None ",
							" DRV_PLC_PHY_PIB_OBJ Struct ",
							" C typedef struct { /* Pointer to PIB data */ uint8_t *pData; /* PLC Information base identification */ DRV_PLC_PHY_ID id; /* Length in bytes of the data information */ uint16_t length; } DRV_PLC_PHY_PIB_OBJ; ",
							" Summary Contains fields used in Information Base access ",
							" Description This structure contains the objects needed to access the PLC PHY Information Base (PIB) ",
							" Remarks None ",
							" PRIME Data types and constants PRIME Data types and constants ",
							" DRV_PLC_PHY_ID Enum ",
							" C typedef enum { PLC_ID_HOST_DESCRIPTION_ID = 0x0100 PLC_ID_HOST_MODEL_ID = 0x010A PLC_ID_HOST_PHY_ID = 0x010C PLC_ID_HOST_PRODUCT_ID = 0x0110 PLC_ID_HOST_VERSION_ID = 0x0112 PLC_ID_HOST_BAND_ID = 0x0116 PLC_ID_TIME_REF_ID = 0x0200 PLC_ID_PRODID = 0x4000 PLC_ID_MODEL PLC_ID_VERSION_STR PLC_ID_VERSION_NUM PLC_ID_CFG_AUTODETECT_IMPEDANCE PLC_ID_CFG_IMPEDANCE PLC_ID_ZC_TIME PLC_ID_RX_PAY_SYMBOLS PLC_ID_TX_PAY_SYMBOLS PLC_ID_RSV0 PLC_ID_MAX_RMS_TABLE_HI PLC_ID_MAX_RMS_TABLE_VLO PLC_ID_THRESHOLDS_TABLE_HI PLC_ID_THRESHOLDS_TABLE_LO PLC_ID_THRESHOLDS_TABLE_VLO PLC_ID_PREDIST_COEF_TABLE_HI PLC_ID_PREDIST_COEF_TABLE_LO PLC_ID_PREDIST_COEF_TABLE_VLO PLC_ID_GAIN_TABLE_HI PLC_ID_GAIN_TABLE_LO PLC_ID_GAIN_TABLE_VLO PLC_ID_DACC_TABLE_CFG PLC_ID_CHANNEL_CFG PLC_ID_NUM_TX_LEVELS PLC_ID_CORRECTED_RMS_CALC PLC_ID_CURRENT_GAIN PLC_ID_ZC_CONF_INV PLC_ID_ZC_CONF_FREQ PLC_ID_ZC_CONF_DELAY PLC_ID_SIGNAL_CAPTURE_START PLC_ID_SIGNAL_CAPTURE_STATUS PLC_ID_SIGNAL_CAPTURE_FRAGMENT PLC_ID_SIGNAL_CAPTURE_DATA PLC_ID_ENABLE_AUTO_NOISE_CAPTURE PLC_ID_TIME_BETWEEN_NOISE_CAPTURES PLC_ID_DELAY_NOISE_CAPTURE_AFTER_RX PLC_ID_RRC_NOTCH_ACTIVE PLC_ID_RRC_NOTCH_INDEX PLC_ID_NOISE_PEAK_POWER PLC_ID_RRC_NOTCH_AUTODETECT PLC_ID_RRC_NOTCH_THR_ON PLC_ID_RRC_NOTCH_THR_OFF PLC_ID_TX_TOTAL PLC_ID_TX_TOTAL_BYTES PLC_ID_TX_TOTAL_ERRORS PLC_ID_TX_BAD_BUSY_TX PLC_ID_TX_BAD_BUSY_CHANNEL PLC_ID_TX_BAD_LEN PLC_ID_TX_BAD_FORMAT PLC_ID_TX_TIMEOUT PLC_ID_RX_TOTAL PLC_ID_RX_TOTAL_BYTES PLC_ID_RX_EXCEPTIONS PLC_ID_RX_BAD_LEN PLC_ID_RX_BAD_CRC_FCH PLC_ID_RX_FALSE_POSITIVE PLC_ID_RX_BAD_FORMAT PLC_ID_NOISE_PER_CARRIER PLC_ID_PPM_CALIB_ON PLC_ID_ZC_PERIOD PLC_ID_SYNC_THRESHOLDS PLC_ID_NUM_CHANNELS PLC_ID_MAX_NUM_CHANNELS PLC_ID_PREDIST_COEF_TABLE_HI_2 PLC_ID_PREDIST_COEF_TABLE_LO_2 PLC_ID_PREDIST_COEF_TABLE_VLO_2 PLC_ID_NOISE_PER_CARRIER_2 PLC_ID_RESET_STATS PLC_ID_IC_DRIVER_CFG PLC_ID_RX_CHN_EST_REAL PLC_ID_RX_CHN_EST_IMAG PLC_ID_RX_CHN_EST_REAL_2 PLC_ID_RX_CHN_EST_IMAG_2 PLC_ID_TX_DISABLE PLC_ID_TX_HIGH_TEMP_120 PLC_ID_TX_CANCELLED PLC_ID_RX_CD_INFO PLC_ID_SFO_ESTIMATION_LAST_RX PLC_ID_END_ID } DRV_PLC_PHY_ID; ",
							" Summary List of PRIME PLC PHY IBs ",
							" Description This Enum contains every accessible objet in PRIME PLC PHY Information Base A detailed description of these objects is available in PRIME DRV_PLC_PHY_IDs  ",
							" DRV_PLC_PHY_IDs ",
							" PLC_ID_HOST_DESCRIPTION_ID (0x0100) Description: Name of MCU in string format where PL360 Host Controller is running Access: Read-only Value Range: 10 bytes Default Value: \"SAME70\" or \"PIC32CX\" ",
							" PLC_ID_HOST_MODEL_ID (0x010A) Description: Model identification number of the PL360 Host Controller Access: Read-only Value Range: 2 bytes Default Value: 0x0002 ",
							" PLC_ID_HOST_PHY_ID (0x010C) Description: Physical identification number of the PL360 Host Controller It is composed of PLC_ID_HOST_VERSION_ID (0x0112) + PLC_ID_HOST_BAND_ID (0x0116) Access: Read-only Value Range: 4 bytes Default Value: 0x36000003 ",
							" PLC_ID_HOST_PRODUCT_ID (0x0110) Description: Product identification number of the PL360 Host Controller Access: Read-only Value Range: 2 bytes Default Value: 0x3600 ",
							" PLC_ID_HOST_VERSION_ID (0x0112) Description: Version number of the PL360 Host Controller Access: Read-only Value Range: 4 bytes Default Value: 0x36000300 ",
							" PLC_ID_HOST_BAND_ID (0x0116) Description: Workband identification number of the PL360 Host Controller Access: Read-only Value Range: 1 byte Default Value: 3 ",
							" PLC_ID_TIME_REF_ID (0x0200) Description: Time reference in microseconds from the last reset of the PL360 device Access: Read-only Value Range: 4 bytes Default Value: Not applicable ",
							" PLC_ID_PRODID (0x4000) Description: Product Identifier of firmware embedded in PL360 device Access: Read-only Value Range: 8 bytes Default Value: \"ATPL360B\" ",
							" PLC_ID_MODEL (0x4001) Description: Model Identifier of firmware embedded in PL360 device Access: Read-only Value Range: 2 bytes Default Value: 0x3601 ",
							" PLC_ID_VERSION_STR (0x4002) Description: Version number of PL360 PHY embedded firmware in string format The format is \"AA BB CC DD\" where: AA: Corresponds to device model (\"36\") BB: Corresponds to PRIME band CC: Major version number DD: Minor version number Access: Read-only Value Range: 11 bytes Example Value: \"36 05 05 04\" ",
							" PLC_ID_VERSION_NUM (0x4003) Description: Version number of PL360 PHY embedded firmware in hexadecimal format The format is 0xAABBCCDD where: AA: Corresponds to device model (0x36) BB: Corresponds to PRIME band CC: Major version number DD: Minor version number Access: Read-only Value Range: 4 bytes Example Value: 0x36050504 ",
							" PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x4004) Description: Auto-Detect Impedance Mode Transmission Automatic Gain Control (Tx AGC) and Automatic Transmission Mode Control (ATMC) can be enabled/disabled There are 3 available modes: OFF : Tx AGC disabled ATMC disabled ON : Tx AGC enabled ATMC enabled AGC : Tx AGC enabled ATMC disabled Access: Read-write Value Range: 1 byte  Default Value: 1 ",
							" PLC_ID_CFG_IMPEDANCE (0x4005) Description: Transmission Mode (HIGH LOW VERY_LOW) It is automatically updated if ATMC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x4004)) Access: Read-write Value Range: 1 byte  Default Value: 0 ",
							" PLC_ID_ZC_TIME (0x406) Description: Gets last deteced Zero-Crossing value in microseconds Access: Read-only Value Range: 4 bytes Default value: 0 ",
							" PLC_ID_RX_PAY_SYMBOLS (0x4007) Description: Number of payload symbols in last received message Access: Read-only Value Range: 2 bytes  Default Value: 0 ",
							" PLC_ID_TX_PAY_SYMBOLS (0x4008) Description: Number of payload symbols in the last requested transmission Access: Read-only Value Range: 2 bytes  Default Value: 0 ",
							" PLC_ID_MAX_RMS_TABLE_HI (0x400A) Description: Target value of RMS_CALC in HIGH Tx Mode (see PLC_ID_CFG_IMPEDANCE (0x4005)) RMS_CALC will tend to this value by automatically adjusting the gain after every transmission (see PLC_ID_CURRENT_GAIN (0x4019)) These parameters are only used if Tx AGC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x4004)) Access: Read-write Value Range: 32 bytes Byte 0-3 Byte 4-7 Byte 8-11 Byte 12-15 Byte 16-19 Byte 20-24 Byte 25-27 Byte 28-31 RMS_HI_0 RMS_HI_1 RMS_HI_2 RMS_HI_3 RMS_HI_4 RMS_HI_5 RMS_HI_6 RMS_HI_7 where RMS_HI_x: Target value of RMS_CALC in mode of transmission HIGH for the attenuation level x (attenuation levels in 1dB steps) Default Value: PRIME MODE RMS_HI_0 RMS_HI_1 RMS_HI_2 RMS_HI_3 RMS_HI_4 RMS_HI_5 RMS_HI_6 RMS_HI_7 Single Channel Only 1725 1522 1349 1202 1071 957 855 764 Single/Double Channel 1223 1090 971 866 772 688 614 547 ",
							" PLC_ID_MAX_RMS_TABLE_VLO (0x400B) Description: Target value of RMS_CALC in VERY_LOW Tx Mode (see PLC_ID_CFG_IMPEDANCE (0x4005)) RMS_CALC will tend to this value by automatically adjusting the gain after every transmission (see PLC_ID_CURRENT_GAIN (0x4019)) These parameters are only used if Tx AGC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x4004)) Access: Read-write Value Range: 32 bytes Byte 0-3 Byte 4-7 Byte 8-11 Byte 12-15 Byte 16-19 Byte 20-24 Byte 25-27 Byte 28-31 RMS_VLO_0 RMS_VLO_1 RMS_VLO_2 RMS_VLO_3 RMS_VLO_4 RMS_VLO_5 RMS_VLO_6 RMS_VLO_7 where: RMS_HI_x: Target value of RMS_CALC in mode of transmission VERY_LOW for the attenuation level x (attenuation levels in 1dB steps) Default Value: PRIME MODE RMS_VLO_0 RMS_VLO_1 RMS_VLO_2 RMS_VLO_3 RMS_VLO_4 RMS_VLO_5 RMS_VLO_6 RMS_VLO_7 Single Channel Only 4874 4427 3986 3555 3157 2795 2470 2184 Single/Double Channel 3002 2674 2355 2065 1811 1587 1397 1235 ",
							" PLC_ID_THRESHOLDS_TABLE_HI (0x400C) Description: Table of thresholds to automatically update Tx Mode (see PLC_ID_CFG_IMPEDANCE (0x4005)) from HIGH mode These parameters are only used if ATMC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x4004)) Corrected RMS_CALC (see PLC_ID_CORRECTED_RMS_CALC (0x4018)) is compared with these thresholds after every transmission to select Tx Mode for next transmission The decision is taken following the steps shown below: If corrected RMS_CALC is below TH_HI_VLO_x Tx Mode will be updated to VERY_LOW mode Else if corrected RMS_CALC is below TH_HI_LO_x Tx Mode will be updated to LOW mode Else Tx Mode will remain in HIGH mode where: TH_HI_VLO_x: Threshold to change from HIGH to VERY_LOW mode for Tx attenuation level x (1 dB steps) TH_HI_LO_x: Threshold to change from HIGH to LOW mode for Tx attenuation level x (1 dB steps) Access: Read-write Value Range: 64 bytes Byte 0-3 Byte 4-7 Byte 8-11 Byte 12-15 Byte 16-19 Byte 20-24 Byte 25-27 Byte 28-31 TH_HI_LO_0 TH_HI_LO_1 TH_HI_LO_2 TH_HI_LO_3 TH_HI_LO_4 TH_HI_LO_5 TH_HI_LO_6 TH_HI_LO_7 Byte 32-35 Byte 36-39 Byte 40-43 Byte 44-47 Byte 48-51 Byte 52-55 Byte 56-59 Byte 60-63 TH_HI_VLO_0 TH_HI_VLO_1 TH_HI_VLO_2 TH_HI_VLO_3 TH_HI_VLO_4 TH_HI_VLO_5 TH_HI_VLO_6 TH_HI_VLO_7 Default Value: PRIME MODE TH_HI_LO_0 TH_HI_LO_1 TH_HI_LO_2 TH_HI_LO_3 TH_HI_LO_4 TH_HI_LO_5 TH_HI_LO_6 TH_HI_LO_7 Single Channel Only 0 0 0 0 0 0 0 0 Single/Double Channel 0 0 0 0 0 0 0 0 PRIME MODE TH_HI_VLO_0 TH_HI_VLO_1 TH_HI_VLO_2 TH_HI_VLO_3 TH_HI_VLO_4 TH_HI_VLO_5 TH_HI_VLO_6 TH_HI_VLO_7 Single Channel Only 1467 1292 1145 1019 910 811 725 648 Single/Double Channel 1038 924 822 731 652 582 518 462 ",
							" PLC_ID_THRESHOLDS_TABLE_LO (0x400D) Description: Table of thresholds to automatically update Tx Mode (see PLC_ID_CFG_IMPEDANCE (0x4005)) from LOW mode These parameters are only used if ATMC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x4004)) Corrected RMS_CALC (see PLC_ID_CORRECTED_RMS_CALC (0x4018)) is compared with these thresholds after every transmission to select Tx Mode for next transmission The decision is taken following the steps shown below: If corrected RMS_CALC is below TH_LO_VLO_x Tx Mode will be updated to VERY_LOW mode Else if corrected RMS_CALC is above TH_LO_HI_x Tx Mode will be updated to HIGH mode Else Tx Mode will remain in LOW mode where: TH_LO_VLO_x: Threshold to change from LOW to VERY_LOW mode for Tx attenuation level x (1 dB steps) TH_LO_HI_x: Threshold to change from LOW to HIGH mode for Tx attenuation level x (1 dB steps) Access: Read-write Value Range: 64 bytes Byte 0-3 Byte 4-7 Byte 8-11 Byte 12-15 Byte 16-19 Byte 20-24 Byte 25-27 Byte 28-31 TH_LO_HI_0 TH_LO_HI_1 TH_LO_HI_2 TH_LO_HI_3 TH_LO_HI_4 TH_LO_HI_5 TH_LO_HI_6 TH_LO_HI_7 Byte 32-35 Byte 36-39 Byte 40-43 Byte 44-47 Byte 48-51 Byte 52-55 Byte 56-59 Byte 60-63 TH_LO_VLO_0 TH_LO_VLO_1 TH_LO_VLO_2 TH_LO_VLO_3 TH_LO_VLO_4 TH_LO_VLO_5 TH_LO_VLO_6 TH_LO_VLO_7 Default Value: PRIME MODE TH_LO_HI_0 TH_LO_HI_1 TH_LO_HI_2 TH_LO_HI_3 TH_LO_HI_4 TH_LO_HI_5 TH_LO_HI_6 TH_LO_HI_7 Single Channel Only 0 0 0 0 0 0 0 0 Single/Double Channel 0 0 0 0 0 0 0 0 PRIME MODE TH_LO_VLO_0 TH_LO_VLO_1 TH_LO_VLO_2 TH_LO_VLO_3 TH_LO_VLO_4 TH_LO_VLO_5 TH_LO_VLO_6 TH_LO_VLO_7 Single Channel Only 0 0 0 0 0 0 0 0 Single/Double Channel 0 0 0 0 0 0 0 0 ",
							" PLC_ID_THRESHOLDS_TABLE_VLO (0x400E) Description: Table of thresholds to automatically update Tx Mode (see PLC_ID_CFG_IMPEDANCE (0x4005)) from VERY_LOW mode These parameters are only used if ATMC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x4004)) Corrected RMS_CALC (see PLC_ID_CORRECTED_RMS_CALC (0x4018)) is compared with these thresholds after every transmission to select Tx Mode for next transmission The decision is taken following the steps shown below: If corrected RMS_CALC is below TH_VLO_VLO_x Tx Mode will remain in VERY_LOW mode Else if corrected RMS_CALC is above TH_VLO_HI_x Tx Mode will be updated to HIGH mode Else Tx Mode will be updated to LOW mode where: TH_VLO_VLO_x: Threshold to remain Tx mode in VERY_LOW mode for Tx attenuation level x (1 dB steps) TH_VLO_HI_x: Threshold to change from VERY_LOW to HIGH mode for Tx attenuation level x (1 dB steps) Access: Read-write Value Range: 64 bytes Byte 0-3 Byte 4-7 Byte 8-11 Byte 12-15 Byte 16-19 Byte 20-24 Byte 25-27 Byte 28-31 TH_VLO_HI_0 TH_VLO_HI_1 TH_VLO_HI_2 TH_VLO_HI_3 TH_VLO_HI_4 TH_VLO_HI_5 TH_VLO_HI_6 TH_VLO_HI_7 Byte 32-35 Byte 36-39 Byte 40-43 Byte 44-47 Byte 48-51 Byte 52-55 Byte 56-59 Byte 60-63 TH_VLO_VLO_0 TH_VLO_VLO_1 TH_VLO_VLO_2 TH_VLO_VLO_3 TH_VLO_VLO_4 TH_VLO_VLO_5 TH_VLO_VLO_6 TH_VLO_VLO_7 Default Value: PRIME MODE TH_VLO_HI_0 TH_VLO_HI_1 TH_VLO_HI_2 TH_VLO_HI_3 TH_VLO_HI_4 TH_VLO_HI_5 TH_VLO_HI_6 TH_VLO_HI_7 Single Channel Only 0 0 0 0 0 0 0 0 Single/Double Channel 0 0 0 0 0 0 0 0 PRIME MODE TH_VLO_VLO_0 TH_VLO_VLO_1 TH_VLO_VLO_2 TH_VLO_VLO_3 TH_VLO_VLO_4 TH_VLO_VLO_5 TH_VLO_VLO_6 TH_VLO_VLO_7 Single Channel Only 8479 7515 6665 5874 5192 4576 4030 3557 Single/Double Channel 100000 100000 100000 100000 100000 100000 100000 100000 ",
							" PLC_ID_PREDIST_COEF_TABLE_HI (0x400F) Description: Equalization Coefficients table in HIGH Tx mode There is one coefficient for each carrier in the used band The format of each coefficient is uQ0 15 (2 byteswhere MSB must be 0) PL360 firmware compensates the total gain internally so modifying the digital gain (see PLC_ID_GAIN_TABLE_HI (0x402D)) is not needed when equalization is modified If Double Channel is used (PLC_ID_NUM_CHANNELS (0x403D)) another table is needed for the second channel (PLC_ID_PREDIST_COEF_TABLE_HI_2 (0x403F)) Access: Read-write Value Range: 194 bytes Default Value: Single Channel only: {0x756E 0x7396 0x730A 0x72EB 0x72B2 0x7433 0x755E 0x75D7 0x769E 0x76A4 0x77C3 0x7851 0x7864 0x78A0 0x78BA 0x7918 0x79B6 0x79E9 0x7ACC 0x7B06 0x7B30 0x7B27 0x7C1E 0x7B96 0x7A76 0x7B12 0x7AFD 0x7C40 0x7C5E 0x7B48 0x7B8A 0x7C64 0x7C42 0x7BCD 0x7AFD 0x7A5F 0x7A03 0x7A9D 0x7A1A 0x7A4A 0x79FC 0x7984 0x7A0D 0x79CC 0x792E 0x780D 0x7676 0x75E4 0x747A 0x7251 0x707E 0x6E96 0x6E30 0x6D44 0x6DBD 0x6C9A 0x6C3C 0x6CF8 0x6CA4 0x6CDF 0x6C59 0x6B2C 0x6CB9 0x6C1F 0x6B6D 0x6BF5 0x6AF0 0x6A55 0x6955 0x674F 0x6841 0x685D 0x670F 0x6904 0x6967 0x6B01 0x6C31 0x6C2A 0x6D82 0x6F58 0x6E62 0x6F18 0x6EE7 0x7069 0x717B 0x7120 0x7170 0x72FB 0x7491 0x75B3 0x75A2 0x7664 0x784A 0x7A52 0x7B51 0x7D5A 0x7FFF} Single/Double Channel: {0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF} ",
							" PLC_ID_PREDIST_COEF_TABLE_LO (0x4010) Description: Equalization Coefficients table in LOW Tx mode There is one coefficient for each carrier in the used band The format of each coefficient is uQ0 15 (2 byteswhere MSB must be 0) PL360 firmware compensates the total gain internally so modifying the gain it is not needed (see PLC_ID_GAIN_TABLE_LO (0x402E)) when equalization is modified If Double Channel is used (PLC_ID_NUM_CHANNELS (0x403D)) another table is needed for the second channel (PLC_ID_PREDIST_COEF_TABLE_HI_2 (0x403F)) Access: Read-write Value Range: 194 bytes Default Value: Single Channel only: {0x7FFF 0x7F2B 0x7E38 0x7CD3 0x7B38 0x7972 0x77D6 0x7654 0x74AE 0x7288 0x70C0 0x6E9A 0x6D24 0x6B80 0x6A2F 0x6852 0x674E 0x65DA 0x652E 0x637E 0x6292 0x6142 0x60CC 0x5FF8 0x5F6D 0x5EC2 0x5E6F 0x5E55 0x5E43 0x5E02 0x5E5B 0x5EB3 0x5F4A 0x5FD7 0x604C 0x60FC 0x61F3 0x6297 0x63A9 0x643D 0x654A 0x6634 0x675C 0x6824 0x6910 0x69A4 0x6A73 0x6B6F 0x6C15 0x6CCD 0x6D64 0x6E4B 0x6ED3 0x6F44 0x6F85 0x70A1 0x70AF 0x71B2 0x7149 0x71F3 0x7203 0x7279 0x71FB 0x72B4 0x7281 0x72A4 0x7262 0x72BD 0x7295 0x72CC 0x729E 0x7288 0x7244 0x7279 0x726C 0x7230 0x71B9 0x70D8 0x7045 0x7052 0x6F8D 0x6F3D 0x6EB0 0x6E6A 0x6E76 0x6E1C 0x6D7A 0x6D84 0x6D50 0x6D45 0x6CF2 0x6CA9 0x6C92 0x6CBA 0x6C69 0x6C27 0x6C02} Single/Double Channel: {0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF} ",
							" PLC_ID_PREDIST_COEF_TABLE_VLO (0x4011) Description: Equalization Coefficients table in VERY_LOW Tx mode There is one coefficient for each carrier in the used band The format of each coefficient is uQ0 15 (2 byteswhere MSB must be 0) PL360 firmware compensates the total gain internally so modifying the gain is not needed (see PLC_ID_GAIN_TABLE_VLO (0x402F)) when equalization is modified If Double Channel is used (PLC_ID_NUM_CHANNELS (0x403D)) another table is needed for the second channel (PLC_ID_PREDIST_COEF_TABLE_HI_2 (0x403F)) Access: Read-write Value Range: 194 bytes Default Value: Single Channel only: {0x7FFF 0x7F2B 0x7E38 0x7CD3 0x7B38 0x7972 0x77D6 0x7654 0x74AE 0x7288 0x70C0 0x6E9A 0x6D24 0x6B80 0x6A2F 0x6852 0x674E 0x65DA 0x652E 0x637E 0x6292 0x6142 0x60CC 0x5FF8 0x5F6D 0x5EC2 0x5E6F 0x5E55 0x5E43 0x5E02 0x5E5B 0x5EB3 0x5F4A 0x5FD7 0x604C 0x60FC 0x61F3 0x6297 0x63A9 0x643D 0x654A 0x6634 0x675C 0x6824 0x6910 0x69A4 0x6A73 0x6B6F 0x6C15 0x6CCD 0x6D64 0x6E4B 0x6ED3 0x6F44 0x6F85 0x70A1 0x70AF 0x71B2 0x7149 0x71F3 0x7203 0x7279 0x71FB 0x72B4 0x7281 0x72A4 0x7262 0x72BD 0x7295 0x72CC 0x729E 0x7288 0x7244 0x7279 0x726C 0x7230 0x71B9 0x70D8 0x7045 0x7052 0x6F8D 0x6F3D 0x6EB0 0x6E6A 0x6E76 0x6E1C 0x6D7A 0x6D84 0x6D50 0x6D45 0x6CF2 0x6CA9 0x6C92 0x6CBA 0x6C69 0x6C27 0x6C02} Single/Double Channel: {0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF} ",
							" PLC_ID_GAIN_TABLE_HI (0x4012) Description: Table of gain values for HIGH Tx Mode Access: Read-write Value Range: 6 bytes Byte 0-1 Byte 2-3 Byte 4-5 GAIN_HI_INI GAIN_HI_MIN GAIN_HI_MAX where: GAIN_HI_INI: Initial gain value in HIGH Tx Mode The minimum value is GAIN_HI_MIN GAIN_HI_MIN: Minimum gain value in HIGH Tx Mode The minimum value is 1 GAIN_HI_MAX: Maximum gain value in HIGH Tx Mode The minimum value is GAIN_HI_INI GAIN_HI_MIN and GAIN_HI_MAX are only used if Tx AGC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x4004)) Default Value: PRIME MODE GAIN_HI_INI GAIN_HI_MIN GAIN_HI_MAX Single Channel Only 81 40 128 Single/Double Channel 120 60 256 ",
							" PLC_ID_GAIN_TABLE_LO (0x4013) Description: Gain value in LOW Tx Mode Access: Read-write Value Range: 2 bytes The minimum value is 1 Default Value: 256 ",
							" PLC_ID_GAIN_TABLE_VLO (0x4014) Description: Table of gain values for VERY_LOW Tx Mode Access: Read-write Value Range: 6 bytes Byte 0-1 Byte 2-3 Byte 4-5 GAIN_VLO_INI GAIN_VLO_MIN GAIN_VLO_MAX where: GAIN_VLO_INI: Initial gain value in VERY_LOW Tx Mode The minimum value is GAIN_VLO_MIN GAIN_VLO_MIN: Minimum gain value in VERY_LOW Tx Mode The minimum value is 1 GAIN_VLO_MAX: Maximum gain value in VERY_LOW Tx Mode The minimum value is GAIN_VLO_INI GAIN_VLO_MIN and GAIN_VLO_MAX are only used if Tx AGC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x4004)) Default Value: PRIME MODE GAIN_VLO_INI GAIN_VLO_MIN GAIN_VLO_MAX Single Channel Only 256 128 281 Single/Double Channel 256 128 256 ",
							" PLC_ID_DACC_TABLE_CFG (0x4015) Description: Configuration values of DACC peripheral according to hardware configuration Access: Read-write Value Range: 68 bytes Default Value: Single Channel only: {0x00000000 0x00002120 0x0000073F 0x00003F3F 0x00000333 0x00000000 0x546000FF 0x1A1A1A1A 0x00002020 0x00000044 0x0FD20005 0x00000355 0x0F000000 0x001020F0 0x00000355 0x0F000000 0x001020FF} Single/Double Channel: {0x00000000 0x10102120 0x033F073F 0x3F3F3F3F 0x00000FFF 0x00000000 0xFFFF00FF 0x17171717 0x10101010 0x00001111 0x04380006 0x000003AA 0xF0000000 0x001020F0 0x00000355 0x0F000000 0x001020FF} ",
							" PLC_ID_CHANNEL_CFG (0x4016) Description: PRIME channel used for transmission and reception in the PL360 device Access: Read-write Value Range: 1 byte  Default Value: 1 (Single Channel only) or 3 (Single/Double Channel) depending on the PL360 PRIME binary used (see PLC_ID_VERSION_NUM (0x4003)) CAUTION: If the channel is modified the Transmission Coupling parameters must be modified too (default values correspond to the default channel) ",
							" PLC_ID_NUM_TX_LEVELS (0x4017) Description: Number of Tx attenuation levels (1 dB steps) for normal transmission behavior When attenuation field (see DRV_PLC_PHY_TRANSMISSION_OBJ ) is higher than or equal to the number of Tx attenuation levels Tx Mode is internally forced by the PL360 device to LOW mode Access: Read-write Value Range: 1 byte  Default Value: 8 ",
							" PLC_ID_CORRECTED_RMS_CALC (0x4018) Description: RMS_CALC value obtained in the last transmitted message compensated with gain applied by Tx AGC algorithm (see PLC_ID_CURRENT_GAIN (0x4019)) This is the value which is actually compared with thresholds (PLC_ID_THRESHOLDS_TABLE_VLO (0x400E) PLC_ID_THRESHOLDS_TABLE_HI (0x400C)) to automatically update Tx Mode Access: Read-only Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_CURRENT_GAIN (0x4019) Description: Transmission Gain which will be used in the next transmitted message It can vary after every transmission if Tx AGC is enabled (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x4004)) Maximum and minimum Gain values can be set in PLC_ID_GAIN_TABLE_HI (0x4012) and PLC_ID_GAIN_TABLE_VLO (0x4014) Access: Read-only Value Range: 2 bytes Default Value: 81 (Single Channel only) or 120 (Single/Double Channel) depending on the PL360 PRIME binary used (see PLC_ID_VERSION_NUM (0x4003)) ",
							" PLC_ID_ZC_CONF_INV (0x401A) Description: Polarity of the pulse generated by the external Zero-Crossing detection circuit For further information refer to Zero-Crossing Configuration Access: Read-write Value Range: 1 byte  Default Value: 1 ",
							" PLC_ID_ZC_CONF_FREQ (0x401B) Description: Initial frequency in Hz for the mains Zero-Crossing detection algorithm For further information refer to Zero-Crossing Configuration Access: Read-write Value Range: 1 byte  Default Value: 50 ",
							" PLC_ID_ZC_CONF_DELAY (0x401C) Description: Time Delay in microseconds of the external mains Zero-Crossing Detection circuit For further information refer to Zero-Crossing Configuration Access: Read-write Value Range: 2 bytes Default Value: -350 ",
							" PLC_ID_SIGNAL_CAPTURE_START (0x401D) Description: Trigger to start signal capture process Access: Write-only Value Range: 9 bytes Byte 0 Byte 1 - Byte 2 - Byte 3 - Byte 4 Byte 5 - Byte 6 - Byte 7 - Byte 8 MODE START TIME DURATION where MODE is set according to the following table: bit 7 bit 6 bit 5 bit 4 bit 3 - bit 2 - bit 1 - bit 0 - Time Mode Band Mode Signal Mode Channel Mode: Time Mode: 0: Start time in absolute mode 1: Start time in relative mode Band Mode: 0: Channel mode Low Pass Equivalent signal at 62 5 kHz sampling rate Each sample is composed of 6 bytes (2 bytes real part 2 bytes imaginary part and 2 bytes AGC value) 1: Full-band mode Signal at 1 MHz sampling rate AGC is fixed Each sample is composed of 1 byte (only real part) using μ-law compression algorithm Signal Mode (only used for Full-band mode): 0: Low level signals up to +/- 100 mV amplitude 1: High level signals up to +/- 13V amplitude Channel (only used for Channel mode): Select channel to capture Start Time: Instant when signal capture has to start referred to 1 μs PHY counter (absolute or relative value depending on TimeMode) Duration: Signal capture duration in μs The maximum duration depends on the selected Band Mode and the PL360 PRIME binary used (see 10 3 4 12 ATPL360_REG_VERSION_NUM (0x4003)): Single Channel only: 97008 (Channel mode); 36378 (Full-band mode) Single/Double Channel: 70176 (Channel mode); 26316 (Full-band mode) Default Value: N/A ",
							" PLC_ID_SIGNAL_CAPTURE_STATUS (0x401E) Description: Status of signal capture process Access: Read-only Value Range: 3 bytes Byte 0 Byte 1 Byte 2 Fragment Count Capture Status where: Fragment Count: Number of 129-byte fragments to read the complete captured signal (only valid when capture is ready) Capture Status: The status of the signal capture process Default Value: N/A ",
							" PLC_ID_SIGNAL_CAPTURE_FRAGMENT (0x401F) Description: Signal fragment index to read It must be set before reading PLC_ID_SIGNAL_CAPTURE_DATA (0x4020) Access: Read-write Value Range: 2 bytes Default Value: 0 ",
							" PLC_ID_SIGNAL_CAPTURE_DATA (0x4020) Description: Signal capture data buffer Fragment of captured signal is selected through PLC_ID_SIGNAL_CAPTURE_FRAGMENT (0x401F) Access: Read-only Value Range: 129 bytes Default Value: N/A ",
							" PLC_ID_ENABLE_AUTO_NOISE_CAPTURE (0x4021) Description: Flag to indicate if automatic noise analyzer is enabled in the reception chain If Auto-mode is enabled notch filter parameters (PLC_ID_RRC_NOTCH_ACTIVE (0x4024) PLC_ID_RRC_NOTCH_INDEX (0x4025)) cannot be modified by the user See PLC_ID_TIME_BETWEEN_NOISE_CAPTURES (0x4022) PLC_ID_RRC_NOTCH_THR_ON (0x4028) PLC_ID_RRC_NOTCH_THR_OFF (0x4029) to configure parameters related to the Auto-mode Access: Read-write Value Range: 1 byte  Default Value: 1 ",
							" PLC_ID_TIME_BETWEEN_NOISE_CAPTURES (0x4022) Description: Time in milliseconds between noise captures Access: Read-write Value Range: 4 bytes  Default Value: 1000 (1 second) CAUTION: It is recommended that the default value of this parameter be kept If reduced the power consumption could increase The default value is optimum for power consumption and performance of noise detection ",
							" PLC_ID_DELAY_NOISE_CAPTURE_AFTER_RX (0x4023) Description: Time in microseconds to start a new noise capture after PDU reception/transmission Access: Read-write Value Range: 4 bytes  Default Value: 3000 (3 milliseconds) ",
							" PLC_ID_RRC_NOTCH_ACTIVE (0x4024) Description: Number of notched frequencies with RRC notch filter Up to 5 notched frequencies are allowed Access: Depends on noise analyzer mode PLC_ID_ENABLE_AUTO_NOISE_CAPTURE (0x4021) value: Auto-mode (1): Read-only Manual-mode (0): Read-write Value Range: 1 byte  Default Value: 0 (No notched frequencies) ",
							" PLC_ID_RRC_NOTCH_INDEX (0x4025) Description: Array of RRC notch filter index values There is one index for each notched frequency The format of each index is sQ8 7 The 9 integer bits (including sign bit) indicate the carrier index for which the notch filter is applied The 7 decimal bits can apply the notch filter to a frequency that is between two consecutive carriers To convert the notch index to frequency (in Hz) the following formulas are applied depending on the number of channels used (PLC_ID_NUM_CHANNELS (0x403D)): Single Channel: F = INDEX * k + 65429 6875 + (Ch - 1) * 54687 5 Double Channel: F = INDEX * k + 92773 4375 + (Ch - 1) * 54687 5 where: k = 1000000 / (2048 * 128) = 3 814697265625 Hz Ch: PRIME channel used (10 3 4 30 ATPL360_REG_CHANNEL_CFG (0x4016)) For example: Single Channel 1 INDEX = -768 (0xFD00): F = -768 * k + 65429 6875 = 62500 Hz Double Channel 3 4 INDEX = 16 (0x0010): F = 16 * k + 92773 4375 + 2 * 54687 5 = 202209 Hz Access: Depends on noise analyzer mode PLC_ID_ENABLE_AUTO_NOISE_CAPTURE (0x4021) value: 1 (Auto-mode): Read-only 0 (Manual-mode): Read-write Value Range: 10 bytes Number of valid 2-byte words depends on the number of notched frequencies (PLC_ID_RRC_NOTCH_ACTIVE (0x4024)) Default Value: 0 ",
							" PLC_ID_NOISE_PEAK_POWER (0x4026) Description: Estimation of noise level in dBµV for the carrier with highest noise power It is actually the maximum value of the PIB described in PLC_ID_NOISE_PER_CARRIER (0x4039) The value is updated only if noise analyzer Auto-mode is enabled (PLC_ID_ENABLE_AUTO_NOISE_CAPTURE (0x4021)) or if noise capture is triggered manually (PLC_ID_RRC_NOTCH_AUTODETECT (0x4027)) Access: Read-only Value Range: 2 bytes Default Value: 0 ",
							" PLC_ID_RRC_NOTCH_AUTODETECT (0x4027) Description: Trigger to start noise analysis If noise analyzer Manual-mode is enabled (see PLC_ID_ENABLE_AUTO_NOISE_CAPTURE (0x4021)) noise capture can be triggered through this PIB by writing 1 Writing 0 has no effect If noise analyzer Auto-mode is enabled writing any value has no effect Access: Write-only Value Range: 1 byte Default Value: 0 ",
							" PLC_ID_RRC_NOTCH_THR_ON (0x4028) Description: Activation threshold for narrow/broad-band noise detection in dBµV with uQ14 2 format For each PRIME channel (PLC_ID_CHANNEL_CFG (0x4016)) there is a specific value (for both read and write) Access: Read-write Value Range: 2 bytes Default Value: Channel 1: 283 (70 75 dBμV) Channel 2: 260 (65 00 dBμV) Channel 3: 241 (60 25 dBμV) Channel 4: 230 (57 50 dBμV) Channel 5: 222 (55 50 dBμV) Channel 6: 213 (53 25 dBμV) Channel 7: 210 (52 50 dBμV) Channel 8: 200 (50 00 dBμV) ",
							" PLC_ID_RRC_NOTCH_THR_OFF (0x4029) Description: Deactivation threshold for narrow band noise in dBµV with uQ14 2 format For each PRIME channel (PLC_ID_CHANNEL_CFG (0x4016)) there is a specific value (for both read and write) Access: Read-write Value Range: 2 bytes Default Value: Channel 1: 267 (66 75 dBμV) Channel 2: 244 (61 00 dBμV) Channel 3: 241 (56 25 dBμV) Channel 4: 225 (53 50 dBμV) Channel 5: 206 (51 50 dBμV) Channel 6: 197 (49 25 dBμV) Channel 7: 194 (48 50 dBμV) Channel 8: 184 (46 00 dBμV) ",
							" PLC_ID_TX_TOTAL (0x402A) Description: Number of successfully transmitted PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_TX_TOTAL_BYTES (0x402B) Description: Number of bytes in successfully transmitted PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_TX_TOTAL_ERRORS (0x402C) Description: Number of unsuccessfully transmitted PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_TX_BAD_BUSY_TX (0x402D) Description: Number of times when the PL360 device received new data to transmit (send_data) and there is already data in the TX chain Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_TX_BAD_BUSY_CHANNEL (0x402E) Description: Number of times when the PL360 device received new data to transmit (send_data) and the PLC channel is busy Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_TX_BAD_LEN (0x402F) Description: Number of times when the PL360 device received new data to transmit (send_data) and the specified length in transmission parameters is invalid Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_TX_BAD_FORMAT (0x4030) Description: Number of times when the PL360 device received new data to transmit (send_data) and the transmission parameters are not valid Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_TX_TIMEOUT (0x4031) Description: Number of times when the PL360 device received new data to transmit (send_data) and it cannot transmit data in the specified time provided by the transmission parameters Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RX_TOTAL (0x4032) Description: Number of successfully received PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RX_TOTAL_BYTES (0x4033) Description: Number of bytes in successfully received PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RX_EXCEPTIONS (0x4034) Description: Number of time-out errors in received PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RX_BAD_LEN (0x4035) Description: Number of errors in FCH length in received PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RX_BAD_CRC_FCH (0x4036) Description: Number of errors in FCH CRC in received PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RX_FALSE_POSITIVE (0x4037) Description: Number of errors in PDU synchronization phase Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_RX_BAD_FORMAT (0x4038) Description: Number of errors in modulation type field included in FCH of received PDUs Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_NOISE_PER_CARRIER (0x4039) Description: Estimation of noise level in dBµV for each carrier in the working band This information is used internally by the PL360 PHY for narrow/broad-band noise detection and notch filter activation The value is updated only if Auto-mode is enabled (PLC_ID_ENABLE_AUTO_NOISE_CAPTURE (0x4021)) or noise capture is triggered through PLC_ID_RRC_NOTCH_AUTODETECT (0x4027) If Double Channel is used (PLC_ID_NUM_CHANNELS (0x403D)) another table is needed for the second channel (PLC_ID_NOISE_PER_CARRIER_2 (0x4042)) Access: Read only Value Range: 97 bytes Default Value: All 0s ",
							" PLC_ID_PPM_CALIB_ON (0x403A) Description: Enable the oscillator clock signal to go out through TXRX1 pad This is useful to measure clock frequency deviation Access: Read-write Value Range: 1 byte  Default Value: 0 ",
							" PLC_ID_ZC_PERIOD (0x403B) Description: Last estimation of the mains Zero-Crossing period in microseconds Access: Read-only Value Range: 4 bytes Default Value: 0 ",
							" PLC_ID_SYNC_XCORR_THRESHOLD (0x403C) Description: Correlation threshold for synchronization (preamble detection) The format is uQ0 16 It represents percentage with respect to the maximum ideal value of correlation (computed internally in PL360) Access: Read-write Value Range: 12 bytes Byte 0-1 Byte 2-3 Byte 4-5 Byte 6-7 Byte 8-9 Byte 10-11 SYNC_TH_A SYNC_TH_B SYNC_2_3_TH_A SYNC_2_3_TH_B SYNC_1_2_TH_A SYNC_1_2_TH_B where: SYNC_TH_A: Threshold for detection of complete TYPE_A preamble Used for frame synchronization SYNC_TH_B: Threshold for detection of complete TYPE_B preamble Used for frame synchronization SYNC_TH_2_3_A: Threshold for detection of 2/3 TYPE_A preamble Used to lock AGC SYNC_TH_2_3_B: Threshold for detection of 2/3 TYPE_B preamble Used to lock AGC SYNC_TH_1_2_A: Threshold for detection of 1/2 TYPE_A preamble Used to activate carrier detect SYNC_TH_1_2_B: Threshold for detection of 1/2 TYPE_B preamble Used to activate carrier detect Default Value: SYNC_TH_A SYNC_TH_B SYNC_2_3_TH_A SYNC_2_3_TH_B SYNC_1_2_TH_A SYNC_1_2_TH_B 11272 10748 12124 11534 16908 16122 CAUTION It is recommended to keep the default value of this parameter in order to maintain expected reception performance ",
							" PLC_ID_NUM_CHANNELS (0x403D) Description: Number of PRIME channels (consecutive) used for transmission and reception in the PL360 device The default value and value range depend on the PL360 PRIME binary used (see PLC_ID_VERSION_NUM (0x4003)) Access: Read-write Value Range: 1 byte  Default Value: 1 (Single Channel only) or 2 (Single/Double Channel) CAUTION If the number of channels is modified the Transmission Coupling parameters must be modified too (default values correspond to the default channel) For further information refer to Transmission Coupling Configuration ",
							" PLC_ID_MAX_NUM_CHANNELS (0x403E) Description: Number of PRIME channels (consecutive) that can be used for transmission and reception in the PL360 device Access: Read-only Value Range: 1 byte Default Value: 1 (Single Channel only) or 2 (Single/Double Channel) depending on the PL360 PRIME binary used (see PLC_ID_VERSION_NUM (0x4003)) ",
							" PLC_ID_PREDIST_COEF_TABLE_HI_2 (0x403F) Description: Equivalent to PLC_ID_PREDIST_COEF_TABLE_HI (0x400F) but for the second channel if Double Channel is used (PLC_ID_NUM_CHANNELS (0x403D)) Access: Read-write Value Range: 194 bytes Default Value: {0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF} ",
							" PLC_ID_PREDIST_COEF_TABLE_LO_2 (0x4040) Description: Equivalent to PLC_ID_PREDIST_COEF_TABLE_LO (0x4010) but for the second channel if Double Channel is used (PLC_ID_NUM_CHANNELS (0x403D)) Access: Read-write Value Range: 194 bytes Default Value: {0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF} ",
							" PLC_ID_PREDIST_COEF_TABLE_VLO_2 (0x4041) Description: Equivalent to PLC_ID_PREDIST_COEF_TABLE_VLO (0x4011) but for the second channel if Double Channel is used (PLC_ID_NUM_CHANNELS (0x403D)) Access: Read-write Value Range: 194 bytes Default Value: {0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF 0x7FFF} ",
							" PLC_ID_NOISE_PER_CARRIER_2 (0x4042) Description: Equivalent to PLC_ID_NOISE_PER_CARRIER (0x4039) but for the second channel if Double Channel is used (PLC_ID_NUM_CHANNELS (0x403D)) Access: Read only Value Range: 97 bytes Default Value: All 0s ",
							" PLC_ID_RESET_STATS (0x4043) Description: Writing any value (1 - 255) causes all PHY statistics (PLC_ID_TX_TOTAL PLC_ID_RX_TOTAL etc ) to be reset to 0 Access: Write-only Value Range: 1 byte Default Value: 0 ",
							" PLC_ID_IC_DRIVER_CFG (0x4044) Description: This parameter configures the Transmission PLC Driver It must be configured according to the PLC device used There are four available modes one for PL360 or PL485 and three for PL460: PL360 : Configured for PL360 or PL485 PL460_MAIN_BRANCH_1F : Configured for PL460 using Main Transmission Branch with a single external filter When transmitting both ASO pins are activated simultaneously for all Tx Modes PL460_MAIN_BRANCH_2F : Configured for PL460 using Main Transmission Branch with two external filters When transmitting ASO0 is activated if HIGH Tx mode and ASO1 is activated if LOW / VERY_LOW Tx mode (see PLC_ID_CFG_AUTODETECT_IMPEDANCE (0x4004)) PL460_AUX_BRANCH : Configured for PL460 using Auxiliary Transmission Branch For further information refer to the PL460 data sheet Access: Read-write Value Range: 1 byte  Default value: 0 ",
							" PLC_ID_RX_CHN_EST_REAL (0x4045) Description: Real part of Channel Estimation of the last received PDU For each carrier in the working band there is one 2-byte signed value The PL360 PHY layer computes the Channel Estimation from the preamble and FCH symbols which is used for the demodulation of payload symbols The value has no unit and the scale does not reflect the real received signal level although the RSSI ( rssi in DRV_PLC_PHY_RECEPTION_OBJ ) could be used to scale the Channel Estimation and obtain the RSSI per carrier in the working band If Double Channel is used (PLC_ID_NUM_CHANNELS (0x403D)) another array is needed for the second channel (PLC_ID_RX_CHN_EST_REAL_2 (0x4047)) Access: Read-only Value Range: 194 bytes Default value: All 0s ",
							" PLC_ID_RX_CHN_EST_IMAG (0x4046) Description: Imaginary part of Channel Estimation of the last received PDU For each carrier in the working band there is one 2-byte signed value See PLC_ID_RX_CHN_EST_REAL (0x4045) for more information If Double Channel is used (PLC_ID_NUM_CHANNELS (0x403D)) another array is needed for the second channel (PLC_ID_RX_CHN_EST_IMAG_2 (0x4048)) Access: Read-only Value Range: 194 bytes Default value: All 0s ",
							" PLC_ID_RX_CHN_EST_REAL_2 (0x4047) Description: Equivalent to PLC_ID_RX_CHN_EST_REAL (0x4045) but for the second channel if Double Channel is used (PLC_ID_NUM_CHANNELS (0x403D)) Access: Read-only Value Range: 194 bytes Default value: All 0s ",
							" PLC_ID_RX_CHN_EST_IMAG_2 (0x4048) Description: Equivalent to PLC_ID_RX_CHN_EST_IMAG (0x4046) but for the second channel if Double Channel is used (PLC_ID_NUM_CHANNELS (0x403D)) Access: Read-only Value Range: 194 bytes Default value: All 0s ",
							" PLC_ID_TX_DISABLE (0x4049) Description: This parameter allows disabling of transmissions If disabled ongoing/programmed transmission (if any) will be aborted and subsequent requests will be denied reporting the transmission result DRV_PLC_PHY_TX_CANCELLED  Access: Read-write Value Range: 1 byte  Default value: 0 ",
							" PLC_ID_TX_HIGH_TEMP_120 (0x404A) Description: Number of unsuccessful transmissions because of high temperature ( 120ºC) error i e with transmission result DRV_PLC_PHY_TX_RESULT_HIGH_TEMP_120 This transmission error is only available in PL460 Access: Read-write Value Range: 4 bytes Default value: 0 ",
							" PLC_ID_TX_CANCELLED (0x404B) Description: Number of canceled transmissions i e with transmission result DRV_PLC_PHY_TX_CANCELLED Transmissions can be canceled by: TX_MODE_CANCEL bit in mode parameter (see DRV_PLC_PHY_TRANSMISSION_OBJ ) PLC_ID_TX_DISABLE (0x4048) Tx Enable pin only available in PL460 Access: Read-write Value Range: 4 bytes Default value: 0 ",
							" PLC_ID_RX_CD_INFO (0x404C) Description: Carrier Detect related information for a PLC frame reception The format is defined by the structure shown below: typedef struct { /* Reception time (message end or header end if message length is not known yet) referred to 1us PHY counter */ uint32_t rx_time_end; /* Current time referred to 1us PHY counter */ uint32_t current_time; /* Correlation peak value */ uint16_t corr_peak_value; /* Average RSSI (Received Signal Strength Indication) in dBuV */ uint8_t rssi_avg; /* Reception state Similar to header from PRIME spec but extra values for preamble */ DRV_PLC_PHY_CD_RX_STATE cd_rx_state; /* Type A Type B or Type BC */ DRV_PLC_PHY_FRAME_TYPE frame_type; } DRV_PLC_PHY_CD_INFO; Access: Read-only Value Range: 13 bytes Default value: N/A ",
							" PLC_ID_SFO_ESTIMATION_LAST_RX (0x404D) Description: Estimation of the double-sided (between transmitter and receiver) clock frequency deviation for the last received PDU The value is signed and the unit is 0 001 ppm To convert to ppm the read value has to be divided by 1000 Access: Read-only Value Range: 4 bytes  Default Value: 0 ",
							" DRV_PLC_PHY_SCH Enum ",
							" C typedef enum { SCHEME_DBPSK = 0 SCHEME_DQPSK = 1 SCHEME_D8PSK = 2 SCHEME_DBPSK_C = 4 SCHEME_DQPSK_C = 5 SCHEME_D8PSK_C = 6 SCHEME_R_DBPSK = 12 SCHEME_R_DQPSK = 13 } DRV_PLC_PHY_SCH; ",
							" Summary PRIME Modulation schemes ",
							" Description This Enum contains every types of modulation schemes supported by PRIME spec ",
							" DRV_PLC_PHY_FRAME_TYPE Enum ",
							" C typedef enum { FRAME_TYPE_A = 0 FRAME_TYPE_B = 2 FRAME_TYPE_BC = 3 } DRV_PLC_PHY_FRAME_TYPE; ",
							" Summary PRIME Types of PHY frame ",
							" Description This Enum contains every types of frame supported by PRIME spec ",
							" DRV_PLC_PHY_HEADER Enum ",
							" C typedef enum { HDR_GENERIC = 0 HDR_PROMOTION = 1 HDR_BEACON = 2 } DRV_PLC_PHY_HEADER; ",
							" Summary PRIME Header Types ",
							" Description This Enum contains every header types supported by PRIME spec ",
							" DRV_PLC_PHY_CHANNEL Enum ",
							" C typedef enum { /* Single Channels */ CHN1 = 1 CHN2 = 2 CHN3 = 3 CHN4 = 4 CHN5 = 5 CHN6 = 6 CHN7 = 7 CHN8 = 8 /* Double Channels */ CHN1_CHN2 = 9 CHN2_CHN3 = 10 CHN3_CHN4 = 11 CHN4_CHN5 = 12 CHN5_CHN6 = 13 CHN6_CHN7 = 14 CHN7_CHN8 = 15 } DRV_PLC_PHY_CHANNEL; ",
							" Summary List of PRIME PHY channels ",
							" Description This type defines the PRIME channels supported by the PLC PHY: 8 single channels 7 double channels (2 consecutive channels at the same time doubling the bandwidth) The PIB PLC_ID_CHANNEL_CFG uses these values ",
							" DRV_PLC_PHY_BUFFER_ID Enum ",
							" C typedef enum { TX_BUFFER_0 = 0 TX_BUFFER_1 = 1 } DRV_PLC_PHY_BUFFER_ID; ",
							" Summary PRIME Internal Buffer identification ",
							" Description It can be used up to 2 different internal buffer to store information to transmit These buffers are implemented into PLC transceiver ",
							" DRV_PLC_PHY_TX_RESULT Enum ",
							" C typedef enum { /* Transmission result: already in process */ DRV_PLC_PHY_TX_RESULT_PROCESS = 0 /* Transmission result: end successfully */ DRV_PLC_PHY_TX_RESULT_SUCCESS = 1 /* Transmission result: invalid length error */ DRV_PLC_PHY_TX_RESULT_INV_LENGTH = 2 /* Transmission result: busy channel error */ DRV_PLC_PHY_TX_RESULT_BUSY_CH = 3 /* Transmission result: busy in transmission error */ DRV_PLC_PHY_TX_RESULT_BUSY_TX = 4 /* Transmission result: busy in reception error */ DRV_PLC_PHY_TX_RESULT_BUSY_RX = 5 /* Transmission result: invalid modulation scheme error */ DRV_PLC_PHY_TX_RESULT_INV_SCHEME = 6 /* Transmission result: timeout error */ DRV_PLC_PHY_TX_RESULT_TIMEOUT = 7 /* Transmission result: invalid buffer identifier error */ DRV_PLC_PHY_TX_RESULT_INV_BUFFER = 8 /* Transmission result: invalid PRIME Mode error */ DRV_PLC_PHY_TX_RESULT_INV_MODE = 9 /* Transmission result: invalid transmission mode */ DRV_PLC_PHY_TX_RESULT_INV_TX_MODE = 10 /* Transmission result: Transmission cancelled */ DRV_PLC_PHY_TX_RESULT_CANCELLED = 11 /* Transmission result: high temperature error */ DRV_PLC_PHY_TX_RESULT_HIGH_TEMP_120 = 12 /* Transmission result: high temperature warning */ DRV_PLC_PHY_TX_RESULT_HIGH_TEMP_110 = 13 /* Transmission result: No transmission ongoing */ DRV_PLC_PHY_TX_RESULT_NO_TX = 255 } DRV_PLC_PHY_TX_RESULT; ",
							" Summary Identifies the possible values that can result from a PLC transmission request ",
							" Description This Enum contains every transmission result supported by MCHP implementation ",
							" DRV_PLC_PHY_SIGNAL_CAPTURE_STATE Enum ",
							" C typedef enum { SIGNAL_CAPTURE_IDLE SIGNAL_CAPTURE_RUNNING SIGNAL_CAPTURE_READY } DRV_PLC_PHY_SIGNAL_CAPTURE_STATE; ",
							" Summary PRIME Noise Capture States ",
							" Description This Enum contains every available states in PRIME Noise capture process ",
							" DRV_PLC_PHY_SIGNAL_CAPTURE_INFO Enum ",
							" C typedef struct { uint8_t uc_num_frags; uint8_t uc_status; } DRV_PLC_PHY_SIGNAL_CAPTURE_INFO; ",
							" Summary Structure defining information about PRIME Noise Capture ",
							" Description This structure contains the information the status of PRIME noise capture and the number of fragments captured ",
							" DRV_PLC_PHY_TRANSMISSION_OBJ Struct ",
							" C typedef struct __attribute__((packed aligned(1))) { /* Pointer to data buffer to transmit */ uint8_t *pTransmitData; /* Instant when transmission has to start referred to 1us PHY counter */ uint32_t time; /* Length of the data to transmit in bytes */ uint16_t dataLength; /* Transmission Mode (absolute relative cancel continuous) Constants above */ uint8_t mode; /* Attenuation level with which the message will be transmitted */ uint8_t attenuation; /* Forced transmission */ uint8_t forced; /* Buffer Id used for transmission */ DRV_PLC_PHY_BUFFER_ID bufferId; /* Scheme of Modulation */ DRV_PLC_PHY_SCH scheme; /* PRIME Frame type */ DRV_PLC_PHY_FRAME_TYPE frameType; } DRV_PLC_PHY_TRANSMISSION_OBJ; ",
							" Summary PRIME Transmission setup data ",
							" Description This structure contains the information of a transmission including parameters of transmission and data to be sent ",
							" Remarks None ",
							" DRV_PLC_PHY_TRANSMISSION_CFM_OBJ Struct ",
							" C typedef struct { /* Instant when frame transmission started referred to 1us PHY counter */ uint32_t time; /* RMS value emitted */ uint32_t rmsCalc; /* PRIME Frame type */ DRV_PLC_PHY_FRAME_TYPE frameType; /* Tx Result (see \"TX Result values\" above) */ DRV_PLC_PHY_TX_RESULT result; /* Buffer Id used for transmission */ DRV_PLC_PHY_BUFFER_ID bufferId; } DRV_PLC_PHY_TRANSMISSION_CFM_OBJ; ",
							" Summary PRIME Result of a transmission ",
							" Description This structure contains the information of the last transmission its result timestamp an estimation of the injected power and the buffer ID used for transmitting ",
							" Remarks None ",
							" DRV_PLC_PHY_RECEPTION_OBJ Struct ",
							" C typedef struct __attribute__((packed aligned(1))) { /* Pointer to received data buffer */ uint8_t *pReceivedData; /* Instant when frame was received (start of message) referred to 1us PHY counter */ uint32_t time; /* Accumulated Error Vector Magnitude for header */ uint32_t evmHeaderAcum; /* Accumulated Error Vector Magnitude for payload */ uint32_t evmPayloadAcum; /* Error Vector Magnitude for header */ uint16_t evmHeader; /* Error Vector Magnitude for payload */ uint16_t evmPayload; /* Length of the received data in bytes */ uint16_t dataLength; /* Scheme of Modulation */ DRV_PLC_PHY_SCH scheme; /* PRIME Frame type */ DRV_PLC_PHY_FRAME_TYPE frameType; /* Header type */ DRV_PLC_PHY_HEADER headerType; /* Average RSSI (Received Signal Strength Indication) in dBuV */ uint8_t rssiAvg; /* Average CNIR (Carrier to Interference + Noise ratio) */ uint8_t cinrAvg; /* Minimum CNIR (Carrier to Interference + Noise ratio) */ uint8_t cinrMin; /* Average Soft BER (Bit Error Rate) */ uint8_t berSoftAvg; /* Maximum Soft BER (Bit Error Rate) */ uint8_t berSoftMax; /* Percentage of carriers affected by narrow band noise */ uint8_t narBandPercent; /* Percentage of symbols affected by impulsive noise */ uint8_t impNoisePercent; } DRV_PLC_PHY_RECEPTION_OBJ; ",
							" Summary Contains information related to a received message ",
							" Description This structure contains necessary information of a received frame such as quality modulation ",
							" Remarks None ",
							" DRV_PLC_PHY_PIB_OBJ Struct ",
							" C typedef struct { /* Pointer to PIB data */ uint8_t *pData; /* PLC Information base identification */ DRV_PLC_PHY_ID id; /* Length in bytes of the data information */ uint16_t length; } DRV_PLC_PHY_PIB_OBJ; ",
							" Summary Contains fields used in Information Base access ",
							" Description This structure contains the objects needed to access the PLC PHY Information Base (PIB) ",
							" Remarks None ",
							" G3 MAC RT Driver This driver provides a non-blocking interface with the external on-chip PLC transceiver The library uses the SPI peripheral library (PLIB) and the Direct Memory Access controller to interface with PL360/PL460 PLC devices This Driver is used when the PLC transceiver is running the G3 MAC Real Time and PHY layers Key Features: Supports a single instance of the PLC device (PL360 / PL460) and a single client to the driver Supports the internal firmware upload process Supports interrupt handling to read PLC events Supports write/read to/from the internal PLC information Base (PIB) Supports transmitting and receiving PLC frames The library can be used in both Bare-Metal and RTOS environments ",
							" How the Library Works The G3 PLC MAC RT firmware communicates with a PLC transceiver using an SPI port The PLC transceiver performs PHY and MAC RT (Real Time) duties of the communication protocol thus allowing a high latency attendance from the host MCU MAC duties performed by the library are: Frame filtering so only frames to be processed are sent to upper layers Acknowledgement generation and reception including frame retries when an expected ACK is not received Segmentation and reassembly of MAC frames Neighbour maintenance and link parameters negotiation (modulation scheme and used tones) on both forward and reverse direction POS (Personal Operating Space) maintenance by storing information of every heard node before filtering Beacon generation upon Beacon Request frames reception The G3 PLC MAC RT library offers the necessary functions to control the transceiver which include: Library initialization Transmitting and Receiving PLC frames Accessing PLC Information Base to get/set configuration parameters Enabling/Disabling transceiver Sleep Mode PLC Transceiver Interrupt mapping PLC transceiver events have to be notified to MCU in which MAC RT Driver is running This is done using a physical connection between the transceiver and an interrupt-capable PIO in MCU The library implements DRV_G3_MACRT_ExternalInterruptHandler function which is set as callback to be invoked when the interrupt is triggered on PIO This function then reads information from the transceiver and performs the required operations Driver Initialization and instance opening First of all driver has to be initialized by calling DRV_G3_MACRT_Initialize to get a valid handle Then when an instance is opened by calling DRV_G3_MACRT_Open the library loads a binary file onto the PLC transceiver This is done using an iternal transfer protocol through SPI port After binary loading the library manages the reset and startup of the transceiver This task is transparent to the user and the library is not available until binary file is transferred and thus PLC transceiver is ready to operate At this point driver is ready to be configured and used Data Service Functions PLC communication capabilities are provided by the following functions: Frame Transmission Frames are trasnmitted to PLC using DRV_G3_MACRT_TxRequest function This function expects a valid standard IEEE 802 15 4 frame (including its MAC Header) as parameter otherwise frame will not be correctly transmitted Transmission result is reported by library through the configured callback function set on DRV_G3_MACRT_TxCfmCallbackRegister  Frame reception is reported by library in 2 steps First reception parameters are received in the configured callback function set on DRV_G3_MACRT_RxParamsIndCallbackRegister Second frame itself is received through the configured callback function set on DRV_G3_MACRT_DataIndCallbackRegister Reception buffer will contain a valid standard IEEE 802 15 4 frame (including its MAC Header) for further processing Following figures ilustrate transmission request and following callback generation for both acknowledged and non-acknowledged transmissions MAC RT Trasnsmission and related events (ACK requested) MACRT_acknowledged_transmission  MAC RT Trasnsmission and related events (ACK not requested) MACRT_non_acknowledged_transmission Apart from receiving frames to be processed MAC RT driver can act as a sniffer (if configured to) at 2 levels: MAC RT Where every valid MAC RT frame will be reported before performing any filtering As in Data Indication callback a valid standard IEEE 802 15 4 frame (including its MAC Header) is received PHY Where every PHY frame will be reported before filtering and reassembling even before CRC checking so invalid MAC frames are also received The content of the sniffer data is compliant with MCHP PLC Sniffer tool provided by Microchip The sniffed frames are reported on the configured callback functions set on DRV_G3_MACRT_MacSnifferCallbackRegister and DRV_G3_MACRT_PhySnifferCallbackRegister respectively Management Functions G3 MAC RT library includes management functions to configure it and to retrieve information about the library transceiver and PLC medium status Management functions include: Information Base Access There are several parameters at both MAC RT and PHY levels that can be written/read to change behaviour and get information to/from the library In order to get/set these parameters DRV_G3_MACRT_PIBGet and DRV_G3_MACRT_PIBSet functions are used Available parameters are listed on MAC_RT_PIB Enum and MAC_RT_PHY_PIB Enum  Sleep Mode DRV_G3_MACRT_Sleep function allows entering/exitting PLC transceiver Sleep mode In case Sleep mode is exited due to an external event it is reported by the library by invoking the callback function set in DRV_G3_MACRT_SleepIndCallbackRegister  PLC Transceiver Timer Referece Every PLC transmission and reception timestamp is referenced to an interal microseconds counter The current value of such counter can be retrieved using DRV_G3_MACRT_GetTimerReference  PLC Transceiver Error handling Errors in the PLC transceiver (here called \"exceptions\") are reported by the library invoking the callback function set in DRV_G3_MACRT_ExceptionCallbackRegister Exceptions are described in DRV_G3_MACRT_EXCEPTION Enum  PLC Transceiver Status DRV_G3_MACRT_Status provides the current status of PLC Transceiver and may be used to verify whether it is ready to accept requests from MAC RT driver PLC Transmission Enabling/Disabling Sometimes it is required to inhibit MAC RT driver to transmit frames to PLC medium but keeping everything else on the driver running and maintaining the Information Base DRV_G3_MACRT_EnableTX function allow to disable PLC transmissions and later enabling them back keeping other driver mechanisms active as well as its state machine ",
							" Using The Library The G3 PLC MACRT library builds on top of an SPI peripheral library (PLIB) to communicate with a PLC transceiver in which G3-PLC lower MAC and PHY layers run However the underlying use of an SPI port is abstracted to the user and library provides a modem-like interface with Data transmission and reception functions and configuration parameters that can be read/written Data Service access is done in asynchronous mode requiring some callbacks to be set in order to let library provide communication events to the user Management Service access is done in synchronous mode and the different Get/Set functions provide the results as part of the returned/referenced parameters Example application to send data through PLC and wait for a response APP_PLC_DATA appPlc; bool txConfirmed; bool frameReceived; uint8_t txBuffer[MAC_RT_MAX_PAYLOAD_SIZE]; uint16_t txLength; static void APP_PLC_SendData ( uint8_t* pData uint16_t length ) { uint8_t *pFrame; uint8_t headerLen; if (length MAC_RT_MAX_PAYLOAD_SIZE) { return; } pFrame = appPlcTx pTxFrame; /* Build MAC RT Frame */ headerLen = APP_PLC_BuildMacRTHeader(pFrame appPlcTx txHeader); pFrame += headerLen; /* Fill Payload */ memcpy(pFrame pData length); pFrame += length; /* Send MAC RT Frame */ txConfirmed = false; DRV_G3_MACRT_TxRequest(appPlc drvPl360Handle appPlcTx pTxFrame pFrame - appPlcTx pTxFrame); } static void APP_PLC_DataCfmCb( MAC_RT_TX_CFM_OBJ *cfmObj ) { /* Update flag */ txConfirmed = true; } static void APP_PLC_DataIndCb( uint8_t *pData uint16_t length ) { /* Do whatever with received frame */ frameReceived = true; } static void APP_PLC_RxParamsIndCb( MAC_RT_RX_PARAMETERS_OBJ *pParameters ) { /* Store Rx Parameters here */ } void APP_PLC_Initialize ( void ) { /* Init PLC data buffers */ appPlcTx pTxFrame = appPlcTxFrameBuffer; appPlcTx pRxFrame = appPlcRxFrameBuffer; /* Set PLC state */ appPlc state = APP_PLC_STATE_IDLE; } void APP_PLC_Tasks ( void ) { /* Check the application's current state */ switch ( appPlc state ) { case APP_PLC_STATE_IDLE: { /* Initialize PLC driver */ appPlc state = APP_PLC_STATE_INIT; } break; case APP_PLC_STATE_INIT: { /* Open PLC driver */ appPlc drvPl360Handle = DRV_G3_MACRT_Open(DRV_G3_MACRT_INDEX_0 NULL); if (appPlc drvPl360Handle = DRV_HANDLE_INVALID) { appPlc state = APP_PLC_STATE_OPEN; } else { appPlc state = APP_PLC_STATE_ERROR; } break; } case APP_PLC_STATE_OPEN: { /* Check PLC transceiver */ if (DRV_G3_MACRT_Status(DRV_G3_MACRT_INDEX_0) == SYS_STATUS_READY) { /* Configure PLC callbacks */ DRV_G3_MACRT_TxCfmCallbackRegister(appPlc drvPl360Handle APP_PLC_DataCfmCb); DRV_G3_MACRT_DataIndCallbackRegister(appPlc drvPl360Handle APP_PLC_DataIndCb); DRV_G3_MACRT_RxParamsIndCallbackRegister(appPlc drvPl360Handle APP_PLC_RxParamsIndCb); /* Apply PLC initial configuration */ APP_PLC_SetInitialConfiguration(); /* Enable PLC Transmission */ DRV_G3_MACRT_EnableTX(appPlc drvPl360Handle true); /* Set PLC state to transmit a frame */ appPlc state = APP_PLC_STATE_TX_REQUEST; } } break; case APP_PLC_STATE_TX_REQUEST: { /* Build a frame in buffer and set length before calling SendData */ APP_PLC_SendData(txBuffer txLength); appPlc state = APP_PLC_STATE_WAITING_TX_CFM; break; } case APP_PLC_STATE_WAITING: { if (frameReceived) { frameReceived = false; /* Send another frame */ appPlc state = APP_PLC_STATE_TX_REQUEST; } break; } case APP_PLC_STATE_WAITING_TX_CFM: { if (txConfirmed) { frameReceived = false; appPlc state = APP_PLC_STATE_WAITING; } break; } /* The default state should never be executed */ default: { /* Handle error in application's state machine */ break; } } } ",
							" Configuring The Library G3 PLC MACRT Driver Specific User Configurations G3 PLC MACRT Driver library is configured via MCC Below is the Snapshot of the MCC configuration window for G3 PLC MACRT driver and brief description G3 PLC MACRT Driver configuration options G3_MACRT_mcc_configuration PLC Driver Mode Used: Specifies the PLC device physically connected The pins in use will vary depending on the device selected Configuration for PL460 device PL460 configuration options G3_MACRT_mcc_pl460_pins Configuration for PL360 device PL360 configuration options G3_MACRT_mcc_pl360_pins PLC Driver Peripheral Used: Indicates the SPI peripheral instance used by the G3 PLC MACRT driver The name of the peripheral will vary from device to device PLC Driver Chip Select Used: Indicates the SPI CS line to which PLC transceiver is connected to This option may vary from device to device PLC Driver External Interrupt Pin Used: GPIO Pin to be used as external interrupt interface (active low) This pin automatically indicates that the firmware running in the PLC device has one or more pending events to be handled Pin selection automatically updates External Interrupt Source and External Interrupt Port fields This pin must be configured as GPIO input in \"Pin Settings\" configuration Set Pull Down configuration PLC PIO Interrupt settings PLC_PHY_mcc_pl460_INT_pin_settings PLC Driver Reset Pin Used: GPIO Pin to be used as reset (active low) This pin must be configured as GPIO output in \"Pin Settings\" configuration This pin resets the core and the peripherals of the PLC device PLC Driver LDO Enable Pin Used: GPIO Pin to be used as LDO enable (active high) This pin must be configured as GPIO output in \"Pin Settings\" configuration This pin provides power to the core voltage regulator embedded in the PLC device PLC Driver TX Enable Pin Used (PL460 mode): GPIO Pin to allow PLC transmissions (active high) This pin must be configured as GPIO output in \"Pin Settings\" configuration Enable Sleep Mode: In Sleep mode the core of the device and the peripherals are reset reducing power consumption PLC Driver Standby Pin Used: GPIO Pin to be used as sleep mode enable (active high) This pin must be configured as GPIO output in \"Pin Settings\" configuration Enable Thermal Monitor (PL460 mode): Enable Thermal Monitor interface PLC Driver Thermal Monitor Pin Used (PL460 mode): GPIO Pin to check the status of the Thermal monitor This pin must be configured as GPIO output in \"Pin Settings\" configuration PLC Coupling Settings: PLC Driver mode must have been selected before to obtain a valid PLC coupling settings for each mode Used to establish the hardware configuration associated to the PLC frequency bands to use The options of this configuration will vary depending on the PLC Driver Mode selected PL460: Main Branch: PL460: Hardware blocks in a single band PLC_PHY_mcc_pl460_main_branch The main transmission branch uses the embedded class-D PLC line driver to optimize performance in terms of efficiency and EMC compliance while reducing BOM cost and PCB complexity This is the default branch for single-band applications either in CEN-A CEN-B or FCC bands G3 frequency table PLC_PHY_mcc_G3_frequencies FCC high attenuation branch: This option is visible only for FCC configured as the main branch The PL460 is capable of automatically managing two external filters in the filtering stage each filter associated to an ASOx line Multiband: PL460: Hardware blocks in multiband PLC_PHY_mcc_pl460_aux_branch This option is visible only for FCC as main branch Used to select CEN-A or CEN-B as the auxiliary PLC phy band Auxiliary Branch: The Auxiliary Transmission Branch can provide an additional output bit-stream if required The Auxiliary Transmission path cannot use the embedded PLC driver in the PL460 and requires an external circuit for signal amplification in addition to the standard filtering and coupling stages Set as default branch: Used to establish Auxiliary branch in the intialization of the PHY PLC driver PL360: Main Branch: PL360: Hardware blocks in a single band with external coupling PLC_PHY_mcc_pl360_main_branch This is the default branch for single-band applications either in CEN-A CEN-B or FCC bands FCC high attenuation branch: This option is visible only for FCC configured as the main branch Internal Driver: This option is visible only for PL360 driver mode and CEN-B configured as the main branch PL360: Hardware blocks in a single band with internal coupling PLC_PHY_mcc_pl360_main_branch_internal In case of using a coupling with internal driver only one branch is allowed and all the four EMIT pins must be connected to the same point and transmission control is indicated by TXRX0 Multiband: PL360: Hardware blocks in multiband with external coupling PLC_PHY_mcc_pl360_aux_branch This option is visible only for FCC as main branch Used to select CEN-A or CEN-B as the auxiliary PLC phy band Auxiliary Branch: The Auxiliary Transmission Branch can provide an additional output bit-stream if required Set as default branch: Used to establish Auxiliary branch in the intialization of the PHY PLC driver NVIC Configurations The G3 PLC MACRT driver has a strong dependency on a delay function defined in the HAL module This delay function is called from the PIO Handler associated with the External Interrupt pin Applications designed in MCHP used as PLC examples use the Timer module as the delay interface so the priority of the Timer interrupt must be higher that the rest of interrupts in order to ensure the correct operation ",
							" Library Interface G3 MAC Real Time driver library provides the following interfaces: Functions Name Description DRV_G3_MACRT_Initialize Initializes the MAC RT instance for the specified driver index DRV_G3_MACRT_Open Opens the specified MAC RT driver instance and returns a handle to it DRV_G3_MACRT_Close Closes an opened instance of the MAC RT driver given its handle DRV_G3_MACRT_TxRequest Allows a client to transmit MAC RT data through Power Line DRV_G3_MACRT_PIBGet Allows a client to get information from PLC transceiver about MAC RT and PHY information base (PIB) DRV_G3_MACRT_PIBSet Allows a client to set information to PLC transceiver on MAC RT and PHY information base (PIB) DRV_G3_MACRT_GetTimerReference Get the internal timer reference from PLC transceiver in microseconds DRV_G3_MACRT_TxCfmCallbackRegister Allows a client to set a data confirm event handling function for the driver to call back when the requested transmission has finished DRV_G3_MACRT_DataIndCallbackRegister Allows a client to set a data indication event handling function for the driver to call back when a data reception has finished DRV_G3_MACRT_RxParamsIndCallbackRegister Allows a client to set a reception parameters event handling function for the driver to call back when a new data message is received DRV_G3_MACRT_MacSnifferCallbackRegister Allows enabling G3 MAC RT Sniffer capabilities and set the data buffer in which the content of the sniffer packet will be stored when a new PLC message is received DRV_G3_MACRT_CommStatusCallbackRegister Allows a client to set a Comm Status indication event handling function for the driver to call back when a Comm Status event has to be reported DRV_G3_MACRT_PhySnifferCallbackRegister Allows enabling G3 PHY Sniffer capabilities and set the data buffer in which the content of the sniffer packet will be stored when a new PLC message is received DRV_G3_MACRT_ExceptionCallbackRegister Allows a client to set an exception event handling function for the driver to call back when some error occurs through PLC transceiver communication DRV_G3_MACRT_ExternalInterruptHandler Allows application to register callback for PLC Interrupt pin DRV_G3_MACRT_Status Gets the current status of the PLC driver module DRV_G3_MACRT_Tasks Maintains the driver's state machine DRV_G3_MACRT_SleepIndCallbackRegister Allows a client to set an sleep mode disable event handling function for the driver to call back when the PLC driver is active again DRV_G3_MACRT_Sleep PLC driver Sleep mode management DRV_G3_MACRT_EnableTX Enables/Disables PLC transmission Data types and constants Name Type Description DRV_G3_MACRT_EXCEPTION Enum Defines the type for G3 MAC RT Driver transfer errors DRV_G3_MACRT_TX_CFM_CALLBACK Typedef Pointer to a MAC RT Driver Transmission Confirm Event handler function DRV_G3_MACRT_DATA_IND_CALLBACK Typedef Pointer to a G3 MAC RT Driver Reception Event handler function DRV_G3_MACRT_RX_PARAMS_IND_CALLBACK Typedef Pointer to a G3 MAC RT Driver Event handler function to get parameters from the last received message DRV_G3_MACRT_MAC_SNIFFER_IND_CALLBACK Typedef Pointer to a G3 MAC RT Sniffer Reception Event handler function DRV_G3_MACRT_COMM_STATUS_IND_CALLBACK Typedef Pointer to a G3 MAC RT Communication Status Event handler function DRV_G3_MACRT_PHY_SNIFFER_IND_CALLBACK Typedef Pointer to a G3 MAC RT PHY Sniffer Reception Event handler function DRV_G3_MACRT_EXCEPTION_CALLBACK Typedef Pointer to a G3 MAC RT Driver Exceptions Event handler function DRV_G3_MACRT_SLEEP_IND_CALLBACK Typedef Notifies when Sleep Mode is disabled and MAC RT driver is available to be used again MAC_RT_TX_CFM_OBJ Struct Includes a transmission result and timestamp MAC_RT_RX_PARAMETERS_OBJ Struct Includes information to describe any new received message MAC_RT_STATUS Enum List of possible retun values for G3 MAC RT Driver functions MAC_RT_PIB_OBJ Struct Object to access the MAC RT and PHY Information Base MAC_RT_PIB Enum List of available MAC RT Information Base objects MAC_RT_PHY_PIB Enum List of available PHY Information Base objects DRV_G3_MACRT_INIT Struct Contains the data required to initialize the PLC driver DRV_PLC_HAL_INTERFACE Struct Contains the data required to initialize the PLC driver HAL Interface DRV_PLC_PLIB_INTERFACE Struct Contains the data required to initialize the PLC driver PLIB Interface ",
							" DRV_G3_MACRT_Initialize Function ",
							" C SYS_MODULE_OBJ DRV_G3_MACRT_Initialize ( const SYS_MODULE_INDEX index const SYS_MODULE_INIT * const init ); ",
							" Summary Initializes the MAC RT instance for the specified driver index ",
							" Description This routine initializes the G3 MAC RT driver making it ready for clients to open and use The initialization data is specified by the init parameter It is a single instance driver so this API should be called only once ",
							" Parameters Param Description index Index for the instance to be initialized As driver is single instance index '0' must always be used init Pointer to the init data structure containing any data necessary to initialize the driver ",
							" Returns If successful returns a valid handle to a driver instance object Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example SYS_MODULE_OBJ sysObjDrvMACRT; DRV_PLC_PLIB_INTERFACE drvPLCPlib = { spiPlibTransferSetup = (DRV_PLC_SPI_PLIB_TRANSFER_SETUP)SPI0_TransferSetup dmaChannelTx = SYS_DMA_CHANNEL_1 dmaChannelRx = SYS_DMA_CHANNEL_0 spiAddressTx = (void *) (SPI0_REGS- SPI_TDR) spiAddressRx = (void *) (SPI0_REGS- SPI_RDR) spiClockFrequency = DRV_PLC_SPI_CLK ldoPin = DRV_PLC_LDO_EN_PIN resetPin = DRV_PLC_RESET_PIN extIntPin = DRV_PLC_EXT_INT_PIN }; DRV_PLC_HAL_INTERFACE drvPLCHalAPI = { plcPlib = drvPLCPlib init = (DRV_PLC_HAL_INIT)drv_plc_hal_init setup = (DRV_PLC_HAL_SETUP)drv_plc_hal_setup reset = (DRV_PLC_HAL_RESET)drv_plc_hal_reset getCd = (DRV_PLC_HAL_GET_CD)drv_plc_hal_get_cd enableExtInt = (DRV_PLC_HAL_ENABLE_EXT_INT)drv_plc_hal_enable_interrupt delay = (DRV_PLC_HAL_DELAY)drv_plc_hal_delay sendBootCmd = (DRV_PLC_HAL_SEND_BOOT_CMD)drv_plc_hal_send_boot_cmd sendWrRdCmd = (DRV_PLC_HAL_SEND_WRRD_CMD)drv_plc_hal_send_wrrd_cmd }; extern uint8_t g3_macrt_bin_start; extern uint8_t g3_macrt_bin_end; DRV_G3_MACRT_INIT drvPLCMacRtInitData = { plcHal = drvPLCHalAPI numClients = DRV_G3_MACRT_CLIENTS_NUMBER_IDX plcProfile = DRV_G3_MACRT_PLC_PROFILE binStartAddress = (uint32_t) g3_macrt_bin_start binEndAddress = (uint32_t) g3_macrt_bin_end secure = DRV_G3_MACRT_SECURE }; sysObjDrvMACRT = DRV_G3_MACRT_Initialize(DRV_G3_MACRT_INDEX_0 (SYS_MODULE_INIT *) drvPLCMacRtInitData); // Register Callback function is mandatory to handle PLC interruption PIO_PinInterruptCallbackRegister(DRV_G3_MACRT_EXT_INT_PIN DRV_G3_MACRT_ExternalInterruptHandler sysObjDrvMACRT); ",
							" Remarks This routine must be called before any other DRV_G3_MACRT routine is called This routine should only be called once during system initialization This routine will block for hardware access ",
							" DRV_G3_MACRT_Open Function ",
							" C SYS_MODULE_OBJ DRV_G3_MACRT_Open ( const SYS_MODULE_INDEX index const DRV_PLC_BOOT_DATA_CALLBACK callback ); ",
							" Summary Opens the specified MAC RT driver instance and returns a handle to it ",
							" Description This routine opens the specified MAC RT driver instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the driver This driver is a single client driver so DRV_G3_MACRT_Open API should be called only once until driver is closed ",
							" Precondition Function DRV_G3_MACRT_Initialize must have been called before calling this function ",
							" Parameters Param Description index Index for the instance to be opened As driver is single instance index '0' must always be used callback Boot Data Callback Function Pointer In case of use NULL binStartAddress and binEndAddress fields must be configured in initialization data DRV_G3_MACRT_INIT  ",
							" Returns If successful the routine returns a valid open-instance handle (a number identifying both the caller and the module instance) As driver is single instance handle '0' is always returned If an error occurs the return value is DRV_HANDLE_INVALID Error can occur: if the driver has been already opened once and in use if the driver peripheral instance being opened is not initialized or is invalid ",
							" Example DRV_HANDLE handle; handle = DRV_G3_MACRT_Open(DRV_G3_MACRT_INDEX_0 NULL); if (handle == DRV_HANDLE_INVALID) { // Unable to open the driver // May be the driver is not initialized } ",
							" Remarks The handle returned is valid until the DRV_G3_MACRT_Close routine is called This routine will NEVER block waiting for hardware ",
							" DRV_G3_MACRT_Close Function ",
							" C void DRV_G3_MACRT_Close ( const DRV_HANDLE handle ); ",
							" Summary Closes an opened instance of the MAC RT driver ",
							" Description This routine closes an opened instance of the MAC RT driver invalidating the handle A new handle must be obtained by calling DRV_G3_MACRT_Open before the caller uses the driver again ",
							" Precondition DRV_G3_MACRT_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_G3_MACRT_Open routine ",
							" Returns None ",
							" Example // 'handle' returned from DRV_G3_MACRT_Open previously called DRV_G3_MACRT_Close(handle); ",
							" Remarks None ",
							" DRV_G3_MACRT_TxRequest Function ",
							" C void DRV_G3_MACRT_TxRequest ( const DRV_HANDLE handle uint8_t *pData uint16_t length ); ",
							" Summary Allows a client to transmit MAC RT data through Power Line (PLC) ",
							" Description This routine sends a new data message through PLC using the MAC RT driver ",
							" Precondition DRV_G3_MACRT_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_G3_MACRT_Open routine pData Pointer to the data to transmit length Length of the data to transmit in bytes ",
							" Returns None ",
							" Example // 'handle' returned from DRV_G3_MACRT_Open previously called // Local function implemented in the user application _setupTransmissionParameters(); DRV_G3_MACRT_TxRequest(handle appData pData appData length); ",
							" Remarks The G3 MAC RT Driver expects an standard 802 15 4 frame in the buffer to be transmitted ",
							" DRV_G3_MACRT_PIBGet Function ",
							" C MAC_RT_STATUS DRV_G3_MACRT_PIBGet ( const DRV_HANDLE handle MAC_RT_PIB_OBJ *pibObj ); ",
							" Summary Allows a client to get information from PLC transceiver about MAC RT and PHY information base (PIB) ",
							" Description This routine gets MAC RT and PHY data information from the PLC transceiver ",
							" Precondition DRV_G3_MACRT_Open must have been called to obtain a valid opened device handle MAC_RT_PIB_OBJ must be configured before getting information ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_G3_MACRT_Open routine pibObj Pointer to the PIB object to get ",
							" Returns MAC_RT_STATUS Enum value containing the result of get operation ",
							" Example // 'handle' returned from DRV_G3_MACRT_Open previously called MAC_RT_PIB_OBJ pibObj; uint32_t phyVersion; uint8_t macRtVersion[6]; pibObj pib = MAC_RT_PIB_MANUF_PHY_PARAM; pibObj index = PHY_PARAM_VERSION; pibObj pData = phyVersion; pibObj length = 4; DRV_G3_MACRT_PIBGet(handle pibObj); pibObj pib = MAC_RT_PIB_MANUF_MAC_RT_INTERNAL_VERSION; pibObj index = 0; pibObj pData = macRtVersion; pibObj length = 6; DRV_G3_MACRT_PIBGet(handle pibObj); ",
							" Remarks None ",
							" DRV_G3_MACRT_PIBSet Function ",
							" C MAC_RT_STATUS DRV_G3_MACRT_PIBSet ( const DRV_HANDLE handle MAC_RT_PIB_OBJ *pibObj ); ",
							" Summary Allows a client to set information to PLC transceiver on MAC RT and PHY information base (PIB) ",
							" Description This routine sets MAC RT and PHY data information to the PLC transceiver ",
							" Precondition DRV_G3_MACRT_Open must have been called to obtain a valid opened device handle MAC_RT_PIB_OBJ must be configured before setting information ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_G3_MACRT_Open routine pibObj Pointer to the PIB object to set ",
							" Returns MAC_RT_STATUS Enum value containing the result of set operation ",
							" Example // 'handle' returned from DRV_G3_MACRT_Open previously called MAC_RT_PIB_OBJ pibObj; uint8_t autoMode uint8_t impedance; uint8_t forcedRobo; // Disable AUTODETECT impedance mode autoMode = 0; // Set VLO impedance mode impedance = VLO_STATE; pibObj pib = MAC_RT_PIB_MANUF_PHY_PARAM; pibObj index = PHY_PARAM_CFG_AUTODETECT_BRANCH; pibObj pData = autoMode; pibObj length = 1; DRV_G3_MACRT_PIBSet(handle pibObj); pibObj pib = MAC_RT_PIB_MANUF_PHY_PARAM; pibObj index = PHY_PARAM_CFG_IMPEDANCE; pibObj pData = impedance; pibObj length = 1; DRV_G3_MACRT_PIBSet(handle pibObj); // Forces Modulation Type in every transmitted frame (1 - Force BPSK_ROBO) forcedRobo = 1; pibObj pib = MAC_RT_PIB_MANUF_FORCED_MOD_TYPE; pibObj index = 0; pibObj pData = forcedRobo; pibObj length = 1; DRV_G3_MACRT_PIBSet(handle pibObj); ",
							" Remarks None ",
							" DRV_G3_MACRT_GetTimerReference Function ",
							" C uint32_t DRV_G3_MACRT_GetTimerReference ( const DRV_HANDLE handle ); ",
							" Summary Gets the internal timer reference from PLC transceiver in microseconds ",
							" Description PLC transceiver has an internal 32 bits counter which is used as internal time reference for all time calculations in PHY layer This counter is internally configured to be increased each microsecond This function allows using this counter as an accurate time reference to upper layers ",
							" Precondition DRV_G3_MACRT_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_G3_MACRT_Open routine ",
							" Returns Internal timer reference from PLC transceiver in microseconds ",
							" Example // 'handle' returned from DRV_G3_MACRT_Open previously called uint32_t macRtTimerRef; macRtTimerRef = DRV_G3_MACRT_GetTimerReference(handle); ",
							" Remarks This function requires an SPI transaction to retrieve time from PLC transceiver so potential jitter in different SPI accesses may impact accuracy ",
							" DRV_G3_MACRT_TxCfmCallbackRegister Function ",
							" C void DRV_G3_MACRT_TxCfmCallbackRegister ( const DRV_HANDLE handle const DRV_G3_MACRT_TX_CFM_CALLBACK callback ); ",
							" Summary Allows a client to set a data confirm event handling function for the driver to call back when the requested transmission has finished ",
							" Description This function allows a client to register a PLC data confirm event handling function with the driver to call back when a data confirmation PLC event occurs The event handler should be set before the client submits any transmission requests that could generate events The callback once set persists until the client closes the driver or sets another callback (which could be a NULL pointer to indicate no callback) ",
							" Precondition DRV_G3_MACRT_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_G3_MACRT_Open routine callback Pointer to the callback function ",
							" Returns None ",
							" Example // Event is received when the transmission is finished void APP_PLC_Tx_Cfm_callback(MAC_RT_TX_CFM_OBJ *cfmObj) { if (cfmObj- result == MAC_RT_STATUS_SUCCESS) { // This means the data was transferred successfully } else { // Error handling here } } // myAppObj is an application specific state data object MY_APP_OBJ myAppObj; // Client registers a TX confirm callback with driver This is done once // 'myHandle' returned from DRV_G3_MACRT_Open previously called DRV_G3_MACRT_TxCfmCallbackRegister( myAppObj myHandle APP_PLC_Tx_Cfm_callback ); DRV_G3_MACRT_TxRequest(myAppObj myHandle myAppObj pData myAppObj dataLength); ",
							" Remarks None ",
							" DRV_G3_MACRT_DataIndCallbackRegister Function ",
							" C void DRV_G3_MACRT_DataIndCallbackRegister ( const DRV_HANDLE handle const DRV_G3_MACRT_DATA_IND_CALLBACK callback ); ",
							" Summary Allows a client to set a data indication event handling function for the driver to call back when a packet reception has finished ",
							" Description This function allows a client to register a MAC RT data indication event handling function with the driver to call back when a PLC data reception event occurs Before this callback is set any received frame by the PLC transceiver will not be notified The callback once set persists until the client closes the driver or sets another callback (which could be a NULL pointer to indicate no callback) ",
							" Precondition DRV_G3_MACRT_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_G3_MACRT_Open routine callback Pointer to the callback function ",
							" Returns None ",
							" Example // Event is received when a frame is received void APP_PLC_Data_Ind_callback(uint8_t *pData uint16_t length) { // Reception handling here if (length) { memcpy(myAppObj- pDataRcv pData length); myAppObj- lengthDataRcv = length; } } // myAppObj is an application specific state data object MY_APP_OBJ myAppObj; // Client registers a data indication callback with driver This is done once // 'myHandle' returned from DRV_G3_MACRT_Open previously called DRV_G3_MACRT_DataIndCallbackRegister( myAppObj myHandle APP_PLC_Data_Ind_callback ); ",
							" Remarks None ",
							" DRV_G3_MACRT_RxParamsIndCallbackRegister Function ",
							" C void DRV_G3_MACRT_RxParamsIndCallbackRegister ( const DRV_HANDLE handle const DRV_G3_MACRT_RX_PARAMS_IND_CALLBACK callback ); ",
							" Summary Allows a client to set a reception parameters event handling function for the driver to call back when a packet reception has finished ",
							" Description This function allows a client to register a MAC RT reception parameters event handling function with the driver to call back when a PLC packet reception event occurs This callback has to be set to get the reception parameters related to a received frame otherwise such information will be unknown The callback once set persists until the client closes the driver or sets another callback (which could be a NULL pointer to indicate no callback) ",
							" Precondition DRV_G3_MACRT_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_G3_MACRT_Open routine callback Pointer to the callback function ",
							" Returns None ",
							" Example void APP_PLC_Params_Ind_callback(MAC_RT_RX_PARAMETERS_OBJ *pParameters) { // Rx Parameters handling here } // myAppObj is an application specific state data object MY_APP_OBJ myAppObj; // Client registers a RxParams indication callback with driver This is done once // 'myHandle' returned from DRV_G3_MACRT_Open previously called DRV_G3_MACRT_RxParamsIndCallbackRegister( myAppObj myHandle APP_PLC_Params_Ind_callback ); ",
							" Remarks None ",
							" DRV_G3_MACRT_MacSnifferCallbackRegister Function ",
							" C void DRV_G3_MACRT_MacSnifferCallbackRegister ( const DRV_HANDLE handle const DRV_G3_MACRT_MAC_SNIFFER_CALLBACK callback uint8_t* pDataBuffer ); ",
							" Summary Allows enabling G3 MAC RT Sniffer capabilities and set the data buffer in which the content of the sniffer packet will be stored when a new PLC message is received ",
							" Description This function allows a client to register a G3 MAC RT Sniffer event handling function with the driver to call back when either a data reception event or confirmation of the last transmission event occurs A MAC RT Sniffer will receive any frame in the PLC medium regardless of addressing or frame type The callback once set persists until the client closes the driver or sets another callback (which could be a NULL pointer to indicate no callback) ",
							" Precondition DRV_G3_MACRT_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_G3_MACRT_Open routine callback Pointer to the callback function pDataBuffer Pointer to buffer where sniffer message is stored Data buffer should be defined as MAC_RT_PHY_DATA_MAX_SIZE to avoid memory overlaps ",
							" Returns None ",
							" Example void APP_G3_MAC_RT_Mac_Sniffer_callback(uint8_t *pData uint16_t length) { if (length) { // Mac Sniffer data handling here } } // myAppObj is an application specific state data object MY_APP_OBJ myAppObj; // Client registers a sniffer callback with driver This is done once // 'myHandle' returned from DRV_G3_MACRT_Open previously called DRV_G3_MACRT_MacSnifferCallbackRegister( myAppObj myHandle APP_G3_MAC_RT_Mac_Sniffer_callback myAppObj pMacSnfBuffer ); ",
							" Remarks None ",
							" DRV_G3_MACRT_CommStatusCallbackRegister Function ",
							" C void DRV_G3_MACRT_CommStatusCallbackRegister ( const DRV_HANDLE handle const DRV_G3_MACRT_COMM_STATUS_IND_CALLBACK callback ); ",
							" Summary Allows a client to set a Comm Status indication event handling function for the driver to call back when a Comm Status event has to be reported ",
							" Description This function allows a client to register a MAC RT Comm Status indication event handling function with the driver to call back when a Comm Status event occurs Comm Status events are defined in IEEE 802 15 4 standard The callback once set persists until the client closes the driver or sets another callback (which could be a NULL pointer to indicate no callback) ",
							" Precondition DRV_G3_MACRT_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_G3_MACRT_Open routine callback Pointer to the callback function ",
							" Returns None ",
							" Example void APP_G3_MAC_RT_Comm_Status_callback(uint8_t *pData) { // Extract Comm Status Data from packet } // myAppObj is an application specific state data object MY_APP_OBJ myAppObj; // Client registers a Comm Status indication callback with driver This is done once // 'myHandle' returned from DRV_G3_MACRT_Open previously called DRV_G3_MACRT_CommStatusCallbackRegister( myAppObj myHandle APP_G3_MAC_RT_Comm_Status_callback ); ",
							" Remarks None ",
							" DRV_G3_MACRT_PhySnifferCallbackRegister Function ",
							" C void DRV_G3_MACRT_PhySnifferCallbackRegister ( const DRV_HANDLE handle const DRV_G3_MACRT_PHY_SNIFFER_CALLBACK callback uint8_t* pDataBuffer ); ",
							" Summary Allows enable G3 MAC RT PHY Sniffer capabilities and set the data buffer in which the content of the sniffer packet will be stored when a new PLC message is received ",
							" Description This function allows a client to register a G3 MAC RT PHY Sniffer event handling function with the driver to call back when either a data reception event or confirmation of the last transmission event occurs The content of the sniffer data is compliant with MCHP PLC Sniffer tool provided by Microchip The callback once set persists until the client closes the driver or sets another callback (which could be a NULL pointer to indicate no callback) ",
							" Precondition DRV_G3_MACRT_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_G3_MACRT_Open routine callback Pointer to the callback function pDataBuffer Pointer to buffer where sniffer message is stored Data buffer should be defined as MAC_RT_DATA_MAX_SIZE to avoid memory overlaps ",
							" Returns None ",
							" Example void APP_G3_MAC_RT_Phy_Sniffer_callback(uint8_t *pData uint16_t length) { if (length) { // Phy Sniffer data handling here } } // myAppObj is an application specific state data object MY_APP_OBJ myAppObj; // Client registers a Phy sniffer callback with driver This is done once // 'myHandle' returned from DRV_G3_MACRT_Open previously called DRV_G3_MACRT_PhySnifferCallbackRegister( myAppObj myHandle APP_G3_MAC_RT_Phy_Sniffer_callback myAppObj pPhySnfBuffer ); ",
							" Remarks None ",
							" DRV_G3_MACRT_ExceptionCallbackRegister Function ",
							" C void DRV_G3_MACRT_ExceptionCallbackRegister ( const DRV_HANDLE handle const DRV_G3_MACRT_EXCEPTION_CALLBACK callback ); ",
							" Summary Allows a client to set an exception event handling function for the driver to call back when some error occurs through PLC transceiver communication ",
							" Description This function allows a client to register a PLC exception event handling function with the driver to call back when a communication SPI error occurs The event handler should be set before using the PLC transceiver in order to capture error events The callback once set persists until the client closes the driver or sets another callback (which could be a NULL pointer to indicate no callback) ",
							" Precondition DRV_G3_MACRT_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_G3_MACRT_Open routine callback Pointer to the callback function ",
							" Returns None ",
							" Example void APP_PLC_Exception_callback(DRV_G3_MACRT_EXCEPTION_OBJ *exceptionObj) { // Exception handling here } // myAppObj is an application specific state data object MY_APP_OBJ myAppObj; // Client registers an exception callback with driver This is done once // 'myHandle' returned from DRV_G3_MACRT_Open previously called DRV_G3_MACRT_ExceptionCallbackRegister( myAppObj myHandle APP_PLC_Exception_callback ); ",
							" Remarks None ",
							" DRV_G3_MACRT_ExternalInterruptHandler Function ",
							" C void DRV_G3_MACRT_ExternalInterruptHandler ( const PIO_PIN pin const uintptr_t context ); ",
							" Summary Allows application to register callback for PLC Interrupt pin ",
							" Description This function allows a client to register a callback function to handle MAC RT interrupt ",
							" Precondition DRV_G3_MACRT_Initialize must have been called to obtain a valid system object ",
							" Parameters Param Description pin PIO pin where interrupt source is connected context Pointer to parameters to be passed to Handler function ",
							" Returns None ",
							" Example // Initialize G3 MAC RT Driver Instance sysObj drvPLCMacRt = DRV_G3_MACRT_Initialize(DRV_G3_MACRT_INDEX (SYS_MODULE_INIT *) drvPLCMacRtInitData); // Register Callback function to handle PLC interruption PIO_PinInterruptCallbackRegister(DRV_G3_MACRT_EXT_INT_PIN DRV_G3_MACRT_ExternalInterruptHandler sysObj drvPLCMacRt); ",
							" Remarks See plib_pio h for more details ",
							" DRV_G3_MACRT_Status Function ",
							" C SYS_STATUS DRV_G3_MACRT_Status ( const SYS_MODULE_INDEX index ); ",
							" Summary Gets the current status of the PLC driver module ",
							" Description This routine provides the current status of the PLC driver module ",
							" Precondition DRV_G3_MACRT_Initialize should have been called before calling this function ",
							" Parameters Param Description index Identifier for the instance used to initialize driver ",
							" Returns Status Description SYS_STATUS_READY Driver is ready to accept requests for new operations SYS_STATUS_UNINITIALIZED Driver is not initialized SYS_STATUS_ERROR Driver is not initialized correctly SYS_STATUS_BUSY Driver is initializing ",
							" Example SYS_STATUS status; // 'DRV_G3_MACRT_INDEX' is the one used before for Driver Initialization status = DRV_G3_MACRT_Status(DRV_G3_MACRT_INDEX); ",
							" Remarks None ",
							" DRV_G3_MACRT_Tasks Function ",
							" C void DRV_G3_MACRT_Tasks ( SYS_MODULE_OBJ object ); ",
							" Summary Maintains the driver's state machine ",
							" Description This function is used to maintain the driver's internal state machine ",
							" Precondition DRV_G3_MACRT_Initialize must have been called before calling this function ",
							" Parameters Param Description object Object handle for the specified driver instance (returned from DRV_G3_MACRT_Initialize ) ",
							" Returns None ",
							" Example SYS_MODULE_OBJ object; // Returned from DRV_G3_MACRT_Initialize while (true) { DRV_G3_MACRT_Tasks (object); // Do other tasks } ",
							" Remarks This function is normally not called directly by an application It is called by the system's Tasks routine (SYS_Tasks) This function will never block or access any resources that may cause it to block ",
							" DRV_G3_MACRT_SleepIndCallbackRegister Function ",
							" C void DRV_G3_MACRT_SleepIndCallbackRegister ( const DRV_HANDLE handle const DRV_G3_MACRT_SLEEP_IND_CALLBACK callback ); ",
							" Summary Allows a client to set an sleep mode disable event handling function for the driver to call back when the PLC driver is active again ",
							" Description This function allows a client to register a PLC sleep mode disable event handling function with the driver to call back when sleep mode is disabled and PLC driver has been restarted The callback once set persists until the client closes the driver or sets another callback (which could be a NULL pointer to indicate no callback) ",
							" Precondition DRV_G3_MACRT_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the driver DRV_G3_MACRT_Open routine callback Pointer to the callback function ",
							" Returns None ",
							" Example void APP_PLC_SleepModeDisableCb( void ) { // Sleep Disable handling here } // myAppObj is an application specific state data object MY_APP_OBJ myAppObj; // Client registers a Sleep indication callback with driver This is done once // 'myHandle' returned from DRV_G3_MACRT_Open previously called DRV_G3_MACRT_SleepDisableCallbackRegister( myAppObj myHandle APP_PLC_SleepModeDisableCb ); // Event is received when PLC device comes out of sleep mode and becomes active again ",
							" Remarks None ",
							" DRV_G3_MACRT_Sleep Function ",
							" C void DRV_G3_MACRT_Sleep ( const DRV_HANDLE handle bool enable ); ",
							" Summary PLC Sleep mode management ",
							" Description This function disables PLC interrupts before going to sleep and will leave them disabled upon return If there is any PLC transmission in progress sleep mode will be enabled after the notification of the TX confirm ",
							" Precondition DRV_G3_MACRT_Initialize must have been called before calling this function ",
							" Parameters Param Description handle Object handle for the specified driver instance (returned from DRV_G3_MACRT_Initialize ) enable Set True to enter in sleep mode Set False to exit from sleep mode ",
							" Returns None ",
							" Example SYS_MODULE_OBJ object; // Returned from DRV_G3_MACRT_Initialize while (true) { if (sleep_condition) { DRV_G3_MACRT_Sleep (object true); } } ",
							" Remarks This function will never block or access any resources that may cause it to block ",
							" DRV_G3_MACRT_EnableTX Function ",
							" C void DRV_G3_MACRT_EnableTX ( const DRV_HANDLE handle bool enable ); ",
							" Summary Enables/Disables PLC transmission ",
							" Description This function allows a client to enable or disable the PLC tranmission If there is any transmission on going it will be cancelled and notified through the TX confirm callback ",
							" Precondition DRV_G3_MACRT_Initialize must have been called before calling this function ",
							" Parameters Param Description handle Object handle for the specified driver instance (returned from DRV_G3_MACRT_Initialize ) enable Set True to enable PLC tranmission Set False to disable it ",
							" Returns None ",
							" Example SYS_MODULE_OBJ object; // Returned from DRV_G3_MACRT_Initialize while (true) { // if (cancel_tx) { DRV_G3_MACRT_EnableTX (object false); } else { DRV_G3_MACRT_EnableTX (object true); } // } ",
							" Remarks None ",
							" DRV_G3_MACRT_EXCEPTION Enum ",
							" C typedef enum { /* SPI has detected an unexpected status reset is recommended */ DRV_G3_MACRT_EXCEPTION_UNEXPECTED_KEY /* SPI critical error */ DRV_G3_MACRT_EXCEPTION_CRITICAL_ERROR /* Device has been reseted by Debugging tool */ DRV_G3_MACRT_EXCEPTION_DEBUG /* Device has been reseted */ DRV_G3_MACRT_EXCEPTION_RESET } DRV_G3_MACRT_EXCEPTION; ",
							" Summary Defines the data type for G3 MAC RT Driver transfer errors ",
							" Description This type is used to indicate the error (if any) of the last SPI transfer ",
							" DRV_G3_MACRT_TX_CFM_CALLBACK Typedef ",
							" C typedef void ( *DRV_G3_MACRT_TX_CFM_CALLBACK )( MAC_RT_TX_CFM_OBJ *cfmObj ); ",
							" Summary Pointer to a MAC RT Driver Transmission Confirm Event handler function ",
							" Description This data type defines the required function signature for the MAC RT driver transmission confirm event handling callback function A client must register a pointer using the callback register function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver ",
							" Parameters Param Description cfmObj Pointer to the object containing any data necessary to identify the result of the last transmission ",
							" Returns None ",
							" Example void APP_MyTXCfmEventHandler( MAC_RT_TX_CFM_OBJ *cfmObj ) { switch(cfmObj- status) { case MAC_RT_STATUS_SUCCESS: // Transmission result: already in process break; case MAC_RT_STATUS_CHANNEL_ACCESS_FAILURE: // Transmission result: CSMA failure break; case MAC_RT_STATUS_NO_ACK: // Transmission result: ACK failure break; } } ",
							" Remarks If the status field is MAC_RT_STATUS_SUCCESS data was transmitted successfully Otherwise it contains the transmssion failure code ",
							" DRV_G3_MACRT_DATA_IND_CALLBACK Typedef ",
							" C typedef void ( *DRV_G3_MACRT_DATA_IND_CALLBACK )( uint8_t *pData uint16_t length ); ",
							" Summary Pointer to a G3 MAC RT Driver Reception Event handler function ",
							" Description This data type defines the required function signature for the MAC RT driver reception event handling callback function A client must register a pointer using the callback register function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver ",
							" Parameters Param Description pData Pointer to the data content length Length of the received data ",
							" Returns None ",
							" Example void APP_MyRxEventHandler( uint8_t *pData uint16_t length ) { // Check length of the new message if (length) { // extract data from received message memcpy(appData- dataRxBuffer pData length); } } ",
							" Remarks None ",
							" DRV_G3_MACRT_RX_PARAMS_IND_CALLBACK Typedef ",
							" C typedef void ( *DRV_G3_MACRT_RX_PARAMS_IND_CALLBACK )( MAC_RT_RX_PARAMETERS_OBJ *pParameters ); ",
							" Summary Pointer to a G3 MAC RT Driver Event handler function to get parameters from the last received message ",
							" Description This data type defines the required function signature for the MAC RT driver reception parameters event handling callback function A client must register a pointer using the callback register function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver ",
							" Parameters Param Description pParameters Pointer to the characterization parameters of the last received message ",
							" Returns None ",
							" Example void APP_MyRxParamsHandler( MAC_RT_RX_PARAMETERS_OBJ *pParameters ) { // extract all parameters from received message memcpy(appData- rxParams (uint8_t *)pParameters sizeof(MAC_RT_RX_PARAMETERS_OBJ)); } ",
							" Remarks This callback is generated just before the DRV_G3_MACRT_DATA_IND_CALLBACK in order to have Rx parameters available when frame is processed ",
							" DRV_G3_MACRT_MAC_SNIFFER_IND_CALLBACK Typedef ",
							" C typedef void ( *DRV_G3_MACRT_MAC_SNIFFER_IND_CALLBACK )( uint8_t *pData uint16_t length ); ",
							" Summary Pointer to a G3 MAC RT Sniffer Reception Event handler function ",
							" Description This data type defines the required function signature for the MAC RT driver sniffer event handling callback function A client must register a pointer using the callback register function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver ",
							" Parameters Param Description pData Pointer to the data content length Length of the received data ",
							" Returns None ",
							" Example void APP_MyMacRtMacSnifferHandler( uint8_t *pData uint16_t length ) { // Check length of the new PLC message if (length) { // extract data from received message memcpy(appData- dataMacRtMacSnifferBuffer pData length); } } ",
							" Remarks None ",
							" DRV_G3_MACRT_COMM_STATUS_IND_CALLBACK Typedef ",
							" C typedef void ( *DRV_G3_MACRT_COMM_STATUS_IND_CALLBACK )( uint8_t *pData ); ",
							" Summary Pointer to a G3 MAC RT Communication Status Event handler function ",
							" Description This data type defines the required function signature for the MAC RT driver Comm Status event handling callback function A client must register a pointer using the callback register function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver ",
							" Parameters Param Description pData Pointer to the data content ",
							" Returns None ",
							" Example void APP_MyPLCMacRtCommStatusHandler( uint8_t *pData ) { // Check length of the new PLC message if (length) { // extract data from received message memcpy(appData- dataMacCommStatusBuffer pData MAC_RT_COMM_STATUS_SIZE)); } } ",
							" Remarks None ",
							" DRV_G3_MACRT_PHY_SNIFFER_IND_CALLBACK Typedef ",
							" C typedef void ( *DRV_G3_MACRT_PHY_SNIFFER_IND_CALLBACK )( uint8_t *pData uint16_t length ); ",
							" Summary Pointer to a G3 MAC RT PHY Sniffer Reception Event handler function ",
							" Description This data type defines the required function signature for the MAC RT driver PHY sniffer event handling callback function A client must register a pointer using the callback register function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver ",
							" Parameters Param Description pData Pointer to the data content length Length of the received data ",
							" Returns None ",
							" Example void APP_MyMacRtPhySnifferHandler( uint8_t *pData uint16_t length ) { // Check length of the new PLC message if (length) { // extract data from received message memcpy(appData- dataMacRtPhySnifferBuffer pData length); } } ",
							" Remarks None ",
							" DRV_G3_MACRT_EXCEPTION_CALLBACK Typedef ",
							" C typedef void ( *DRV_G3_MACRT_EXCEPTION_CALLBACK )( DRV_G3_MACRT_EXCEPTION exception ); ",
							" Summary Pointer to a G3 MAC RT Driver Exceptions Event handler function ",
							" Description This data type defines the required function signature for the MAC RT driver exceptions event handling callback function A client must register a pointer using the callback register function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver ",
							" Parameters Param Description exception Value (of type DRV_G3_MACRT_EXCEPTION Enum) identifying the exception code which occurs during SPI transfer ",
							" Returns None ",
							" Example void APP_MyExceptionEventHandler( DRV_G3_MACRT_EXCEPTION exception ) { switch (exceptionObj) { case DRV_G3_MACRT_EXCEPTION_UNEXPECTED_KEY: // SPI has detected an unexpected status reset is recommended break; case DRV_G3_MACRT_EXCEPTION_CRITICAL_ERROR: // SPI critical error in last transfer Bootloader task has failured break; case DRV_G3_MACRT_EXCEPTION_DEBUG: // PLC transceiver has been reset by Debugging tool break; case DRV_G3_MACRT_EXCEPTION_RESET: // PLC transceiver has been reset break; default: // SPI has detected an unexpected status reset is recommended } appData- macrt_exception = true; } ",
							" Remarks None ",
							" DRV_G3_MACRT_SLEEP_IND_CALLBACK Typedef ",
							" C typedef void ( *DRV_G3_MACRT_SLEEP_IND_CALLBACK )( void ); ",
							" Summary Pointer to notification when Sleep Mode is disabled and MAC RT driver is available to be used again ",
							" Description This data type defines the required function signature for the MAC RT driver sleep mode disable event handling callback function A client must register a pointer using the callback register function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver ",
							" Parameters None ",
							" Returns None ",
							" Example void APP_MySleepDisableEventHandler( void ) { // Do initial configuration of the application if needed appData plc_sleep = false; } ",
							" Remarks None ",
							" MAC_RT_TX_CFM_OBJ Struct ",
							" C typedef struct { /* MAC RT Status */ MAC_RT_STATUS status; /* Flag to indicate Timestamp should be updated */ bool updateTimestamp; } MAC_RT_TX_CFM_OBJ; ",
							" Summary Contains a transmission result and timestamp ",
							" Description This structure contains the information of a transmission its result and timestamp ",
							" Remarks None ",
							" MAC_RT_RX_PARAMETERS_OBJ Struct ",
							" C typedef struct __attribute__((packed aligned(1))) { /* High Priority */ bool highPriority; /* PDU Link Quality */ uint8_t pduLinkQuality; /* Phase Differential */ uint8_t phaseDifferential; /* Modulation Type */ MAC_RT_MOD_TYPE modType; /* Modulation Scheme */ MAC_RT_MOD_SCHEME modScheme; /* Tone map */ MAC_RT_TONE_MAP toneMap; /* Tone map Response */ MAC_RT_TONE_MAP_RSP_DATA toneMapRsp; } MAC_RT_RX_PARAMETERS_OBJ; ",
							" Summary Contains information realted to a received message ",
							" Description This structure contains necessary information of a received frame such as quality modulation ",
							" Remarks None ",
							" MAC_RT_STATUS Enum ",
							" C typedef enum { MAC_RT_STATUS_SUCCESS = 0x00 MAC_RT_STATUS_CHANNEL_ACCESS_FAILURE = 0xE1 MAC_RT_STATUS_DENIED = 0xE2 MAC_RT_STATUS_INVALID_INDEX = 0xF9 MAC_RT_STATUS_INVALID_PARAMETER = 0xE8 MAC_RT_STATUS_NO_ACK = 0xE9 MAC_RT_STATUS_READ_ONLY = 0xFB MAC_RT_STATUS_TRANSACTION_OVERFLOW = 0xF1 MAC_RT_STATUS_UNSUPPORTED_ATTRIBUTE = 0xF4 } MAC_RT_STATUS; ",
							" Summary List of possible status of MAC RT driver ",
							" Description This type defines the possible return values for MAC RT driver functions ",
							" MAC_RT_PIB_OBJ Struct ",
							" C typedef struct { MAC_RT_PIB pib; uint16_t index; uint8_t length; uint8_t pData[MAC_RT_PIB_MAX_VALUE_LENGTH]; } MAC_RT_PIB_OBJ; ",
							" Summary Contains fields used in Information Base access ",
							" Description This structure contains the objects needed to access the MAC RT and PHY Information Base (PIB) ",
							" Remarks None ",
							" MAC_RT_PIB Enum ",
							" C typedef enum { MAC_RT_PIB_MAX_BE = 0x00000047 MAC_RT_PIB_BSN = 0x00000049 MAC_RT_PIB_DSN = 0x0000004C MAC_RT_PIB_MAX_CSMA_BACKOFFS = 0x0000004E MAC_RT_PIB_MIN_BE = 0x0000004F MAC_RT_PIB_PAN_ID = 0x00000050 MAC_RT_PIB_PROMISCUOUS_MODE = 0x00000051 MAC_RT_PIB_SHORT_ADDRESS = 0x00000053 MAC_RT_PIB_MAX_FRAME_RETRIES = 0x00000059 MAC_RT_PIB_DUPLICATE_DETECTION_TTL = 0x00000078 MAC_RT_PIB_HIGH_PRIORITY_WINDOW_SIZE = 0x00000100 MAC_RT_PIB_CSMA_NO_ACK_COUNT = 0x00000106 MAC_RT_PIB_BAD_CRC_COUNT = 0x00000109 MAC_RT_PIB_NEIGHBOUR_TABLE = 0x0000010A MAC_RT_PIB_CSMA_FAIRNESS_LIMIT = 0x0000010C MAC_RT_PIB_TMR_TTL = 0x0000010D MAC_RT_PIB_POS_TABLE_ENTRY_TTL = 0x0000010E MAC_RT_PIB_RC_COORD = 0x0000010F MAC_RT_PIB_TONE_MASK = 0x00000110 MAC_RT_PIB_BEACON_RANDOMIZATION_WINDOW_LENGTH = 0x00000111 MAC_RT_PIB_A = 0x00000112 MAC_RT_PIB_K = 0x00000113 MAC_RT_PIB_MIN_CW_ATTEMPTS = 0x00000114 MAC_RT_PIB_CENELEC_LEGACY_MODE = 0x00000115 MAC_RT_PIB_FCC_LEGACY_MODE = 0x00000116 MAC_RT_PIB_BROADCAST_MAX_CW_ENABLE = 0x0000011E MAC_RT_PIB_TRANSMIT_ATTEN = 0x0000011F MAC_RT_PIB_POS_TABLE = 0x00000120 MAC_RT_PIB_POS_RECENT_ENTRY_THRESHOLD = 0x00000121 MAC_RT_PIB_POS_RECENT_ENTRIES = 0x00000122 /* manufacturer specific */ /* Extended address of this node */ MAC_RT_PIB_MANUF_EXTENDED_ADDRESS = 0x08000001 /* provides access to neighbour table by short address (transmitted as index) */ MAC_RT_PIB_MANUF_NEIGHBOUR_TABLE_ELEMENT = 0x08000002 /* returns the maximum number of tones used by the band */ MAC_RT_PIB_MANUF_BAND_INFORMATION = 0x08000003 /* Forces Modulation Scheme in every transmitted frame 0 - Not forced 1 - Force Differential 2 - Force Coherent */ MAC_RT_PIB_MANUF_FORCED_MOD_SCHEME = 0x08000007 /* Forces Modulation Type in every transmitted frame 0 - Not forced 1 - Force BPSK_ROBO 2 - Force BPSK 3 - Force QPSK 4 - Force 8PSK */ MAC_RT_PIB_MANUF_FORCED_MOD_TYPE = 0x08000008 /* Forces ToneMap in every transmitted frame {0} - Not forced other value will be used as tonemap */ MAC_RT_PIB_MANUF_FORCED_TONEMAP = 0x08000009 /* Forces Modulation Scheme bit in Tone Map Response 0 - Not forced 1 - Force Differential 2 - Force Coherent */ MAC_RT_PIB_MANUF_FORCED_MOD_SCHEME_ON_TMRESPONSE = 0x0800000A /* Forces Modulation Type bits in Tone Map Response 0 - Not forced 1 - Force BPSK_ROBO 2 - Force BPSK 3 - Force QPSK 4 - Force 8PSK */ MAC_RT_PIB_MANUF_FORCED_MOD_TYPE_ON_TMRESPONSE = 0x0800000B /* Forces ToneMap field Tone Map Response {0} - Not forced other value will be used as tonemap field */ MAC_RT_PIB_MANUF_FORCED_TONEMAP_ON_TMRESPONSE = 0x0800000C /* Indicates whether an LBP frame for other destination has been received */ MAC_RT_PIB_MANUF_LBP_FRAME_RECEIVED = 0x0800000F /* Indicates whether an LBP frame for other destination has been received */ MAC_RT_PIB_MANUF_LNG_FRAME_RECEIVED = 0x08000010 /* Gets number of valid elements in the Neighbour Table */ MAC_RT_PIB_MANUF_NEIGHBOUR_TABLE_COUNT = 0x08000012 /* Gets number of discarded packets due to Other Destination */ MAC_RT_PIB_MANUF_RX_OTHER_DESTINATION_COUNT = 0x08000013 /* Gets number of discarded packets due to MAC Repetition */ MAC_RT_PIB_MANUF_RX_MAC_REPETITION_COUNT = 0x08000015 /* Gets number of discarded packets due to Segment Decode Error */ MAC_RT_PIB_MANUF_RX_SEGMENT_DECODE_ERROR_COUNT = 0x0800001C /* Enables MAC Sniffer */ MAC_RT_PIB_MANUF_ENABLE_MAC_SNIFFER = 0x0800001D /* Gets number of valid elements in the POS Table */ MAC_RT_PIB_MANUF_POS_TABLE_COUNT = 0x0800001E /* Gets or Sets number of retires left before forcing ROBO mode */ MAC_RT_PIB_MANUF_RETRIES_LEFT_TO_FORCE_ROBO = 0x0800001F /* Gets internal MAC RT version */ MAC_RT_PIB_MANUF_MAC_RT_INTERNAL_VERSION = 0x08000022 /* Enable/Disable Sleep Mode */ MAC_RT_PIB_SLEEP_MODE = 0x08000024 /* Set PLC Debug Mode */ MAC_RT_PIB_DEBUG_SET = 0x08000025 /* Read PL360 Debug Information */ MAC_RT_PIB_DEBUG_READ = 0x08000026 /* Provides access to POS table by short address (referenced as index) */ MAC_RT_PIB_MANUF_POS_TABLE_ELEMENT = 0x08000027 /* Minimum LQI to consider a neighbour for Trickle */ MAC_RT_PIB_MANUF_TRICKLE_MIN_LQI = 0x08000028 /* LQI for a given neighbour which short address will be indicated by index 8 bits */ MAC_RT_PIB_MANUF_NEIGHBOUR_LQI = 0x08000029 /* Best LQI found in neighbour table 8 bits */ MAC_RT_PIB_MANUF_BEST_LQI = 0x0800002A /* Flag to indicate whether next transmission is in High Priority window 8 bits */ MAC_RT_PIB_TX_HIGH_PRIORITY = 0x0800002B /* IB used to set the complete MIB structure at once */ MAC_RT_PIB_GET_SET_ALL_MIB = 0x08000100 /* Gets or sets a parameter in Phy layer Index will be used to contain PHY parameter ID Check 'enum EPhyParam' below for available Phy parameter IDs */ MAC_RT_PIB_MANUF_PHY_PARAM = 0x08000020 } MAC_RT_PIB; ",
							" Summary List of G3 MAC RT IBs ",
							" Description This Enum contains every accessible objet in G3 MAC RT Information Base A detailed description of these objects is available in G3 MAC_RT_PIBs  ",
							" G3 MAC RT IBs ",
							" MAC_RT_PIB_MAX_BE (0x00000047) Description: Maximum value of back-off exponent It should always be greater than macMinBE Access: Read-write Value Range: 1 byte  Default Value: 8 ",
							" MAC_RT_PIB_BSN (0x00000049) Description: Beacon frame sequence number Access: Read-write Value Range: 1 byte Default Value: Random ",
							" MAC_RT_PIB_DSN (0x0000004C) Description: Data frame sequence number Access: Read-write Value Range: 1 byte Default Value: Random ",
							" MAC_RT_PIB_MAX_CSMA_BACKOFFS (0x0000004E) Description: Maximum number of back-off attempts Access: Read-write Value Range: 1 byte Default Value: 50 ",
							" MAC_RT_PIB_MIN_BE (0x0000004F) Description: Minimum value of back-off exponent Access: Read-write Value Range: 1 byte  Default Value: 3 ",
							" MAC_RT_PIB_PAN_ID (0x00000050) Description: PAN ID of the network Access: Read-write Value Range: 2 bytes Default Value: 0xFFFF ",
							" MAC_RT_PIB_PROMISCUOUS_MODE (0x00000051) Description: Promiscuous mode enabled as defined in IEEE 802 15 4 specification Access: Read-write Value Range: 1 byte  Default Value: 0 ",
							" MAC_RT_PIB_SHORT_ADDRESS (0x00000053) Description: Device short address Access: Read-write Value Range: 2 bytes Default Value: 0xFFFF ",
							" MAC_RT_PIB_MAX_FRAME_RETRIES (0x00000059) Description: Maximum number of retransmission Access: Read-write Value Range: 1 byte  Default Value: 5 ",
							" MAC_RT_PIB_DUPLICATE_DETECTION_TTL (0x00000078) Description: Time a received tuple is retained for duplicate frame detection in seconds This value should be greater than (1 + MAC_RT_PIB_MAX_FRAME_RETRIES) * aEIFS Access: Read-write Value Range: 1 byte Default Value: 3 ",
							" MAC_RT_PIB_HIGH_PRIORITY_WINDOW_SIZE (0x00000100) Description: The high priority contention window size in number of slots Access: Read-write Value Range: 1 byte  Default Value: 7 ",
							" MAC_RT_PIB_CSMA_NO_ACK_COUNT (0x00000106) Description: Statistic counter of the number of times an ACK is not received after transmitting a unicast data frame Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" MAC_RT_PIB_BAD_CRC_COUNT (0x00000109) Description: Statistic counter of the number of frames received with bad CRC Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" MAC_RT_PIB_NEIGHBOUR_TABLE (0x0000010A) Description: The neighbour table as defined in G3-PLC Specification To get all the active entries the first step is to get the number of such active entries by means of MAC_WRP_PIB_MANUF_NEIGHBOUR_TABLE_COUNT (0x08000012) Then because the table is ordered all the entries can be obtained by iterating from 0 to the number of active entries Access: Read-write Value Range: 19-byte entries as defined in the following structure: typedef struct __attribute__((packed)) { uint16_t shortAddress; MAC_RT_TONE_MAP toneMap; uint8_t modulationType : 3; uint8_t txGain : 4; uint8_t txRes : 1; MAC_RT_TX_COEF txCoef; uint8_t modulationScheme : 1; uint8_t phaseDifferential : 3; uint8_t lqi; uint16_t tmrValidTime; } MAC_RT_NEIGHBOUR_ENTRY; Default Value: Empty Table ",
							" MAC_RT_PIB_CSMA_FAIRNESS_LIMIT (0x0000010C) Description: Channel access fairness limit Specifies after how many failed back-off attempts back-off exponent is set to minBE Should be at least (2 * (MAC_RT_PIB_MAX_BE - MAC_RT_PIB_MIN_BE)) Access: Read-write Value Range: 1 byte Default Value: 25 ",
							" MAC_RT_PIB_TMR_TTL (0x0000010D) Description: Maximum time to live for an entry in the neighbor table in minutes Access: Read-write Value Range: 1 byte Default Value: 10 ",
							" MAC_RT_PIB_POS_TABLE_ENTRY_TTL (0x0000010E) Description: Maximum time to live for an entry in the POS table in minutes Access: Read-write Value Range: 1 byte Default Value: 255 ",
							" MAC_RT_PIB_RC_COORD (0x0000010F) Description: Route cost to coordinator to be used in the beacon payload as RC_COORD Access: Read-write Value Range: 2 bytes Default Value: 0xFFFF ",
							" MAC_RT_PIB_TONE_MASK (0x00000110) Description: Defines the tone mask to use during symbol formation It is represented using one bit per carrier Holds up to 72 carriers (for FCC) so its size is 9 bytes Bits set indicate carrier used; bits cleared indicate carrier masked Depending on the band used a different number of bits are taken into account This PIB is a 9-byte array coded little endian (LSB first) In the Cenelec-A band the carriers are placed as shown in the figure: Tone Mask representation for Cenelec-A MAC_PIB_TONE_MASK1 Access: Read-write Value Range: 0x00-0xFF for each of 9 bytes Default Value: All bytes set to 0xFF (All carriers are enabled) ",
							" MAC_RT_PIB_BEACON_RANDOMIZATION_WINDOW_LENGTH (0x00000111) Description: Duration time in seconds for beacon randomization Access: Read-write Value Range: 1 byte  Default Value: 12 ",
							" MAC_RT_PIB_A (0x00000112) Description: This parameter controls the adaptive CW linear decrease Access: Read-write Value Range: 1 byte  Default Value: 8 ",
							" MAC_RT_PIB_K (0x00000113) Description: Rate adaptation factor for channel access fairness limit Access: Read-write Value Range: 1 byte  Default Value: 5 ",
							" MAC_RT_PIB_MIN_CW_ATTEMPTS (0x00000114) Description: Number of consecutive attempts while using minimum CW Access: Read-write Value Range: 1 byte Default Value: 255 ",
							" MAC_RT_PIB_CENELEC_LEGACY_MODE (0x00000115) Description: This read only attribute indicates the capability of the node Access: Read-only Value Range: 1 byte  Default Value: 1 ",
							" MAC_RT_PIB_FCC_LEGACY_MODE (0x00000116) Description: This read only attribute indicates the capability of the node Access: Read-only Value Range: 1 byte  Default Value: 1 ",
							" MAC_RT_PIB_BROADCAST_MAX_CW_ENABLE (0x0000011E) Description: If enabled MAC uses maximum contention window for Broadcast frames Access: Read-write Value Range: 1 byte  Default Value: 0 ",
							" MAC_RT_PIB_TRANSMIT_ATTEN (0x0000011F) Description: Attenuation of the output level in dB Access: Read-write Value Range: 1 byte  Default Value: 0 ",
							" MAC_RT_PIB_POS_TABLE (0x00000120) Description: The POS table as defined in G3-PLC Specification To get all the active entries the first step is to get the number of such active entries by means of MAC_WRP_PIB_MANUF_POS_TABLE_COUNT (0x0800001E) Then because the table is ordered all the entries can be obtained by iterating from 0 to the number of active entries Access: Read-write Value Range: 5-byte entries as defined in the following structure: typedef struct __attribute__((packed)) { uint16_t shortAddress; uint8_t lqi; uint16_t posValidTime; } MAC_RT_POS_ENTRY; Default Value: Empty Table ",
							" MAC_RT_PIB_POS_RECENT_ENTRY_THRESHOLD (0x00000121) Description: Threshold in minutes below which POS table entries are considered as recently refreshed Access: Read-write Value Range: 1 byte Default Value: 120 ",
							" MAC_RT_PIB_POS_RECENT_ENTRIES (0x00000122) Description: Number of POS table entries having been refreshed recently and which LQI is above adpTrickleMinLQI Value Access: Read-write Value Range: 2 bytes Default Value: 1 ",
							" MAC_RT_PIB_MANUF_EXTENDED_ADDRESS (0x08000001) Description: Extended address of this node Access: Read-write Value Range: 8 bytes Default Value: All bytes set to 0 ",
							" MAC_RT_PIB_MANUF_NEIGHBOUR_TABLE_ELEMENT (0x08000002) Description: This object has the same content as the neighbour table but it is retrieved using the short address of the node instead of the index inside the table To do so set the short address in the index field in the Get IB function Refer to MAC_RT_PIB_NEIGHBOUR_TABLE (0x0000010A) Access: Read-only Value Range: 19-byte entries Default Value: N/A ",
							" MAC_RT_PIB_MANUF_BAND_INFORMATION (0x08000003) Description: This read only object returns information about the band The intention of this IB is more internal than for G3 user It is used by G3 stack to perform calculations based on these parameters Access: Read-only Value Range: 10-byte entries Default Value: N/A ",
							" MAC_RT_PIB_MANUF_FORCED_MOD_SCHEME (0x08000007) Description: Forces Modulation Scheme in every transmitted frame instead of using neighbour table info For testing purposes Access: Read-write Value Range: 1 byte  0 - Not forced 1 - Force Differential 2 - Force Coherent Default Value: 0 ",
							" MAC_RT_PIB_MANUF_FORCED_MOD_TYPE (0x08000008) Description: Forces Modulation Type in every transmitted frame instead of using neighbour table info For testing purposes Access: Read-write Value Range: 1 byte  0 - Not forced 1 - Force BPSK_ROBO 2 - Force BPSK 3 - Force QPSK 4 - Force 8PSK Default Value: 0 ",
							" MAC_RT_PIB_MANUF_FORCED_TONEMAP (0x08000009) Description: Forces ToneMap in every transmitted frame instead of using neighbour table info For testing purposes Access: Read-write Value Range: 3 bytes {0xXX 0xXX 0xXX} - ToneMap to be used in subsequent transmissions {0x00 0x00 0x00} - Not forced other value will be used as tonemap Default Value: All bytes set to 0 ",
							" MAC_RT_PIB_MANUF_FORCED_MOD_SCHEME_ON_TMRESPONSE (0x0800000A) Description: Forces Modulation Scheme bit in Tone Map Response instead of using PHY layer estimation info For testing purposes Access: Read-write Value Range: 1 byte  0 - Not forced 1 - Force Differential 2 - Force Coherent Default Value: 0 ",
							" MAC_RT_PIB_MANUF_FORCED_MOD_TYPE_ON_TMRESPONSE (0x0800000B) Description: Forces Modulation Type bits in Tone Map Response instead of using PHY layer estimation info For testing purposes Access: Read-write Value Range: 1 byte  0 - Not forced 1 - Force BPSK_ROBO 2 - Force BPSK 3 - Force QPSK 4 - Force 8PSK Default Value: 0 ",
							" MAC_RT_PIB_MANUF_FORCED_TONEMAP_ON_TMRESPONSE (0x0800000C) Description: Forces ToneMap field Tone Map Response instead of using PHY layer estimation info For testing purposes Access: Read-write Value Range: 3 bytes {0xXX 0xXX 0xXX} - ToneMap to be used in subsequent transmissions {0x00 0x00 0x00} - Not forced other value will be used as tonemap Default Value: All bytes set to 0 ",
							" MAC_RT_PIB_MANUF_LBP_FRAME_RECEIVED (0x0800000F) Description: Indicates whether an LBP frame for other destination has been received For internal G3 stack purposes Access: Read-write Value Range: 1 byte  Default Value: 0 ",
							" MAC_RT_PIB_MANUF_LNG_FRAME_RECEIVED (0x08000010) Description: Indicates whether an LNG frame for other destination has been received For internal G3 stack purposes Access: Read-write Value Range: 1 byte  Default Value: 0 ",
							" MAC_RT_PIB_MANUF_NEIGHBOUR_TABLE_COUNT (0x08000012) Description: Gets number of valid elements in the Neighbour Table Access: Read-write Value Range: 2 bytes  Default Value: 0 ",
							" MAC_RT_PIB_MANUF_RX_OTHER_DESTINATION_COUNT (0x08000013) Description: Gets number of discarded packets due to Other Destination Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" MAC_RT_PIB_MANUF_RX_MAC_REPETITION_COUNT (0x08000015) Description: Gets number of discarded packets due to MAC Repetition Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" MAC_RT_PIB_MANUF_RX_SEGMENT_DECODE_ERROR_COUNT (0x0800001C) Description: Gets number of discarded packets due to Segment Decode Error Access: Read-write Value Range: 4 bytes Default Value: 0 ",
							" MAC_RT_PIB_MANUF_ENABLE_MAC_SNIFFER (0x0800001D) Description: Enables MAC Sniffer Access: Read-write Value Range: 1 byte  Default Value: 0 ",
							" MAC_RT_PIB_MANUF_POS_TABLE_COUNT (0x0800001E) Description: Gets number of valid elements in the POS Table Access: Read-write Value Range: 2 bytes  Default Value: 0 ",
							" MAC_RT_PIB_MANUF_RETRIES_LEFT_TO_FORCE_ROBO (0x0800001F) Description: Gets or Sets number of retires left before forcing ROBO mode Access: Read-write Value Range: 1 byte  Default Value: 0 ",
							" MAC_RT_PIB_MANUF_MAC_RT_INTERNAL_VERSION (0x08000022) Description: Gets internal MAC RT version Access: Read-write Value Range: 6 bytes as defined in the following structure: typedef struct { uint8_t major; uint8_t minor; uint8_t revision; uint8_t year; // year since 2000 uint8_t month; uint8_t day; } MAC_RT_INTERNAL_VERSION; Default Value: N/A ",
							" MAC_RT_PIB_SLEEP_MODE (0x08000024) Description: Enable/Disable Sleep Mode Access: Read-write Value Range: 1 byte  Default Value: 0 ",
							" MAC_RT_PIB_DEBUG_SET (0x08000025) Description: Set PLC Debug Mode Access: Write-only Value Range: 1 byte Default Value: 0 ",
							" MAC_RT_PIB_DEBUG_READ (0x08000026) Description: Read PL360 Debug Information Access: Read-only Value Range: 1 byte  Default Value: 0 ",
							" MAC_RT_PIB_MANUF_POS_TABLE_ELEMENT (0x08000027) Description: This object has the same content as the POS table but it is retrieved using the short address of the node instead of the index inside the table To do so set the short address in the index field in the Get IB function Refer to MAC_RT_PIB_POS_TABLE (0x00000120) Access: Read-write Value Range: 5-byte entries Default Value: N/A ",
							" MAC_RT_PIB_MANUF_TRICKLE_MIN_LQI (0x08000028) Description: Minimum LQI to consider a neighbour for Trickle Access: Read-write Value Range: 1 byte Default Value: 60 ",
							" MAC_RT_PIB_MANUF_NEIGHBOUR_LQI (0x08000029) Description: LQI for a given neighbour which short address will be indicated by index Access: Read-only Value Range: 1 byte Default Value: 0 ",
							" MAC_RT_PIB_MANUF_BEST_LQI (0x0800002A) Description: Best LQI found in neighbour table Access: Read-only Value Range: 1 byte Default Value: 0 ",
							" MAC_RT_PIB_TX_HIGH_PRIORITY (0x0800002B) Description: Flag to indicate whether next transmission is in High Priority window Access: Read-write Value Range: 1 byte Default Value: 0 ",
							" MAC_RT_PIB_GET_SET_ALL_MIB (0x08000100) Description: IB used to ge/set the complete MIB structure at once Access: Read-write Value Range: Entire IB Table size Default Value: N/A ",
							" MAC_RT_PIB_MANUF_PHY_PARAM (0x08000020) Description: Gets or sets a parameter in Phy layer Index will be used to contain PHY parameter ID A detailed description of the G3 PHY objects is available in G3 DRV_PLC_PHY_IDs  Access: Read-write Value Range: N/A Default Value: N/A ",
							" MAC_RT_PHY_PIB Enum ",
							" C typedef enum { PHY_PIB_PRODID = 0 PHY_PIB_MODEL PHY_PIB_VERSION_STR PHY_PIB_VERSION_NUM PHY_PIB_TONE_MASK PHY_PIB_TONE_MAP_RSP_DATA PHY_PIB_TX_TOTAL PHY_PIB_TX_TOTAL_BYTES PHY_PIB_TX_TOTAL_ERRORS PHY_PIB_TX_BAD_BUSY_TX PHY_PIB_TX_BAD_BUSY_CHANNEL PHY_PIB_TX_BAD_LEN PHY_PIB_TX_BAD_FORMAT PHY_PIB_TX_TIMEOUT PHY_PIB_RX_TOTAL PHY_PIB_RX_TOTAL_BYTES PHY_PIB_RX_RS_ERRORS PHY_PIB_RX_EXCEPTIONS PHY_PIB_RX_BAD_LEN PHY_PIB_RX_BAD_CRC_FCH PHY_PIB_RX_FALSE_POSITIVE PHY_PIB_RX_BAD_FORMAT PHY_PIB_ENABLE_AUTO_NOISE_CAPTURE PHY_PIB_TIME_BETWEEN_NOISE_CAPTURES PHY_PIB_DELAY_NOISE_CAPTURE_AFTER_RX PHY_PIB_RRC_NOTCH_ACTIVE PHY_PIB_RRC_NOTCH_INDEX PHY_PIB_NOISE_PEAK_POWER PHY_PIB_CRC_TX_RX_CAPABILITY PHY_PIB_RX_BAD_CRC_PAY PHY_PIB_CFG_AUTODETECT_IMPEDANCE PHY_PIB_CFG_IMPEDANCE PHY_PIB_ZC_PERIOD PHY_PIB_FCH_SYMBOLS PHY_PIB_PAY_SYMBOLS_TX PHY_PIB_PAY_SYMBOLS_RX PHY_PIB_RRC_NOTCH_AUTODETECT PHY_PIB_MAX_RMS_TABLE_HI PHY_PIB_MAX_RMS_TABLE_VLO PHY_PIB_THRESHOLDS_TABLE_HI PHY_PIB_THRESHOLDS_TABLE_LO PHY_PIB_THRESHOLDS_TABLE_VLO PHY_PIB_PREDIST_COEF_TABLE_HI PHY_PIB_PREDIST_COEF_TABLE_LO PHY_PIB_PREDIST_COEF_TABLE_VLO PHY_PIB_GAIN_TABLE_HI PHY_PIB_GAIN_TABLE_LO PHY_PIB_GAIN_TABLE_VLO PHY_PIB_DACC_TABLE_CFG PHY_PIB_RSV0 PHY_PIB_NUM_TX_LEVELS PHY_PIB_CORRECTED_RMS_CALC PHY_PIB_RRC_NOTCH_THR_ON PHY_PIB_RRC_NOTCH_THR_OFF PHY_PIB_CURRENT_GAIN PHY_PIB_ZC_CONF_INV PHY_PIB_ZC_CONF_FREQ PHY_PIB_ZC_CONF_DELAY PHY_PIB_NOISE_PER_CARRIER PHY_PIB_SYNC_XCORR_THRESHOLD PHY_PIB_SYNC_XCORR_PEAK_VALUE PHY_PIB_SYNC_SYNCM_THRESHOLD PHY_PIB_TONE_MAP_RSP_ENABLED_MODS PHY_PIB_PPM_CALIB_ON PHY_PIB_SFO_ESTIMATION_LAST_RX PHY_PIB_PDC_TX_LAST_RX PHY_PIB_MAX_PSDU_LEN_PARAMS PHY_PIB_MAX_PSDU_LEN PHY_PIB_RESET_STATS PHY_PIB_PLC_IC_DRIVER_CFG PHY_PIB_RX_CHN_EST_REAL PHY_PIB_RX_CHN_EST_IMAG PHY_PIB_TX_DISABLE PHY_PIB_TX_HIGH_TEMP_120 PHY_PIB_TX_CANCELLED PHY_PIB_ZC_VALUE PHY_PIB_PDC_RX_LAST_RX PHY_PIB_PDC_ZC_TIME_LAST_RX PHY_PIB_PDC_ZC_PERIOD_LAST_RX PHY_PIB_PREAMBLE_NUM_SYNCP } MAC_RT_PHY_PIB; ",
							" Summary List of G3 PHY IBs ",
							" Description This Enum contains every accessible objet in G3 PHY Information Base ",
							" DRV_G3_MACRT_INIT Struct ",
							" C typedef struct { /* Identifies the HAL API set to be used by the driver to access * peripherals */ DRV_PLC_HAL_INTERFACE *plcHal; /* PLC Profile */ uint8_t plcProfile; /* Start Address where PLC binary file is located */ uint32_t binStartAddress; /* End Address where PLC binary file is located */ uint32_t binEndAddress; /* Secure mode */ bool secure; } DRV_G3_MACRT_INIT; ",
							" Summary Contains the data required to initialize the PLC driver ",
							" Description This structure contains the objects needed to initialize the PLC driver It is passed as parameter (casted as SYS_MODULE_INIT ) to DRV_G3_MACRT_Initialize function Field description: plcHal Pointer to DRV_PLC_HAL_INTERFACE Struct which defines the way driver accesses to PLC transceiver plcProfile Not used reserved for future use binStartAddress Memory address where the first byte of transceiver's binary file is located binEndAddress Memory address where the last byte of transceiver's binary file is located secure Flag to indicate whether binary file is encrypted not supported on current version ",
							" Remarks None ",
							" DRV_PLC_HAL_INTERFACE Struct ",
							" C typedef struct { /* PLC PLIB Interface */ DRV_PLC_PLIB_INTERFACE *plcPlib; /* PLC HAL init */ DRV_PLC_HAL_INIT init; /* PLC HAL setup */ DRV_PLC_HAL_SETUP setup; /* PLC HAL reset device */ DRV_PLC_HAL_RESET reset; /* PLC low power management */ DRV_PLC_HAL_SET_STBY setStandBy; /* Only visible if SLEEP MODE is enabled on Driver Configuration */ /* PLC Temperature Monitor */ DRV_PLC_HAL_GET_THMON getThermalMonitor; /* Only visible if PL460 Driver is used and THERMAL MONITOR is enabled on Driver Configuration */ /* PLC HAL Set Tx Enable pin */ DRV_PLC_HAL_SET_TXENABLE setTxEnable; /* Only visible if PL460 Driver is used */ /* PLC HAL Enable/Disable external interrupt */ DRV_PLC_HAL_ENABLE_EXT_INT enableExtInt; /* PLC HAL delay function */ DRV_PLC_HAL_DELAY delay; /* PLC HAL Transfer Bootloader Command */ DRV_PLC_HAL_SEND_BOOT_CMD sendBootCmd; /* PLC HAL Transfer Write/Read Command */ DRV_PLC_HAL_SEND_WRRD_CMD sendWrRdCmd; } DRV_PLC_HAL_INTERFACE; ",
							" Summary Contains the data required to initialize the PLC driver HAL Interface ",
							" Description This structure contains the objects needed to initialize the driver access to PLC transceiver Field description: plcPlib Pointer to DRV_PLC_PLIB_INTERFACE Struct which defines the SPI and Control Lines to access PLC transceiver init Pointer to Hardware Initialization function setup Pointer to transceiver Setup function reset Pointer to transceiver Reset function setStandBy Pointer to transceiver Standby (Sleep) management function Only available if SLEEP MODE is enabled on Driver Configuration getThermalMonitor Pointer to transceiver Thermal Monitor status function Only available if PL460 Driver is used and THERMAL MONITOR is enabled on Driver Configuration setTxEnable Pointer to transceiver Tx Enable control function Only available if PL460 Driver is used enableExtInt Pointer to external interrupt (triggered by transceiver) management function delay Pointer to driver's implementation of Delay function sendBootCmd Pointer to driver's function to send a Boot Command to transceiver sendWrRdCmd Pointer to driver's function to send a Read/write Command to transceiver ",
							" Remarks None ",
							" DRV_PLC_HAL_INTERFACE Struct ",
							" C typedef struct { /* PLC PLIB Interface */ DRV_PLC_PLIB_INTERFACE *plcPlib; /* PLC HAL init */ DRV_PLC_HAL_INIT init; /* PLC HAL setup */ DRV_PLC_HAL_SETUP setup; /* PLC HAL reset device */ DRV_PLC_HAL_RESET reset; /* PLC low power management */ DRV_PLC_HAL_SET_STBY setStandBy; /* Only visible if SLEEP MODE is enabled on Driver Configuration */ /* PLC Temperature Monitor */ DRV_PLC_HAL_GET_THMON getThermalMonitor; /* Only visible if PL460 Driver is used and THERMAL MONITOR is enabled on Driver Configuration */ /* PLC HAL Set Tx Enable pin */ DRV_PLC_HAL_SET_TXENABLE setTxEnable; /* Only visible if PL460 Driver is used */ /* PLC HAL Enable/Disable external interrupt */ DRV_PLC_HAL_ENABLE_EXT_INT enableExtInt; /* PLC HAL delay function */ DRV_PLC_HAL_DELAY delay; /* PLC HAL Transfer Bootloader Command */ DRV_PLC_HAL_SEND_BOOT_CMD sendBootCmd; /* PLC HAL Transfer Write/Read Command */ DRV_PLC_HAL_SEND_WRRD_CMD sendWrRdCmd; } DRV_PLC_HAL_INTERFACE; ",
							" Summary Contains the data required to initialize the PLC driver HAL Interface ",
							" Description This structure contains the objects needed to initialize the driver access to PLC transceiver Field description: plcPlib Pointer to DRV_PLC_PLIB_INTERFACE Struct which defines the SPI and Control Lines to access PLC transceiver init Pointer to Hardware Initialization function setup Pointer to transceiver Setup function reset Pointer to transceiver Reset function setStandBy Pointer to transceiver Standby (Sleep) management function Only available if SLEEP MODE is enabled on Driver Configuration getThermalMonitor Pointer to transceiver Thermal Monitor status function Only available if PL460 Driver is used and THERMAL MONITOR is enabled on Driver Configuration setTxEnable Pointer to transceiver Tx Enable control function Only available if PL460 Driver is used enableExtInt Pointer to external interrupt (triggered by transceiver) management function delay Pointer to driver's implementation of Delay function sendBootCmd Pointer to driver's function to send a Boot Command to transceiver sendWrRdCmd Pointer to driver's function to send a Read/write Command to transceiver ",
							" Remarks None ",
							" Metrology Driver This driver defines the interface of Microchip smart meter PIC32CXMTSH/C metrology firmware It describes the metrology control registers metrology status registers and the quantities which shall be directly computed and available through the metrology interface registers as well as provides pertinent definitions required for proper coding Key Features: This metrology driver has been designed based on Microchip PIC32CXMTSH/C series SoC featuring industrial 0 2s accuracy class over a dynamic range of 3000:1 Supports single-phase and bi-phase smart energy applications including an internal energy metering analog front end (PIC32CXMTSH) Supports three-phases smart metering applications based on an external ATSENSE301HA analog front end (PIC32CXMTC) Supports the internal firmware upload process from Core 0 to Core 1 Supports IPC interrupt handling to read events originated by the metrology library running in Core 1 Supports write/read to/from the metrology registers Supports special functions: Waveform capture Harmonic Analysis and auto Calibration process The library can be used in both Bare-Metal and RTOS environments ",
							" How the Metrology driver library works This driver has been designed to be only used with PIC32CXMTSH or PIC32CXMTC devices which are parts of the MISTRAL (PIC32CXMT) device family of the Smart Energy group Depending on which device is used there are some requirements to be considered: PIC32CXMTSH connection This device supports single phase and dual phase (2 voltages and 2 currents) AFE is internally provided PIC32CXMTC connection This device supports poly-phase It requires an external AFE ATSense203 The Energy Metering AFE collects the data from current sensors and voltage inputs and digitizes voltage and current data This data is processed by the Metrology library running on the Core 1 of the PIC32CXMTSH/C microcontroller The Metrology driver and metering application run on Core 0 Metrology Block Diagram Metrology_Block_Diagram ",
							" Initialization process After a power up the metrology driver is responsible of the following points: Initialize and configure IPC (Inter-Processor communication) peripheral Initialize the interface with the metrology library via shared memory If the reset cause of the main processor was not a Watchdog reset: Control reset lines of the coprocessor (second processor) and the peripherals driven by the coprocessor Control clock lines of the coprocessor (second processor) and the peripherals driven by the coprocessor Copy the metrology library application file to the coprocessor execution memory A watchdog reset detection is needed in order to avoid any interruption source of the metrology library application from the main processor The metrology driver provides an assembly file to include the metrology library application file into the application of the main processor: section rodata global met_bin_start global met_bin_end align 8 met_bin_start: incbin \" /core1_metlib bin\" align 8 met_bin_end: A couple of variables are created in order to set the start and end address where the metrology library file can be found in the main application extern uint8_t met_bin_start; extern uint8_t met_bin_end; /* Metrology Driver Initialization Data */ DRV_METROLOGY_INIT drvMetrologyInitData = { /* MET bin destination address */ regBaseAddress = DRV_METROLOGY_REG_BASE_ADDRESS /* MET Binary start address */ binStartAddress = (uint32_t) met_bin_start /* MET Binary end address */ binEndAddress = (uint32_t) met_bin_end }; Once the metrology library has been located in the main application the metrology driver is in charge of copying its content in the execution memory of the coprocessor Once the metrology driver has been initialized it is necessary to call to opening function which is responsible of enabling IPC peripheral and waiting until metrology library application has been started At this point metrology control registers are configured and state control data is set to INIT status Application Initialization Sequence Metrology_Library_States_Diagram At this point start function should be called by the main application until the metrology library is in READY status When it happens the metrology driver sets the state control data to RUN status and the IPC integration interrupt will be triggered after every integration period When an integration period interrupt has been triggered by the metrology library application a callback function will be used to notify this event to the main application When it happens the update measurements function should be called to obtain the RMS values and all the metrology events properly ",
							" Using The Library The quantities available in the Metrology Module make observable all basic components required to completely define or derive all power system measurement quantities for most currently used definitions of power All per-phase voltages currents and power for fundamental and fundamental + harmonics are available allowing computation of all modern system or poly-phase power quantities Measurement data from one measurement interval is short-lived and does not persist longer than one measurement interval At the end of a measurement interval the user will be informed by software interrupt at which point the user must read all pertinent quantities before the next measurement period ends All computed quantities available through the Metrology Module are integrated over a time interval equivalent to an integral number of periods of the fundamental frequency All integration periods are approximated by the final output sample rate of the DSP filters 4000 Hz; so measurement accuracy will increase using longer integration periods One second is the recommended minimum integration period (50 cycles of 50Hz or 60 cycles of 60Hz) but fewer numbers of samples may still yield acceptable results DSP filters require a settling time before accurate measurements may be used for revenue-quality metering It is recommended to wait at least 250ms after startup before testing when testing to revenue-grade accuracy The Smart Meter DSP Module is specifically designed to accept samples from an ATSENSE Δ/Σ ADC using an OSR=64 at an input sample rate of 16 000 KHz This input data stream is further filtered to an internal sample rate of 4 000 KHz for generation of metrology quantities All computed metrology quantities are available at a rate of approximately 1Hz when using recommended settings DSP channel nomenclature defines 3 basic voltage channels: V_A V_B and V_C and 4 basic current channels: I_A I_B I_C and measured neutral current I_ Nm The current channels are combined to create an accumulated imputed neutral current I_Ni and an accumulated sample-by-sample difference between the measured and imputed neutral currents I_Nmi Values further labeled as “_F” indicate values associated with the fundamental frequency component only while values without the “_F” indicate values associated with fundamental + harmonics Example application to handle metrology driver based on FreeRTOS application void SYS_Initialize ( void* data ) { ( ) /* Initialize Metrology Driver Instance */ DRV_METROLOGY_Initialize((SYS_MODULE_INIT *) drvMetrologyInitData RSTC_ResetCauseGet()); ( ) } static void _APP_METROLOGY_NewIntegrationCallback(void) { if (app_metrologyData state == APP_METROLOGY_STATE_RUNNING) { /* Signal Metrology thread to update measurements for an integration period */ OSAL_SEM_PostISR( appMetrologySemID); } } void APP_METROLOGY_Initialize (void) { /* Detection of the WDOG0 Reset */ if (RSTC_ResetCauseGet() == RSTC_SR_RSTTYP(RSTC_SR_RSTTYP_WDT0_RST_Val)) { app_metrologyData startMode = DRV_METROLOGY_START_SOFT; } else { app_metrologyData startMode = DRV_METROLOGY_START_HARD; } /* Get Pointers to metrology data regions */ app_metrologyData pMetControl = DRV_METROLOGY_GetControl(); app_metrologyData pMetStatus = DRV_METROLOGY_GetStatus(); app_metrologyData pMetAccData = DRV_METROLOGY_GetAccData(); app_metrologyData pMetHarData = DRV_METROLOGY_GetHarData(); /* Set Callback for each metrology integration process */ DRV_METROLOGY_IntegrationCallbackRegister(_APP_METROLOGY_NewIntegrationCallback); /* Clear Harmonic Analysis Data */ app_metrologyData harmonicAnalysisPending = false; app_metrologyData pHarmonicAnalisysCallback = NULL; app_metrologyData pHarmonicAnalysisResponse = NULL; /* Clear Calibration Data */ app_metrologyData pCalibrationCallback = NULL; /* Create the Switches Semaphore */ if (OSAL_SEM_Create( appMetrologySemID OSAL_SEM_TYPE_BINARY 0 0) == OSAL_RESULT_FALSE) { /* Handle error condition Not sufficient memory to create semaphore */ } app_metrologyData state = APP_METROLOGY_STATE_INIT; } void APP_METROLOGY_Tasks (void) { APP_ENERGY_QUEUE_DATA newMetrologyData; APP_EVENTS_QUEUE_DATA newEvent; /* Check the application's current state */ switch (app_metrologyData state) { /* Application's initial state */ case APP_METROLOGY_STATE_INIT: { if (DRV_METROLOGY_Open(app_metrologyData startMode) == DRV_METROLOGY_SUCCESS) { if (app_metrologyData startMode == DRV_METROLOGY_START_HARD) { app_metrologyData state = APP_METROLOGY_STATE_START; } else { app_metrologyData state = APP_METROLOGY_STATE_RUNNING; } } else { app_metrologyData state = APP_METROLOGY_STATE_ERROR; } vTaskDelay(10 / portTICK_PERIOD_MS); break; } case APP_METROLOGY_STATE_START: { if (DRV_METROLOGY_GetState() == DRV_METROLOGY_STATE_READY) { if (DRV_METROLOGY_Start() == DRV_METROLOGY_SUCCESS) { app_metrologyData state = APP_METROLOGY_STATE_RUNNING; } else { app_metrologyData state = APP_METROLOGY_STATE_ERROR; } vTaskDelay(10 / portTICK_PERIOD_MS); } break; } case APP_METROLOGY_STATE_RUNNING: { /* Wait for the metrology semaphore to get measurements at the end of the integration period */ OSAL_SEM_Pend( appMetrologySemID OSAL_WAIT_FOREVER); /* Obtain RMS values and events */ DRV_METROLOGY_UpdateMeasurements(); /* Send new Energy values to the Energy Task */ app_metrologyData queueFree = uxQueueSpacesAvailable(appEnergyQueueID); if (app_metrologyData queueFree) { newMetrologyData energy = DRV_METROLOGY_GetEnergyValue(true); newMetrologyData Pt = DRV_METROLOGY_GetRMSValue(RMS_PT); xQueueSend(appEnergyQueueID newMetrologyData (TickType_t) 0); } else { SYS_CMD_MESSAGE(\"ENERGY Queue is FULL n r\"); } /* Send new Events to the Events Task */ app_metrologyData queueFree = uxQueueSpacesAvailable(appEventsQueueID); if (app_metrologyData queueFree) { RTC_TimeGet( newEvent eventTime); DRV_METROLOGY_GetEventsData( newEvent eventFlags); xQueueSend(appEventsQueueID newEvent (TickType_t) 0); } else { SYS_CMD_MESSAGE(\"EVENTS Queue is FULL n r\"); } break; } /* The default state should never be executed */ case APP_METROLOGY_STATE_ERROR: default: { /* TODO: Handle error in application's state machine */ break; } } } ",
							" Metrology driver Configurations Metrology Specific User Configurations Metrology Driver library should be configured via MCC Below is the Snapshot of the MCC configuration window for Metrology driver and brief description Metrology Driver main configuration options Metrology_MCC_main_options Register Base Address: Specifies the PLC device physically connected The pins in use will vary depending on the device selected Waveform capture: Enable waveform capture The waveform capture feature is a powerful tool allowing the Core 0 to access to the metrology samples The data can be processed by the Demo Meter Application running on Core 0 or can be sent to an external device for being analyzed The waveform capture function is useful in two main scenarios: When the product is being developed it's an excellent engineering tool for analyzing the acquired data The signals can be inspected in order to obtain more information about a hypothetical cross-talk or to assess how some critical sections of the electronic design (power supplies communications modules relays switching devices ) could be introducing noise in the metrology channels At the release time it allows to include new functionality in the final product Typical examples: waveform monitors harmonic analysis of the captured data (FFT) etc Metrology Driver waveform configuration options Metrology_MCC_waveform_capture Up to 6 channels of data may be captured at the same time Capture Channel IA: Enable waveform capture of channel IA Capture Channel VA: Enable waveform capture of channel VA Capture Channel IB: Enable waveform capture of channel IB Capture Channel VB: Enable waveform capture of channel VB Capture Channel IC: Enable waveform capture of channel IC Only valid for PIC32CXMTC_DB board Capture Channel VC: Enable waveform capture of channel VC Only valid for PIC32CXMTC_DB board Capture Source: All captured data is after Vref compensation has been applied and are scaled values (normalized by the appropriate K_Ix and K_Vx) In the case of 16kHz sampling data the calibration constants have not been applied Possible values could be: Capture 16kHz data before DSP filtering Capture 4kHz FBW data (Full Bandwidth = fundamental + harmonics) Capture 4kHz NBW data (Narrow Bandwidth = fundamental only) Capture Type: Capture must be enabled to initiate a capture process Once enabled capture occurs based on the requested capture mode If enabled and a continuous capture mode is selected capture continues until it is disabled If enabled and a one-shot capture mode is selected capture continues until appointed number samples is captured Samples per Channel: Specifies the buffer size used per channel for the capture function in units of 32-bits value Size of the global buffer in bytes where the data set will be stored is obtained as (Num_channels) x (Size_per_Channel) x 4 Additional notifications: Metrology Driver additional IPC notifications Metrology_MCC_aditional_not Line Cycle: Enable Line Cycle interrupt This interrupt is generated every full line cycle It means that the frequency and accumulated energy associated with pulse have been updated Unlike the RZC_IRQ the FULL_CYCLE_IRQ uses the 4KHz narrowband filtered voltage channels and exhibit a deterministic but frequency-dependent phase delay Half Line Cycle: Enable Half Line Cycle interrupt This interrupt is generated every half line cycle It means that swell and sag flags have been updated Unlike the RZC_IRQ the HALF_CYCLE_IRQ uses the 4KHz narrowband filtered voltage channels and exhibit a deterministic but frequency-dependent phase delay Raw Zero Crossing: Enable Raw Zero Crossing interrupt This interrupt is generated on zero-crossings using the unfiltered “raw” 16KHz data stream of the selected direction and selected voltage channel Pulse 0: Enable Pulse 0 interrupt This interrupt is generated immediately after their respective pulse has computationally committed to be generated but not necessarily occurred and is not subject to the pulse's PC0_OVERRIDE control bit Pulse 1: Enable Pulse 1 interrupt This interrupt is generated immediately after their respective pulse has computationally committed to be generated but not necessarily occurred and is not subject to the pulse's PC1_OVERRIDE control bit Pulse 2: Enable Pulse 2 interrupt This interrupt is generated immediately after their respective pulse has computationally committed to be generated but not necessarily occurred and is not subject to the pulse's PC2_OVERRIDE control bit Enable Channels Metrology Driver channels Metrology_MCC_enable_chn Enable Channel I0 Enable channel I0 on ATSense AFE Enable Channel I1 Enable channel I1 on ATSense AFE Enable Channel V1 Enable channel V1 on ATSense AFE Enable Channel I2 Enable channel I2 on ATSense AFE Enable Channel V2 Enable channel V2 on ATSense AFE Enable Channel I3 Enable channel I3 on ATSense AFE Only valid for PIC32CXMTC_DB board Enable Channel V3 Enable channel V3 on ATSense AFE Only valid for PIC32CXMTC_DB board Configuration Metrology Driver control configuration options Metrology_MCC_configuration Sensor Type Selects the type of current and voltage sensor used For each channel selected as using a Rogowski sensor the Metrology DSP implements a digital integrator filter to normalize the effects of the sensor’s di/dt behavior Possible values could be: Current Transformer Resistive Shunt May only be used with phase-to-neutral voltage measurement applications Rogowski Coil (CRC) Current sensor A digital integrator function is added to the DSP of all current channels selected as using Rogowski Coils When SENSOR_TYPE_I_x = 2 an additional phase correction is internally added to each channel with a Rogowski sensor in the amount of -0 3704º (@60Hz) to correct for a linear phase response introduced by the digital integrator filter This is taken into account during the internal calculation of actual phase-correction filter coefficients when a new set of phase calibration settings are loaded and should not be added by the user in the phase-correction entries When SENSOR_TYPE_I_x is set to other values it takes no effects Resistive Divider (VRD) Voltage sensor Normally this is the typical option selected for voltage sensors Meter Constant Amount of energy signified by one output pulse (MC) Units: pulses/kWh (active energy) pulses/kVARh (reactive energy) or pulses/kAmp2-h (amp square) Mains Frequency Mains frequency (F) Units: Hz Transformer Ratio In the case of a current transformer this is the current transformer ratio (Tr) In the case of a Rogowski Coil this is the current sensitivity (units: uV/A) at the main frequency specified in “Frequency” parameter Metrology Driver configuration for Rogowski coil Type Metrology_MCC_conf_rogowski Resistor Load In the case of current transformer this is the resistor load (Rl) or burden resistor (units: Ω) In the case of shunt resistor this is the shunt resistor value (units: uΩ) Metrology Driver configuration for Shunt Type Metrology_MCC_conf_shunt Voltage divider ratio Voltage divider ratio (Ku) Programable Gain Amplifier Programmable Gain Amplifier (G) of the AFE (analog front end) Possible values: 1 2 4 or 8 SWELL Threshold RMS For each half cycle of the fundamental period VxRMS is calculated per phase and compared to the value set in SWELL_THRESHOLD_Vx: where x = to determine if a voltage swell condition exists For each half cycle that a voltage swell exists the associated flag SWELL_DET_Vx is set to 1 A threshold is allowed for each phase and is computed using the native phase voltages before transformation to implied 4WY service This allows setting different thresholds for non-balanced service types For this configuration same SWELL Threshold will be applied to all phases SAG Threshold RMS For each half cycle of the fundamental period VxRMS is calculated per phase and compared to the value set in SAG_THRESHOLD_Vx: where x = to determine if a voltage sag condition exists For each half cycle that a voltage sag exists the associated flag SWAG_DET_Vx is set to 1 A threshold is allowed for each phase and is computed using the native phase voltages before transformation to implied 4WY service This allows setting different thresholds for non-balanced service types For this configuration same SAG Threshold will be applied to all phases Active Power Creep Threshold Enable Used to enable/disable metrology creep function of active power pulse generation and any associated ACC_Tx total energy pulse value accumulators Metrology Driver configuration for Active Power Creep Metrology_MCC_conf_p_creep Creep Active Energy (Wh) - Total active energy pulse quantities in any one line cycle interval less than the creep threshold are reset to zero and are not accumulated - Is the creep active energy (Watt-hour) in a full cycle (20ms for 50Hz 16 667ms for 60Hz) Reactive power Creep Threshold Enable Used to enable/disable metrology creep function of reactive power pulse generation and any associated ACC_Tx total quadergy pulse value accumulators Metrology Driver configuration for Reactive Power Creep Metrology_MCC_conf_q_creep Creep Reactive Energy (VARh) Total reactive energy pulse quantities in any one line cycle interval less than the creep threshold are reset to zero and are not accumulated Is the creep reactive energy (Var-hour) in a full cycle (20ms for 50Hz 16 667ms for 60Hz) Current Creep Threshold Enable Used to enable/disable creep function of metrology both for pulse generation and any associated ACC_Tx total pulse value accumulators Current creep thresholding is used to kill pulse contribution from any or all phases below the current threshold and affects all enabled pulsing Metrology Driver configuration for Current Creep Metrology_MCC_conf_i_creep Creep Current (mA) For each phase whose current is less than this threshold any contributions to a selected pulse are zeroed out and quantities from that phase make no contribution toward any selected pulse and its associated pulse accumulator Pulse X Control Three pulses can be generated at the same time PULSE0_CTRL is used to control the pulse output from PD17 PULSE1_CTRL is used to control the pulse output from PD18 PULSE2_CTRL is used to control the pulse output from PD19 IPC interrupts are triggered at each pulse: IPC_PULSEx Metrology Driver configuration for Pulse X Control Metrology_MCC_pulse_control Output Pulse Enable Used to enable or disable pulse functionality Total Absolute Values When creating P and Q accumulator totals of multiple phases this option allows taking the absolute values of each phase before adding to make the total This is used to primarily ignore direction of energy delivered/generated for pulse generation Possible values could be: Net: Pulses generated based on (energy delivered – energy generated): Individual sign of each channel’s P and Q is taken into account when creating total P and Q accumulator sums Absolute: Pulses generated based on (energy delivered + energy generated): The absolute value of each phase’s P and Q is used when creating the total P and Q accumulator sums Delivered: Pulses generated based on (delivered only): Only positive values (energy delivered) of each phase’s P and Q are used when creating the total P and Q accumulator sums with negative values (energy generated) being ignored Generated: Pulses generated based on (generated only): Only negative values (energy generated) of each phase’s P and Q are used when creating the total P and Q accumulator sums with positive values (energy delivered) being ignored Polarity Pulse Polarity Possible values could be: PULSE_LOW: Output pulse is low with width set by K_WIDTH followed by an inactive level of high PULSE_HIGH: Output pulse is high with width set by K_WIDTH followed by an inactive level of low Type Types described as “all phases” are based on all active phases: Types described as “S” use only the synthesized voltage channel phase: if available Possible values could be: P_T: Watt-hours total all phases fundamental + harmonics P_T_F: Watt-hours total all phases fundamental only Q_T: Var-hours total all phases fundamental + harmonics Q_T_F: Var-hours total all phases fundamental only I_T: Amp-squared-hours total all phases fundamental + harmonics I_T_F: Amp-squared-hours total all phases fundamental only Width Pulse width The granularity for pulse width is in units of 2 1552μs corresponding to a peripheral clock rate of 464kHz ",
							" Library Interface Metrology driver library provides the following interfaces: Functions Name Description DRV_METROLOGY_Initialize Initializes the metrology Driver for MISTRAL dual-core devices DRV_METROLOGY_Open Opens the specified metrology driver DRV_METROLOGY_Close Closes an opened instance of the metrology driver DRV_METROLOGY_Start Start running the metrology library in coprocessor DRV_METROLOGY_IntegrationCallbackRegister Allows a client to set an event handling function for the driver to call back when the integration period has completed DRV_METROLOGY_GetState Gets the current state of the metrology driver DRV_METROLOGY_GetControl Gets the pointer to the control registers of the metrology library DRV_METROLOGY_GetStatus Gets the pointer to the status registers of the metrology library DRV_METROLOGY_GetAccData Gets the pointer to the accumulated quantities of the metrology library DRV_METROLOGY_GetHarData Gets the pointer to the Harmonic analysis quantities of the metrology library DRV_METROLOGY_GetCalibrationData Gets the pointer to the calibration data used for the metrology driver DRV_METROLOGY_GetControlByDefault Gets the pointer to the control registers defined by MCC configurator DRV_METROLOGY_SetControl Sets the value of all the control registers of the metrology library DRV_METROLOGY_UpdateMeasurements Allows a client to update all RMS events and energy measurements according to the last values stored in the registers of the metrology library DRV_METROLOGY_GetEnergyValue Gets the last energy calculated value DRV_METROLOGY_GetRMSValue Gets the RMS value of the desired measurement DRV_METROLOGY_GetRMSSign Gets the RMS sign of the desired measurement DRV_METROLOGY_GetEventsData Gets the pointer to the last events obtained from the metrology library DRV_METROLOGY_SetConfiguration Applies the proper configuration before calibrating the system DRV_METROLOGY_StartCalibration Starts the calibration process DRV_METROLOGY_UpdateCalibration Allows a client to update the calibration process DRV_METROLOGY_CalibrationIsCompleted Checks if the calibration process has been completed DRV_METROLOGY_GetCalibrationResult Check if the calibration process has been performed correctly DRV_METROLOGY_StartHarmonicAnalysis Starts the harmonics computation DRV_METROLOGY_HarmonicAnalysisIsRun Checks if the harmonic analysis is in progress DRV_METROLOGY_GetHarmonicAnalysisResult Check if the harmonic analisys computation has been performed correctly Data types and constants Name Type Description DRV_METROLOGY_RESULT Enum Result of a Metrology driver interface operation DRV_METROLOGY_START_MODE Enum Identifies types of startup process DRV_METROLOGY_RMS_SIGN Enum Identifies the sign of RMS values DRV_METROLOGY_CALLBACK Typedef Pointer to a metrology event handler function DRV_METROLOGY_SENSOR_TYPE Enum Identifies types of metrology sensors DRV_METROLOGY_GAIN_TYPE Enum Identifies possible gain values for the AFE (Analog Front End) DRV_METROLOGY_PHASE_ID Enum Identifies all the metrology phases DRV_METROLOGY_CALIBRATION_REFS Struct Specifies the all reference values used for the auto calibration process DRV_METROLOGY_CALIBRATION Struct Specifies all data internally needed for the auto calibration process DRV_METROLOGY_AFE_EVENTS Struct Identifies all events related to metrology library DRV_METROLOGY_HARMONIC Struct Identifies the result of the Harmonic Analysis process DRV_METROLOGY_RMS_TYPE Enum Identifies the all RMS types of measurements DRV_METROLOGY_AFE_DATA Struct Identifies the data calculated from the metrology AFE measurements DRV_METROLOGY_CONFIGURATION Struct Identifies values needed to set different metrology configurations DRV_METROLOGY_STATE Enum Identifies the state of the metrology library DRV_METROLOGY_INIT Struct Identifies values needed for the initialization routine ",
							" DRV_METROLOGY_Initialize Function ",
							" C SYS_MODULE_OBJ DRV_METROLOGY_Initialize ( SYS_MODULE_INIT * init uint32_t resetValue ); ",
							" Summary Initializes the metrology driver according to the init parameter and the cause of the reset of the main processor ",
							" Description This routine initializes the metrology driver making it ready for clients to open and use The initialization data is specified by the init parameter It is a single instance driver ",
							" Parameters Param Description init Pointer to the init data structure containing any data necessary to initialize the driver resetValue Reset cause of the main processor ",
							" Returns If successful returns a valid handle to a driver instance object Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example SYS_MODULE_OBJ sysObjDrvMet; extern uint8_t met_bin_start; extern uint8_t met_bin_end; /* Metrology Driver Initialization Data */ DRV_METROLOGY_INIT drvMetrologyInitData = { /* MET bin destination address */ regBaseAddress = DRV_METROLOGY_REG_BASE_ADDRESS /* MET Binary start address */ binStartAddress = (uint32_t) met_bin_start /* MET Binary end address */ binEndAddress = (uint32_t) met_bin_end }; sysObjDrvMet = DRV_METROLOGY_Initialize((SYS_MODULE_INIT *) drvMetrologyInitData RSTC_ResetCauseGet()); ",
							" Remarks This routine must be called before any other DRV_METROLOGY routine is called ",
							" DRV_METROLOGY_Open Function ",
							" C DRV_METROLOGY_RESULT DRV_METROLOGY_Open ( DRV_METROLOGY_START_MODE mode ); ",
							" Summary Opens the metrology driver according to the mode parameter ",
							" Description This routine enables the IPC peripheral and only if a HARD start mode has been selected also handles the reset and clock lines for enabling the metrology library application On the other hand SOFT mode does not any effects on metrology library application running in the second processor ",
							" Parameters Param Description mode Metrology Driver Start mode ",
							" Returns If successful returns DRV_METROLOGY_SUCCESS Otherwise it returns DRV_METROLOGY_ERROR ",
							" Example /* Detection of the WDOG0 Reset */ if (RSTC_ResetCauseGet() == RSTC_SR_RSTTYP(RSTC_SR_RSTTYP_WDT0_RST_Val)) { app_metrologyData startMode = DRV_METROLOGY_START_SOFT; } else { app_metrologyData startMode = DRV_METROLOGY_START_HARD; } case APP_METROLOGY_STATE_INIT: { if (DRV_METROLOGY_Open(app_metrologyData startMode) == DRV_METROLOGY_SUCCESS) { if (app_metrologyData startMode == DRV_METROLOGY_START_HARD) { app_metrologyData state = APP_METROLOGY_STATE_START; } else { app_metrologyData state = APP_METROLOGY_STATE_RUNNING; } } else { app_metrologyData state = APP_METROLOGY_STATE_ERROR; } break; } ",
							" Remarks This routine must be called after DRV_METROLOGY_Initialize routine is called ",
							" DRV_METROLOGY_Close Function ",
							" C DRV_METROLOGY_RESULT DRV_METROLOGY_Close (void); ",
							" Summary Closes the metrology driver ",
							" Description This routine closes the metrology driver making it unusable ",
							" Parameters None ",
							" Returns If successful returns DRV_METROLOGY_SUCCESS Otherwise it returns DRV_METROLOGY_ERROR ",
							" Example app_metrologyData state = APP_METROLOGY_STATE_INIT; app_metrologyData startMode = DRV_METROLOGY_START_HARD; DRV_METROLOGY_Close(); DRV_METROLOGY_Initialize(NULL RSTC_SR_RSTTYP(RSTC_SR_RSTTYP_SOFT_RST_Val)); ",
							" Remarks None ",
							" DRV_METROLOGY_Start Function ",
							" C DRV_METROLOGY_RESULT DRV_METROLOGY_Start (void); ",
							" Summary Starts the metrology driver ",
							" Description This routine shoud be called until the metrology library application running in the second processor is ready to be used ",
							" Parameters None ",
							" Returns Returns DRV_METROLOGY_SUCCESS when the metrology library application is ready to be used Otherwise it returns DRV_METROLOGY_ERROR ",
							" Example case APP_METROLOGY_STATE_START: { if (DRV_METROLOGY_Start() == DRV_METROLOGY_SUCCESS) { app_metrologyData state = APP_METROLOGY_STATE_RUNNING; } else { app_metrologyData state = APP_METROLOGY_STATE_ERROR; } break; } ",
							" Remarks This routine must be called after DRV_METROLOGY_Start routine has been called ",
							" DRV_METROLOGY_IntegrationCallbackRegister Function ",
							" C DRV_METROLOGY_RESULT DRV_METROLOGY_IntegrationCallbackRegister ( DRV_METROLOGY_CALLBACK callback ); ",
							" Summary Allows a client to set a metrology integration event handling function for the driver to call back when a integration period has completed ",
							" Description This function allows a client to register an integration period event handling function with the driver to call back when a integration period has completed This function must be always called after DRV_METROLOGY_Initialize routine is called since the initialization routine sets a NULL pointer to indicate no callback ",
							" Precondition DRV_METROLOGY_Initialize must have been called before ",
							" Parameters Param Description callback Pointer to the callback function ",
							" Returns If successful returns DRV_METROLOGY_SUCCESS Otherwise it returns DRV_METROLOGY_ERROR ",
							" Example static void _APP_METROLOGY_NewIntegrationCallback(void) { if (app_metrologyData state == APP_METROLOGY_STATE_RUNNING) { /* Signal Metrology thread to update measurements for an integration period */ OSAL_SEM_PostISR( appMetrologySemID); } } ( ) /* Set Callback for each metrology integration process */ DRV_METROLOGY_IntegrationCallbackRegister(_APP_METROLOGY_NewIntegrationCallback); ",
							" Remarks None ",
							" DRV_METROLOGY_GetState Function ",
							" C DRV_METROLOGY_STATE DRV_METROLOGY_GetState (void); ",
							" Summary Get the status of the metrology library application running on the second processor ",
							" Description Metrology function state: 0 = HALT: Metrology module is halted; 1 = RESET: Resetting metrology module; 2 = INIT_DSP: Initializing DSP filters; 3 = DSP_READY: DSP filters have been initialized; 4 = INIT_ATSENSE: Initializing ATSENSE; 5 = ATSENSE_READY: ATSENSE has been initialized; 6 = READY: ATSENSE temperature configuration calibration data has been copied into output registers; 7 = DSP_SETTLING: waiting for DSP filters to stabilize to full accuracy; 8 = DSP_RUNNING: DSP filters have stabilized to full accuracy; You can refer to the metrology state diagram for more detailed description: Metrology State Diagram Metrology_State_Diagram ",
							" Parameters None ",
							" Returns Returns the metrology state ",
							" Example case APP_METROLOGY_STATE_START: { if (DRV_METROLOGY_GetState() == DRV_METROLOGY_STATE_READY) { if (DRV_METROLOGY_Start() == DRV_METROLOGY_SUCCESS) { app_metrologyData state = APP_METROLOGY_STATE_RUNNING; } else { app_metrologyData state = APP_METROLOGY_STATE_ERROR; } vTaskDelay(10 / portTICK_PERIOD_MS); } break; } ",
							" Remarks None ",
							" DRV_METROLOGY_GetControl Function ",
							" C DRV_METROLOGY_CONTROL * DRV_METROLOGY_GetControl (void); ",
							" Summary Get the pointer to the control registers of the metrology library application running on the second processor ",
							" Description Control registers are acting as 32-bit metrology input control registers For a detailed description of the control registers refer to \"drv_metrology_regs h\" header file ",
							" Parameters None ",
							" Returns Pointer to the 32-bit metrology input control registers ",
							" Example /* Get Pointers to metrology data regions */ app_metrologyData pMetControl = DRV_METROLOGY_GetControl(); app_metrologyData pMetStatus = DRV_METROLOGY_GetStatus(); app_metrologyData pMetAccData = DRV_METROLOGY_GetAccData(); app_metrologyData pMetHarData = DRV_METROLOGY_GetHarData(); ",
							" Remarks None ",
							" DRV_METROLOGY_GetStatus Function ",
							" C DRV_METROLOGY_STATUS * DRV_METROLOGY_GetStatus (void); ",
							" Summary Get the pointer to the status registers of the metrology library application running on the second processor ",
							" Description The Metrology library generates primary 32-bit output measurement quantities for each measurement interval For a detailed description of the status registers refer to \"drv_metrology_regs h\" header file ",
							" Parameters None ",
							" Returns Pointer to the 32-bit metrology output measurement quantities for each measurement interval ",
							" Example /* Get Pointers to metrology data regions */ app_metrologyData pMetControl = DRV_METROLOGY_GetControl(); app_metrologyData pMetStatus = DRV_METROLOGY_GetStatus(); app_metrologyData pMetAccData = DRV_METROLOGY_GetAccData(); app_metrologyData pMetHarData = DRV_METROLOGY_GetHarData(); ",
							" Remarks None ",
							" DRV_METROLOGY_GetAccData Function ",
							" C DRV_METROLOGY_ACCUMULATORS * DRV_METROLOGY_GetAccData (void); ",
							" Summary Get the pointer to the accumulator registers of the metrology library application running on the second processor ",
							" Description Accumulator registers are acting as 64-bit metrology output accumulator registers All values are integrated at an equivalent sampling rate of 4 000KHz The Metrology library shall generate the following primary output measurement quantities for each measurement interval per-phase quantities with each phase designated by the subscript “_x” (where x = for voltage channels and x = for current channels) For a detailed description of the control registers refer to \"drv_metrology_regs h\" header file ",
							" Parameters None ",
							" Returns Pointer to the 32-bit metrology input control registers ",
							" Example /* Get Pointers to metrology data regions */ app_metrologyData pMetControl = DRV_METROLOGY_GetControl(); app_metrologyData pMetStatus = DRV_METROLOGY_GetStatus(); app_metrologyData pMetAccData = DRV_METROLOGY_GetAccData(); app_metrologyData pMetHarData = DRV_METROLOGY_GetHarData(); ",
							" Remarks None ",
							" DRV_METROLOGY_GetHarData Function ",
							" C DRV_METROLOGY_HARMONICS * DRV_METROLOGY_GetHarData (void); ",
							" Summary Get the pointer to the harmonic analysis registers of the metrology library application running on the second processor ",
							" Description Harmonic analysis registers are acting as 32-bit metrology harmonic analysis registers The Metrology module shall generate the following primary output measurement quantities for each measurement interval per-phase quantities with each phase designated by the subscript “_x” (where x = for voltage channels and x = for current channels) Internal scaling allows accurate harmonic analysis for integration periods of up to 16 seconds for up to full-scale magnitude input waveforms For a detailed description of the harmonic analysis registers refer to \"drv_metrology_regs h\" header file ",
							" Parameters None ",
							" Returns Pointer to the 32-bit metrology harmonic analysis registers ",
							" Example /* Get Pointers to metrology data regions */ app_metrologyData pMetControl = DRV_METROLOGY_GetControl(); app_metrologyData pMetStatus = DRV_METROLOGY_GetStatus(); app_metrologyData pMetAccData = DRV_METROLOGY_GetAccData(); app_metrologyData pMetHarData = DRV_METROLOGY_GetHarData(); ",
							" Remarks None ",
							" DRV_METROLOGY_GetCalibrationData Function ",
							" C DRV_METROLOGY_CALIBRATION * DRV_METROLOGY_GetCalibrationData (void); ",
							" Summary Get the pointer to the data used in the internal calibration process of the metrology library ",
							" Description These internal calibration values are used to obtain the RMS values correctly They also includes the result of the calibration process to be checked by the main application ",
							" Parameters None ",
							" Returns Pointer to the internal calibration data ",
							" Example void APP_METROLOGY_StartCalibration(APP_METROLOGY_CALIBRATION * calibration) { DRV_METROLOGY_CALIBRATION * pCalibrationData; pCalibrationData = DRV_METROLOGY_GetCalibrationData(); pCalibrationData- references aimIA = calibration- aimIA; pCalibrationData- references aimVA = calibration- aimVA; pCalibrationData- references angleA = calibration- angleA; pCalibrationData- references aimIB = calibration- aimIB; pCalibrationData- references aimVB = calibration- aimVB; pCalibrationData- references angleB = calibration- angleB; pCalibrationData- references aimIC = calibration- aimIC; pCalibrationData- references aimVC = calibration- aimVC; pCalibrationData- references angleC = calibration- angleC; pCalibrationData- references lineId = calibration- lineId; app_metrologyData state = APP_METROLOGY_STATE_CHECK_CALIBRATION; } ",
							" Remarks None ",
							" DRV_METROLOGY_GetControlByDefault Function ",
							" C DRV_METROLOGY_CONTROL * DRV_METROLOGY_GetControlByDefault (void); ",
							" Summary Get the pointer to the control registers defined by default via the Microchip Code Configurator (MCC) included in Harmony 3 framework ",
							" Description After generating the code application via MCC a struct data is defined as a constant It includes all control registers obtained according to the MCC configuration established in the Harmony 3 project The content of each control register is defined in \"configuration h\" header file ",
							" Parameters None ",
							" Returns Pointer to the control registers defined as the default configuration ",
							" Example const DRV_METROLOGY_CONTROL gDrvMetControlDefault = { STATE_CTRL_STATE_CTRL_RESET_Val /* 00 STATE_CTRL */ _UINT32_(DRV_METROLOGY_CONF_FCTRL0) /* 01 FEATURE_CTRL0 */ _UINT32_(DRV_METROLOGY_CONF_FCTRL1) /* 02 FEATURE_CTRL1 */ _UINT32_(DRV_METROLOGY_CONF_MT) /* 03 METER_TYPE sensor_type =0 CT 1 SHUNT 2 ROGOWSKI */ _UINT32_(0x00000000) /* 04 M M=50- 50Hz M=60- 60Hz */ _UINT32_(0x00001130) /* 05 N_MAX 4400=0x1130 */ _UINT32_(DRV_METROLOGY_CONF_PULSE0_CTRL) /* 06 PULSE0_CTRL */ _UINT32_(DRV_METROLOGY_CONF_PULSE1_CTRL) /* 07 PULSE1_CTRL */ _UINT32_(DRV_METROLOGY_CONF_PULSE2_CTRL) /* 08 PULSE2_CTRL */ _UINT32_(DRV_METROLOGY_CONF_PKT) /* 09 P_K_T */ _UINT32_(DRV_METROLOGY_CONF_PKT) /* 10 Q_K_T */ _UINT32_(DRV_METROLOGY_CONF_PKT) /* 11 I_K_T */ _UINT32_(DRV_METROLOGY_CONF_CREEP_P) /* 12 CREEP_THR_P */ _UINT32_(DRV_METROLOGY_CONF_CREEP_Q) /* 13 CREEP_THR_Q */ _UINT32_(DRV_METROLOGY_CONF_CREEP_I) /* 14 CREEP_THR_I */ _UINT32_(0x00000000) /* 15 POWER_OFFSET_CTRL */ _UINT32_(0x00000000) /* 16 POWER_OFFSET_P */ _UINT32_(0x00000000) /* 17 POWER_OFFSET_Q */ _UINT32_(DRV_METROLOGY_CONF_SWELL) /* 18 SWELL_THR_VA */ _UINT32_(DRV_METROLOGY_CONF_SWELL) /* 19 SWELL_THR_VB */ _UINT32_(DRV_METROLOGY_CONF_SWELL) /* 20 SWELL_THR_VC */ _UINT32_(DRV_METROLOGY_CONF_SAG) /* 21 SAG_THR_VA */ _UINT32_(DRV_METROLOGY_CONF_SAG) /* 22 SAG_THR_VB */ _UINT32_(DRV_METROLOGY_CONF_SAG) /* 23 SAG_THR_VC */ _UINT32_(DRV_METROLOGY_CONF_KI) /* 24 K_IA */ _UINT32_(DRV_METROLOGY_CONF_KV) /* 25 K_VA */ _UINT32_(DRV_METROLOGY_CONF_KI) /* 26 K_IB */ _UINT32_(DRV_METROLOGY_CONF_KV) /* 27 K_VB */ _UINT32_(DRV_METROLOGY_CONF_KI) /* 28 K_IC */ _UINT32_(DRV_METROLOGY_CONF_KV) /* 29 K_VC */ _UINT32_(DRV_METROLOGY_CONF_KI) /* 30 K_IN */ _UINT32_(0x20000000) /* 31 CAL_M_IA */ _UINT32_(0x20000000) /* 32 CAL_M_VA */ _UINT32_(0x20000000) /* 33 CAL_M_IB */ _UINT32_(0x20000000) /* 34 CAL_M_VB */ _UINT32_(0x20000000) /* 35 CAL_M_IC */ _UINT32_(0x20000000) /* 36 CAL_M_VC */ _UINT32_(0x20000000) /* 37 CAL_M_IN */ _UINT32_(0x00000000) /* 38 CAL_PH_IA */ _UINT32_(0x00000000) /* 39 CAL_PH_VA */ _UINT32_(0x00000000) /* 40 CAL_PH_IB */ _UINT32_(0x00000000) /* 41 CAL_PH_VB */ _UINT32_(0x00000000) /* 42 CAL_PH_IC */ _UINT32_(0x00000000) /* 43 CAL_PH_VC */ _UINT32_(0x00000000) /* 44 CAL_PH_IN */ _UINT32_(DRV_METROLOGY_CONF_WAVEFORM) /* 45 CAPTURE_CTRL */ _UINT32_(DRV_METROLOGY_CAPTURE_BUF_SIZE) /* 46 CAPTURE_BUFF_SIZE */ _UINT32_(0x00000000) /* 47 CAPTURE_ADDR */ _UINT32_(0x00000000) /* 48 RESERVED_C48 */ _UINT32_(0x00000000) /* 49 RESERVED_C49 */ _UINT32_(DRV_METROLOGY_CONF_ATS2023) /* 51 ATSENSE_CTRL_20_23 */ _UINT32_(DRV_METROLOGY_CONF_ATS2427) /* 52 ATSENSE_CTRL_24_27 */ _UINT32_(0x00000003) /* 53 ATSENSE_CTRL_28_2B: MSB_MODE=0 OSR=3 */ _UINT32_(0x00000000) /* 54 RESERVED_C54 */ _UINT32_(0x00000000) /* 55 POWER_OFFSET_P_A */ _UINT32_(0x00000000) /* 56 POWER_OFFSET_P_B */ _UINT32_(0x00000000) /* 57 POWER_OFFSET_P_C */ _UINT32_(0x00000000) /* 58 POWER_OFFSET_Q_A */ _UINT32_(0x00000000) /* 59 POWER_OFFSET_Q_B */ _UINT32_(0x00000000) /* 60 POWER_OFFSET_Q_C */ }; DRV_METROLOGY_CONTROL *pSrc; pSrc = DRV_METROLOGY_GetControlByDefault(); ",
							" Remarks None ",
							" DRV_METROLOGY_SetControl Function ",
							" C void DRV_METROLOGY_SetControl (DRV_METROLOGY_CONTROL * pControl); ",
							" Summary Establishes the content of all control registers at once ",
							" Description Overwrite the value of the every control register in the shared memory at once ",
							" Parameters Pointer to data of the new control registers to overwrite the old ones ",
							" Returns None ",
							" Example void APP_METROLOGY_SetControlByDefault(void) { DRV_METROLOGY_CONTROL *pSrc; pSrc = DRV_METROLOGY_GetControlByDefault(); DRV_METROLOGY_SetControl(pSrc); } ",
							" Remarks None ",
							" DRV_METROLOGY_UpdateMeasurements Function ",
							" C void DRV_METROLOGY_UpdateMeasurements(void); ",
							" Summary Updates the RMS values metrology events and AFE energy value ",
							" Description This function is used to obtain the RMS values and the metrology events from the control and accumulator registers of the metrology library AFE energy value is also calculated and updated Control and Accumulator registers are updated by the metrology library application once per an integration period ",
							" Parameters None ",
							" Returns None ",
							" Example case APP_METROLOGY_STATE_RUNNING: { /* Wait for the metrology semaphore to get measurements at the end of the integration period */ OSAL_SEM_Pend( appMetrologySemID OSAL_WAIT_FOREVER); DRV_METROLOGY_UpdateMeasurements(); } ",
							" Remarks This routine should be called after every integration period interrupt captured by the IPC peripheral ",
							" DRV_METROLOGY_GetEnergyValue Function ",
							" C uint32_t DRV_METROLOGY_GetEnergyValue(bool restartEnergy); ",
							" Summary Gets the active energy value ",
							" Description Gets the active energy value Energy value should be previously updated by the DRV_METROLOGY_UpdateMeasurements() routine ",
							" Parameters Param Description restartEnergy Flag to indicate if the energy value should be restarted or accumulated to the previous calculated value ",
							" Returns The active energy value obtained according to the last call to DRV_METROLOGY_UpdateMeasurements() routine ",
							" Example DRV_METROLOGY_UpdateMeasurements(); /* Send new Energy values to the Energy Task */ app_metrologyData queueFree = uxQueueSpacesAvailable(appEnergyQueueID); if (app_metrologyData queueFree) { newMetrologyData energy = DRV_METROLOGY_GetEnergyValue(true); newMetrologyData Pt = DRV_METROLOGY_GetRMSValue(RMS_PT); xQueueSend(appEnergyQueueID newMetrologyData (TickType_t) 0); } else { SYS_CMD_MESSAGE(\"ENERGY Queue is FULL n r\"); } ",
							" Remarks None ",
							" DRV_METROLOGY_GetRMSValue Function ",
							" C uint32_t DRV_METROLOGY_GetRMSValue(DRV_METROLOGY_RMS_TYPE type); ",
							" Summary Gets the last RMS value of the selected measurement type ",
							" Description RMS values should be previously updated by the DRV_METROLOGY_UpdateMeasurements() routine For further information about RMS types refer to DRV_METROLOGY_RMS_TYPE definition ",
							" Parameters Param Description type Indicate what type of measurement is obtained ",
							" Returns The RMS value of the selected type ",
							" Example DRV_METROLOGY_UpdateMeasurements(); /* Send new Energy values to the Energy Task */ app_metrologyData queueFree = uxQueueSpacesAvailable(appEnergyQueueID); if (app_metrologyData queueFree) { newMetrologyData energy = DRV_METROLOGY_GetEnergyValue(true); newMetrologyData Pt = DRV_METROLOGY_GetRMSValue(RMS_PT); xQueueSend(appEnergyQueueID newMetrologyData (TickType_t) 0); } else { SYS_CMD_MESSAGE(\"ENERGY Queue is FULL n r\"); } ",
							" Remarks None ",
							" DRV_METROLOGY_GetRMSSign Function ",
							" C DRV_METROLOGY_RMS_SIGN DRV_METROLOGY_GetRMSSign(DRV_METROLOGY_RMS_TYPE type); ",
							" Summary Gets the sign of the last RMS value of the selected measurement type ",
							" Description RMS sign values should be previously updated by the DRV_METROLOGY_UpdateMeasurements() routine For further information about RMS types refer to DRV_METROLOGY_RMS_TYPE definition ",
							" Parameters Param Description type Indicate what type of measurement is obtained ",
							" Returns The RMS sign of the last RMS value Positive sign is identified as RMS_SIGN_POSITIVE (0) negative sign as RMS_SIGN_NEGATIVE (1) ",
							" Example bool APP_METROLOGY_GetRMS(DRV_METROLOGY_RMS_TYPE rmsId uint32_t * rmsValue DRV_METROLOGY_RMS_SIGN * sign) { if (rmsId = RMS_TYPE_NUM) { return false; } if (sign = NULL) { *sign = DRV_METROLOGY_GetRMSSign(rmsId); } *rmsValue = DRV_METROLOGY_GetRMSValue(rmsId); return true; } ",
							" Remarks None ",
							" DRV_METROLOGY_GetEventsData Function ",
							" C void DRV_METROLOGY_GetEventsData(DRV_METROLOGY_AFE_EVENTS * events); ",
							" Summary Gets the last metrology AFE events data ",
							" Description Events data should be previously updated by the DRV_METROLOGY_UpdateMeasurements() routine For further information about the event data refer to DRV_METROLOGY_AFE_EVENTS definition ",
							" Parameters Param Description events Pointer to the data where the events related information will be written ",
							" Returns None ",
							" Example DRV_METROLOGY_UpdateMeasurements(); /* Send new Events to the Events Task */ app_metrologyData queueFree = uxQueueSpacesAvailable(appEventsQueueID); if (app_metrologyData queueFree) { RTC_TimeGet( newEvent eventTime); DRV_METROLOGY_GetEventsData( newEvent eventFlags); xQueueSend(appEventsQueueID newEvent (TickType_t) 0); } else { SYS_CMD_MESSAGE(\"EVENTS Queue is FULL n r\"); } ",
							" Remarks None ",
							" DRV_METROLOGY_SetConfiguration Function ",
							" C void DRV_METROLOGY_SetConfiguration(DRV_METROLOGY_CONFIGURATION * config); ",
							" Summary Set metrology configuration ",
							" Description This routine is used to configure the metrology library according to the hardware in the input networks as well as the programmable gain of the internal amplifiers This function has to be called before the DRV_METROLOGY_StartCalibration() routine in order to ensure that the proper configuration has been applied before calibrating the system If the programmable gain of the internal amplifiers changes then the metrology library must be reinitialized in order to apply the changes The metrology driver code receives the parameters and writes the proper metrology control registers ",
							" Parameters Param Description config Pointer to configuration data to be used by the metrology library ",
							" Returns None ",
							" Example DRV_METROLOGY_CONFIGURATION newConf; newConf mc = 800; newConf st = SENSOR_CT; newConf freq = 50; newConf gain = GAIN_1; newConf tr = 1000; newConf rl = 3 24; newConf ku = 1651; DRV_METROLOGY_SetConfiguration( newConf); ",
							" Remarks None ",
							" APP_METROLOGY_StartCalibration Function ",
							" C void APP_METROLOGY_StartCalibration(APP_METROLOGY_CALIBRATION * calibration); ",
							" Summary Starts internal calibration process ",
							" Description This routine is used to automatically calibrate the board It requires accurate and stable voltage and current sources and loads which can be provided by a meter test bench like the WECO (or equivalent equipment) This routine must be called after a configuration routine (APP_METROLOGY_SetConfiguration) in order to ensure that the proper configuration has been applied ",
							" Parameters Param Description calibration Pointer to calibration data to be used by the metrology library ",
							" Returns None ",
							" Example APP_METROLOGY_CALIBRATION newCal; /* Calibrate phase A applying 220 00V 5 000A angle=60 00º */ newCal aimVA = 220 00; newCal aimIA = 5 000; newCal angleA = 60 00; APP_METROLOGY_StartCalibration( newCal); ",
							" Remarks None ",
							" DRV_METROLOGY_UpdateCalibration Function ",
							" C void DRV_METROLOGY_UpdateCalibration(void); ",
							" Summary Performs the internal calibration process ",
							" Description Once the calibration process is started by calling DRV_METROLOGY_StartCalibration() routine this funtion has to be called every integration period The metrology driver internally sets the duration of the calibration process as 4 integration periods CAL_M_Ix (X = A B C or N) and CAL_M_Vx (X = A B or C) are used to calibrate the current and voltage magnitudes of phase x Calibration process is iterative using prior or old magnitude calibration factors to perform the next calibration cycle CAL_PH_Ix(x = A B C or N) and CAL_PH_Vx(x = A B or C) are used to align the phase delays between each pair of current and voltage channels and also to optionally equalize the phase delays between voltage channels All phase shift coefficients used by the metrology library must be normalized to equivalent linear-phase shift amounts at 60Hz ",
							" Parameters None ",
							" Returns None ",
							" Example case APP_METROLOGY_STATE_CHECK_CALIBRATION: { /* Wait for the metrology semaphore to get measurements at the end of the integration period */ OSAL_SEM_Pend( appMetrologySemID OSAL_WAIT_FOREVER); DRV_METROLOGY_UpdateCalibration(); if (DRV_METROLOGY_CalibrationIsCompleted()) { bool result = DRV_METROLOGY_GetCalibrationResult(); if (app_metrologyData pCalibrationCallback) { app_metrologyData pCalibrationCallback(result); } app_metrologyData state = APP_METROLOGY_STATE_RUNNING; } vTaskDelay(10 / portTICK_PERIOD_MS); break; } ",
							" Remarks DRV_METROLOGY_CalibrationIsCompleted() routine should be called to detect if the calibration process is finished ",
							" DRV_METROLOGY_CalibrationIsCompleted Function ",
							" C bool DRV_METROLOGY_CalibrationIsCompleted(void); ",
							" Summary Checks if the calibration process is finished ",
							" Description This routine should be called to know if the calibration process is finished ",
							" Parameters None ",
							" Returns True if the calibration process has been completed otherwise False ",
							" Example case APP_METROLOGY_STATE_CHECK_CALIBRATION: { /* Wait for the metrology semaphore to get measurements at the end of the integration period */ OSAL_SEM_Pend( appMetrologySemID OSAL_WAIT_FOREVER); DRV_METROLOGY_UpdateCalibration(); if (DRV_METROLOGY_CalibrationIsCompleted()) { bool result = DRV_METROLOGY_GetCalibrationResult(); if (app_metrologyData pCalibrationCallback) { app_metrologyData pCalibrationCallback(result); } app_metrologyData state = APP_METROLOGY_STATE_RUNNING; } vTaskDelay(10 / portTICK_PERIOD_MS); break; } ",
							" Remarks None ",
							" DRV_METROLOGY_GetCalibrationResult Function ",
							" C bool DRV_METROLOGY_GetCalibrationResult(void); ",
							" Summary Gets the result of the calibration process ",
							" Description This routine should be used to check if the calibration process has been completed successfully ",
							" Parameters None ",
							" Returns True if at least 1 phase has been calibrated successfully otherwise False ",
							" Example case APP_METROLOGY_STATE_CHECK_CALIBRATION: { /* Wait for the metrology semaphore to get measurements at the end of the integration period */ OSAL_SEM_Pend( appMetrologySemID OSAL_WAIT_FOREVER); DRV_METROLOGY_UpdateCalibration(); if (DRV_METROLOGY_CalibrationIsCompleted()) { bool result = DRV_METROLOGY_GetCalibrationResult(); if (app_metrologyData pCalibrationCallback) { app_metrologyData pCalibrationCallback(result); } app_metrologyData state = APP_METROLOGY_STATE_RUNNING; } vTaskDelay(10 / portTICK_PERIOD_MS); break; } ",
							" Remarks None ",
							" DRV_METROLOGY_StartHarmonicAnalysis Function ",
							" C void DRV_METROLOGY_StartHarmonicAnalysis( uint8_t harmonicNum DRV_METROLOGY_HARMONIC *pHarmonicResponse ); ",
							" Summary Starts the harmonic Analysis process ",
							" Description This routine configures the metrology library to enable the harmonics computation and to calculate the data corresponding to the harmonic number n Then the metrology driver receives the data from the metrology library and computes the RMS currents and voltages of the selected harmonic ",
							" Parameters Param Description harmonicNum Harmonic number pHarmonicResponse Pointer to the harmonic analysis struct data to store the harmonic data result ",
							" Returns None ",
							" Example DRV_METROLOGY_HARMONIC harmonicAnalysisResponse; DRV_METROLOGY_StartHarmonicAnalysis(3 harmonicAnalysisResponse); ",
							" Remarks None ",
							" DRV_METROLOGY_HarmonicAnalysisIsRun Function ",
							" C bool DRV_METROLOGY_HarmonicAnalysisIsRun(void); ",
							" Summary Checks if the Harmonic analysis is finished ",
							" Description This routine should be called to know if the Harmonic analysis is finished ",
							" Parameters None ",
							" Returns True if the Harmonic analysis is still running otherwise False ",
							" Example bool APP_METROLOGY_StartHarmonicAnalysis(uint8_t harmonicNum) { if (DRV_METROLOGY_HarmonicAnalysisIsRun()) { return false; } if (app_metrologyData pHarmonicAnalisysCallback == NULL) { return false; } if (app_metrologyData pHarmonicAnalysisResponse == NULL) { return false; } app_metrologyData harmonicAnalysisPending = true; app_metrologyData harmonicAnalysisNum = harmonicNum; DRV_METROLOGY_StartHarmonicAnalysis(harmonicNum app_metrologyData pHarmonicAnalysisResponse); return true; } ",
							" Remarks None ",
							" DRV_METROLOGY_GetHarmonicAnalysisResult Function ",
							" C bool DRV_METROLOGY_GetHarmonicAnalysisResult(void); ",
							" Summary Gets the result of the Harmonic analysis ",
							" Description This routine should be used to check if the Harmonic analysis has been completed successfully ",
							" Parameters None ",
							" Returns True if the Harmonic analysis has been completed successfully otherwise False ",
							" Example case APP_METROLOGY_STATE_CHECK_HARMONIC_ANALYSIS: { if (DRV_METROLOGY_GetHarmonicAnalysisResult()) { app_metrologyData harmonicAnalysisPending = false; app_metrologyData pHarmonicAnalisysCallback(app_metrologyData harmonicAnalysisNum); } app_metrologyData state = APP_METROLOGY_STATE_RUNNING; vTaskDelay(10 / portTICK_PERIOD_MS); break; } ",
							" Remarks None ",
							" DRV_METROLOGY_RESULT Enum ",
							" C typedef enum { /* Operation completed with success */ DRV_METROLOGY_SUCCESS /* Invalid handle or operation failed */ DRV_METROLOGY_ERROR } DRV_METROLOGY_RESULT; ",
							" Summary Result of a Metrology driver interface operation ",
							" Description Identifies the result of certain Metrology driver operations ",
							" DRV_METROLOGY_START_MODE Enum ",
							" C typedef enum { /* Operation completed with success */ DRV_METROLOGY_START_SOFT /* Invalid handle or operation failed */ DRV_METROLOGY_START_HARD } DRV_METROLOGY_START_MODE; ",
							" Summary Describes how is the startup process ",
							" Description HARD mode implies a full reload of Core 1 application SOFT mode does not any effects on Core 1 application ",
							" DRV_METROLOGY_RMS_SIGN Enum ",
							" C typedef enum { /* Positive Value */ RMS_SIGN_POSITIVE = 0 /* Negative Value */ RMS_SIGN_NEGATIVE = 1 } DRV_METROLOGY_RMS_SIGN; ",
							" Summary Describes the sign of some metrology measurements ",
							" Description This quality only affects to some RMS measurements ",
							" DRV_METROLOGY_CALLBACK Typedef ",
							" C typedef void (* DRV_METROLOGY_CALLBACK)(void); ",
							" Summary Pointer to a metrology event handler function ",
							" Description A client must register a pointer using the callback register routines ",
							" Parameters None ",
							" Returns None ",
							" Example static void _APP_METROLOGY_NewIntegrationCallback(void) { if (app_metrologyData state == APP_METROLOGY_STATE_RUNNING) { /* Set the flag to indicate that there is new data to get */ app_metrologyData newIntegrationPeriod = True; } } ( ) /* Set Callback for each metrology integration process */ DRV_METROLOGY_IntegrationCallbackRegister(_APP_METROLOGY_NewIntegrationCallback); ",
							" Remarks None ",
							" DRV_METROLOGY_SENSOR_TYPE Enum ",
							" C typedef enum { /* Current Transformer */ SENSOR_CT = 0 /* Shunt resistor */ SENSOR_SHUNT = 1 /* Rogowski Coil */ SENSOR_ROGOWSKI = 2 SENSOR_NUM_TYPE } DRV_METROLOGY_SENSOR_TYPE; ",
							" Summary Describes the sensor type ",
							" Description The metrology driver has been designed to interface with Current Transformers Rogowski Coils and Shunt Resistors current sensors ",
							" DRV_METROLOGY_GAIN_TYPE Enum ",
							" C typedef enum { GAIN_1 = 0 GAIN_2 = 1 GAIN_4 = 2 GAIN_8 = 3 GAIN_NUM_TYPE } DRV_METROLOGY_GAIN_TYPE; ",
							" Summary Gain selected for use in the ADC front-end ",
							" Description On Current measurement channels gain for voltage is fixed to 1 ",
							" DRV_METROLOGY_PHASE_ID Enum ",
							" C typedef enum { PHASE_A = 1 PHASE_B = 2 PHASE_C = 3 PHASE_T = 5 PHASE_ID_NUM = PHASE_T } DRV_METROLOGY_PHASE_ID; ",
							" Summary Line identifier used in the calibration process ",
							" Description Phase A B and C are used to identify Ua Ub and Uc respectively Phase T includes all phases ",
							" DRV_METROLOGY_CALIBRATION_REFS Struct ",
							" C typedef struct { double aimVA; double aimIA; double angleA; double aimVB; double aimIB; double angleB; double aimVC; double aimIC; double angleC; DRV_METROLOGY_PHASE_ID lineId; } DRV_METROLOGY_CALIBRATION_REFS; ",
							" Summary Specifies the all reference values used for the auto calibration process ",
							" Description Field description: aimVA Rms voltage applied to the voltage input (phase A) Units: Volts aimIA Rms current applied to the current input (phase A) Units: Amps angleA Angle between the voltage and current vectors (phase A) Units: Degrees The value is positive if the current is lagging the voltage aimVB Rms voltage applied to the voltage input (phase B) Units: Volts aimIB Rms current applied to the current input (phase B) Units: Amps angleB Angle between the voltage and current vectors (phase B) Units: Degrees The value is positive if the current is lagging the voltage aimVC Rms voltage applied to the voltage input (phase C) Units: Volts aimIC Rms current applied to the current input (phase C) Units: Amps angleC Angle between the voltage and current vectors (phase C) Units: Degrees The value is positive if the current is lagging the voltage lineId Line identifier of the phase to calibrate ",
							" Remarks None ",
							" DRV_METROLOGY_CALIBRATION Struct ",
							" C typedef struct { DRV_METROLOGY_CALIBRATION_REFS references; uint32_t featureCtrl0Backup; double freq; uint32_t numIntegrationPeriods; uint64_t dspAccIa; uint64_t dspAccIb; uint64_t dspAccIc; uint64_t dspAccIn; uint64_t dspAccUa; uint64_t dspAccUb; uint64_t dspAccUc; uint64_t dspAccUn; int64_t dspAccPa; int64_t dspAccPb; int64_t dspAccPc; int64_t dspAccQa; int64_t dspAccQb; int64_t dspAccQc; uint8_t harmonicOrder; bool running; bool result; } DRV_METROLOGY_CALIBRATION; ",
							" Summary Specifies all data internally needed for the auto calibration process ",
							" Description Field description: references Calibration references Client must be set the references before starting the calibration process featureCtrl0Backup Stores a backup value to restore FeatureCtrl0 register after finishing the calibration process freq Stores the mains frequency passed as parameter in the DRV_METROLOGY_SetConfiguration() routine numIntegrationPeriods Number of integration periods needed to complete the calibration process It is set internally to 4 dspAccIa Field internally used to perform the calibration process dspAccIb Field internally used to perform the calibration process dspAccIc Field internally used to perform the calibration process dspAccIn Field internally used to perform the calibration process dspAccUa Field internally used to perform the calibration process dspAccUb Field internally used to perform the calibration process dspAccUc Field internally used to perform the calibration process dspAccUn Field internally used to perform the calibration process dspAccPa Field internally used to perform the calibration process dspAccPb Field internally used to perform the calibration process dspAccPc Field internally used to perform the calibration process dspAccQa Field internally used to perform the calibration process dspAccQb Field internally used to perform the calibration process dspAccQc Field internally used to perform the calibration process running Flag used to check if the calibration process was completed result Flag used to check if the calibration process has been successful ",
							" Remarks None ",
							" DRV_METROLOGY_AFE_EVENTS Struct ",
							" C typedef struct { uint32_t paDir : 1; uint32_t pbDir : 1; uint32_t pcDir : 1; uint32_t ptDir : 1; uint32_t qaDir : 1; uint32_t qbDir : 1; uint32_t qcDir : 1; uint32_t qtDir : 1; uint32_t sagA : 1; uint32_t sagB : 1; uint32_t sagC : 1; uint32_t reserved1 : 1; uint32_t swellA : 1; uint32_t swellB : 1; uint32_t swellC : 1; uint32_t reserved2 : 17; } DRV_METROLOGY_AFE_EVENTS; ",
							" Summary dentifies all events related to metrology library ",
							" Description Field description: paDir Identifies the sign of the active power in channel A \"1\" means a negative value \"0\" is a positive value pbDir Identifies the sign of the active power in channel B \"1\" means a negative value \"0\" is a positive value pcDir Identifies the sign of the active power in channel C \"1\" means a negative value \"0\" is a positive value ptDir Identifies the sign of the total active power in all channels \"1\" means a negative value \"0\" is a positive value qaDir Identifies the sign of the reactive power in channel A \"1\" means a negative value \"0\" is a positive value qbDir Identifies the sign of the reactive power in channel B \"1\" means a negative value \"0\" is a positive value qcDir Identifies the sign of the reactive power in channel C \"1\" means a negative value \"0\" is a positive value qtDir Identifies the sign of the total reactive power in all channels \"1\" means a negative value \"0\" is a positive value sagA Voltage Sag Detected Flag for Channel A \"1\" means that voltage sag is detected sagB Voltage Sag Detected Flag for Channel B \"1\" means that voltage sag is detected sagC Voltage Sag Detected Flag for Channel C \"1\" means that voltage sag is detected swellA Voltage Swell Detected Flag for Channel A \"1\" means that voltage Swell is detected swellB Voltage Swell Detected Flag for Channel B \"1\" means that voltage Swell is detected swellC Voltage Swell Detected Flag for Channel C \"1\" means that voltage Swell is detected ",
							" Remarks None ",
							" DRV_METROLOGY_HARMONIC Struct ",
							" C typedef struct { double Irms_A_m; double Irms_B_m; double Irms_C_m; double Irms_N_m; double Vrms_A_m; double Vrms_B_m; double Vrms_C_m; } DRV_METROLOGY_HARMONIC; ",
							" Summary Identifies the result of the Harmonic Analysis process ",
							" Description Field description: Irms_A_m RMS current value obtained as the result of last the harmonic analysis regarding channel A Irms_B_m RMS current value obtained as the result of last the harmonic analysis regarding channel B Irms_C_m RMS current value obtained as the result of last the harmonic analysis regarding channel C Irms_N_m RMS current value obtained as the result of last the harmonic analysis regarding neutral channel Vrms_A_m RMS voltage value obtained as the result of last the harmonic analysis regarding channel A Vrms_B_m RMS voltage value obtained as the result of last the harmonic analysis regarding channel B Vrms_C_m RMS voltage value obtained as the result of last the harmonic analysis regarding channel C ",
							" Remarks None ",
							" DRV_METROLOGY_RMS_TYPE Enum ",
							" C typedef enum { RMS_UA = 0 RMS_UB RMS_UC RMS_IA RMS_IB RMS_IC RMS_INI RMS_INM RMS_INMI RMS_PT RMS_PA RMS_PB RMS_PC RMS_QT RMS_QA RMS_QB RMS_QC RMS_ST RMS_SA RMS_SB RMS_SC RMS_FREQ RMS_ANGLEA RMS_ANGLEB RMS_ANGLEC RMS_ANGLEN RMS_TYPE_NUM } DRV_METROLOGY_RMS_TYPE; ",
							" Summary Identifies the all RMS types of measurements ",
							" Description RMS values are calculated including all harmonics of each phase where: U = Voltage RMS value I = Current RMS value P = Active power RMS value Q = Reactive power RMS value S = Aparent power RMS value FREQ = Frequency of the line voltage fundamental harmonic component determined by the Metrology library using the dominant phase ANGLE = Angle between the voltage and current vectors ",
							" DRV_METROLOGY_AFE_DATA Struct ",
							" C typedef struct { uint32_t energy; DRV_METROLOGY_AFE_EVENTS afeEvents; uint32_t RMS[RMS_TYPE_NUM]; } DRV_METROLOGY_AFE_DATA; ",
							" Summary Identifies the data calculated from the metrology AFE measurements ",
							" Description Field description: energy Active energy calculated value afeEvents AFE events data RMS RMS calculated values ",
							" Remarks None ",
							" DRV_METROLOGY_CONFIGURATION Struct ",
							" C typedef struct { uint32_t mc; double freq; double tr; double rl; uint32_t ku; DRV_METROLOGY_SENSOR_TYPE st; DRV_METROLOGY_GAIN_TYPE gain; } DRV_METROLOGY_CONFIGURATION; ",
							" Summary Identifies values needed to set different metrology configurations ",
							" Description Field description: mc Meter Constant (amount of energy signified by one output pulse) Units: pulses/kWh (active energy) pulses/kVARh (reactive energy) or pulses/kAmp2-h (amp square) freq Mains frequency Units: Hz tr In the case of a current transformer this is the current transformer ratio In the case of a Rogowski Coil this is the current sensitivity (units: uV/A) at the main frequency specified in “Frequency” parameter rl In the case of current transformer this is the resistor load or burden resistor (units: Ω) In the case of shunt resistor this is the shunt resistor value (units: uΩ) ku Voltage divider ratio st Sensor Type Refer to DRV_METROLOGY_SENSOR_TYPE gain Programmable Gain Amplifier of the AFE (analog front end) Refer to DRV_METROLOGY_GAIN_TYPE ",
							" Remarks None ",
							" DRV_METROLOGY_STATE Enum ",
							" C typedef enum { DRV_METROLOGY_STATE_HALT = STATUS_STATUS_HALT DRV_METROLOGY_STATE_RESET = STATUS_STATUS_RESET DRV_METROLOGY_STATE_INIT_DSP = STATUS_STATUS_INIT_DSP DRV_METROLOGY_STATE_DSP_READY = STATUS_STATUS_DSP_READY DRV_METROLOGY_STATE_INIT_ATSENSE = STATUS_STATUS_INIT_ATSENSE DRV_METROLOGY_STATE_ATSENSE_READY = STATUS_STATUS_ATSENSE_READY DRV_METROLOGY_STATE_READY = STATUS_STATUS_READY DRV_METROLOGY_STATE_SETTLING = STATUS_STATUS_DSP_SETTLING DRV_METROLOGY_STATE_RUNNING = STATUS_STATUS_DSP_RUNNING } DRV_METROLOGY_STATE; ",
							" Summary Identifies the state of the metrology library ",
							" Description For further information about the state diagram refer to DRV_METROLOGY_GetState() routine ",
							" DRV_METROLOGY_INIT Struct ",
							" C typedef struct { uint32_t regBaseAddress; uint32_t binStartAddress; uint32_t binEndAddress; } DRV_METROLOGY_INIT; ",
							" Summary Defines the data required to initialize the Metrology driver ",
							" Description Field description: regBaseAddress Base Address for Metrology registers binStartAddress Start Address where Metrology library application file is located binEndAddress End Address where Metrology library application file is located ",
							" Remarks None ",
							" Service Libraries The Smart Energy Services are software components designed to be used in conjuction with Smart Energy Drivers in order to add specific functionalities In the Smart Energy applications there are examples of use of all of these services ",
							" PLC PHY Coupling Service The PLC PHY Coupling service can be used in conjuction with a PLC Driver (PHY or G3 MAC RT) to facilitate the configuration of the PLC Transmission Coupling PHY parameters (PIBs) If the application/middleware using the PLC Driver does not need to perform PLC transmissions e g PHY sniffer this service is not needed ",
							" How the Library Works The PLC Physical Layer (PHY) implements some transmission capabilities with the following purposes: Comply with regulatory requirements Meet power injection and signal quality requirements Compensate nonlinearities of the power supply and coupling harware designs related to components' tolerances and PCB layout Support different PLC devices (PL360/PL460) and transmission coupling harware designs These capabilities are configured through PHY parameters (PIBs) The PLC PHY Coupling service offers a simple interface to set these PIBs whose values can be configured via MCC  The default PLC PHY Coupling configuration values are optimized for the Evaluation Kits calibrated for each transmission coupling harware reference design and working band For custom designs different from the Microchip reference designs it is recommended to recalibrate the PLC PHY Coupling configuration values To help in this calibration process of the PLC PHY Microchip provides the PHY Calibration Tool an open source application developed with Python® For further information contact with the Smart Energy support team or refer to the PL360 Physical Calibration user guide ",
							" PLC PHY Transmission Capabilities Transmission capabilities implemented in the PLC PHY: Transmission Modes Equalization Dynamic adaptation ",
							" Transmission Modes Three transmission modes are available in the PLC PHY (PIB PLC_ID_CFG_IMPEDANCE): Tx Mode PLC_ID_CFG_IMPEDANCE value Description HIGH 0 Optimized for high impedance (typically Z 20 Ω) LOW 1 Optimized for low impedance In the current implementations this mode is not used VLOW 2 Optimized for very low impedance (typically Z 10 Ω) Transmission digital gain and equalization are independentely configured for each Tx mode Since each Tx mode is optimized for an impedance range the PLC PHY is also capable of selecting automatically the Tx mode based on the estimated load impedance This allows to achieve a good tradeoff between transmission performance efficiency signal quality and spectrum ripple for a wider range of load impedances ",
							" Equalization Usually the transmitted signal has a non-flat frequency spectrum inside the working band (ripple) because of the frequency response of the external analog filter (discrete components) This ripple can be reduced by equalizing the transmitted signal The PLC PHY can perform this equalization by means of digital signal pre-distortion A specific gain factor is assigned to each carrier in the working band compensating the frequency response of the external analog filter For different equalization configurations the average signal level in the whole working band is maintained (pre-distorsion gain reduction is compensated) The external analog filter may have different frequency response for different load impedances For that reason equalization is independentely configured for each Tx mode The following figure shows an example of equalization in the G3-PLC CENELEC-A band It shows how the ripple is reduced after equalization keeping the same signal average in band (overlapped curves) Example of Equalization in G3-PLC CENELEC-A band Equalization ",
							" Dynamic adaptation The PLC PHY can modify the Tx mode and digital gain dynamically after each transmission Three automatic modes are available (PIB PLC_ID_CFG_AUTODETECT_IMPEDANCE): Auto Mode PLC_ID_CFG_AUTODETECT_IMPEDANCE value Tx Mode Tx Gain OFF 0 Fixed Fixed ON 1 Dynamic Dynamic AGC 2 Fixed Dynamic The PLC Device receives its own transmitted signal and the RMS value is computed by the PHY ( rmsCalc in DRV_PLC_PHY_TRANSMISSION_CFM_OBJ) This allows to estimate the load impedance and adjust the Tx mode/gain for the next transmission For dynamic Tx gain a target RMS is configured and the digital Tx gain is adjusted (between configurable minumum and maximum) after each transmission The objective is to try to inject the same signal level for different load impedances For lower load impedances the Tx gain will be increased to inject the required signal level while for higher load impedances the Tx gain will be reduced to reduce power consumption For dynamic Tx mode RMS thresholds are configured to switch from one Tx mode to another The objective is to try to use the most efficient Tx mode depending on the load impedance The thresholds should be configured using an hystheresis window to avoid undesirable behaviours The following figure illustrates the interaction between the different functionalities described above: PLC PHY Transmission Capabilities abstraction model CalibrationSteps_reduced The following figure shows an example of the injected signal level in terms of the load impedance (from 0 to 100 Ω) for Auto Mode OFF (HIGH/VLOW modes) and ON: Example of injected signal level in terms of load impedance TxStateThresholdsAndHysteresisWindow ",
							" PLC PHY Coupling parameters The following table sumarizes the PLC PHY PIBs related to transmission configuration coupling hardware design and PLC device used: PHY PIB Description PLC_ID_CFG_IMPEDANCE Tx Mode PLC_ID_CFG_AUTODETECT_IMPEDANCE Auto Tx Mode Enable/disable dynamic Tx mode/gain PLC_ID_PREDIST_COEF_TABLE_HI Pre-distorsion table for equalization in HIGH mode PLC_ID_PREDIST_COEF_TABLE_VLO Pre-distorsion table for equalization in VLOW mode PLC_ID_PREDIST_COEF_TABLE_HI_2 Pre-distorsion table for equalization in HIGH mode (only for PRIME Double Channel) PLC_ID_PREDIST_COEF_TABLE_VLO_2 Pre-distorsion table for equalization in VLOW mode (only for PRIME Double Channel) PLC_ID_GAIN_TABLE_HI Digital gain configuration for HIGH mode PLC_ID_GAIN_TABLE_VLO Digital gain configuration for VLOW mode PLC_ID_CURRENT_GAIN Indicates the digital gain for the next/current transmission It may vary between transmissions if dynamic Tx gain is enabled PLC_ID_CORRECTED_RMS_CALC Indicates the RMS value of the last transmission compensated with the dynamic Tx gain factor applied This is the value used in dynamic adaptation algorithms PLC_ID_NUM_TX_LEVELS Number of transmission attenuation levels ( attenuation field in DRV_PLC_PHY_TRANSMISSION_OBJ ) supporting dynamic mode/gain PLC_ID_MAX_RMS_TABLE_HI Target RMS values in HIGH mode for dynamic Tx gain PLC_ID_MAX_RMS_TABLE_VLO Target RMS values in VLOW mode for dynamic Tx gain PLC_ID_THRESHOLDS_TABLE_HI Threshold RMS values in HIGH mode for dynamic Tx mode PLC_ID_THRESHOLDS_TABLE_VLO Threshold RMS values in VLOW mode for dynamic Tx mode PLC_ID_IC_DRIVER_CFG PLC Device (PL360/PL460) and branch configuration PLC_ID_DACC_TABLE_CFG PLC Device's DACC peripheral register values ",
							" Using The Library The PLC PHY Coupling Service allows a PLC Driver's client to configure the PHY PIBs related to: PLC Transceiver used (PL360/PL460) Transmission hardware coupling design Transmission digital gain and equalization Calibration values for dynamic capabilities If the application/middleware using the PLC Driver does not need to perform PLC transmissions e g PHY sniffer this service is not needed The API is sligthly different depending on the PLC protocol used by the PLC Driver (G3-PLC or PRIME) ",
							" Using The Library (G3-PLC) For G3-PLC SRV_PCOUP_Set_Config has to be called once the PLC Driver is ready (binary loaded to PLC Device) and before any transmission is requested Each transmission branch (main or auxiliary) is associated to a G3-PLC PHY band For multi-band applications (one PLC PHY binary for each band) SRV_PCOUP_Set_Config has to be called every time the band is changed (PLC PHY binary reloaded) G3-PLC Example application using PLC PHY Coupling service #include \"definitions h\" typedef enum { APP_STATE_INIT APP_STATE_OPEN APP_STATE_READY APP_STATE_ERROR } APP_STATE; typedef struct { APP_STATE state; SRV_PLC_PCOUP_BRANCH plcBranch; DRV_HANDLE drvPlcHandle; } APP_DATA; APP_DATA appData; static void APP_PLC_DataCfmCb(DRV_PLC_PHY_TRANSMISSION_CFM_OBJ *cfmObj uintptr_t context) { /* Do whatever with transmission confirm */ } static void APP_PLC_DataIndCb(DRV_PLC_PHY_RECEPTION_OBJ *indObj uintptr_t context) { /* Do whatever with received frame indication */ } void APP_Initialize (void) { /* Initialize application state */ appData state = APP_STATE_INIT; /* Get the default transmission branch */ appData plcBranch = SRV_PCOUP_Get_Default_Branch(); } void APP_Tasks (void) { /* Check the application's current state */ switch (appData state) { case APP_STATE_INIT: { /* Open PLC driver */ appData drvPlcHandle = DRV_PLC_PHY_Open(DRV_PLC_PHY_INDEX NULL); if (appData drvPlcHandle = DRV_HANDLE_INVALID) { /* Register PLC callbacks */ DRV_PLC_PHY_DataIndCallbackRegister(appData drvPlcHandle APP_PLC_DataIndCb DRV_PLC_PHY_INDEX); DRV_PLC_PHY_DataCfmCallbackRegister(appData drvPlcHandle APP_PLC_DataCfmCb DRV_PLC_PHY_INDEX); /* Enable PLC Transmission */ DRV_PLC_PHY_Enable_TX(appData drvPlcHandle true); /* Go to next state to wait until PLC Driver is ready */ appData state = APP_STATE_OPEN; } else { appData state = APP_PLC_STATE_ERROR; } break; } case APP_STATE_OPEN: { /* Check PLC Driver status */ if (DRV_PLC_PHY_Status(DRV_PLC_PHY_INDEX) == SYS_STATUS_READY) { /* Apply PLC PHY Coupling configuration */ SRV_PCOUP_Set_Config(appData drvPlcHandle appData plcBranch); /* At this point the PLC Transceiver is ready for transmission */ appData state = APP_STATE_READY; } } break; case APP_STATE_READY: { /* Do whatever request transmission or wait to receive something */ break; } /* The default state should never be executed */ default: { /* Handle error in application's state machine */ break; } } } ",
							" Using The Library (PRIME) For PRIME SRV_PCOUP_Set_Channel_Config has to be called once the PLC Driver is ready (binary loaded to PLC Device) and before any transmission is requested Additionally SRV_PCOUP_Set_Channel_Config has to be called every time the PRIME channel is changed (PLC_ID_CHANNEL_CFG PIB) PRIME Example application using PLC PHY Coupling service #include \"definitions h\" typedef enum { APP_STATE_INIT APP_STATE_OPEN APP_STATE_READY APP_STATE_ERROR } APP_STATE; typedef struct { APP_STATE state; DRV_PLC_PHY_CHANNEL plcChannel; DRV_HANDLE drvPlcHandle; } APP_DATA; APP_DATA appData; static void APP_PLC_DataCfmCb(DRV_PLC_PHY_TRANSMISSION_CFM_OBJ *cfmObj uintptr_t context) { /* Do whatever with transmission confirm */ } static void APP_PLC_DataIndCb(DRV_PLC_PHY_RECEPTION_OBJ *indObj uintptr_t context) { /* Do whatever with received frame indication */ } static void APP_PLC_SetChannel() { DRV_PLC_PHY_PIB_OBJ pibObj; /* Set channel configuration */ pibObj id = PLC_ID_CHANNEL_CFG; pibObj length = 1; pibObj pData = appData plcChannel; DRV_PLC_PHY_PIBSet(appData drvPlcHandle pibObj); /* Apply PLC PHY Coupling configuration for the selected channel */ SRV_PCOUP_Set_Channel_Config(appPlc drvPlcHandle appData plcChannel); } void APP_Initialize (void) { /* Initialize application state */ appData state = APP_STATE_INIT; /* Get the default PRIME channel */ appData plcChannel = SRV_PCOUP_Get_Default_Channel(); } void APP_Tasks (void) { /* Check the application's current state */ switch (appData state) { case APP_STATE_INIT: { /* Open PLC driver */ appData drvPlcHandle = DRV_PLC_PHY_Open(DRV_PLC_PHY_INDEX NULL); if (appData drvPlcHandle = DRV_HANDLE_INVALID) { /* Register PLC callbacks */ DRV_PLC_PHY_DataIndCallbackRegister(appData drvPlcHandle APP_PLC_DataIndCb DRV_PLC_PHY_INDEX); DRV_PLC_PHY_DataCfmCallbackRegister(appData drvPlcHandle APP_PLC_DataCfmCb DRV_PLC_PHY_INDEX); /* Enable PLC Transmission */ DRV_PLC_PHY_Enable_TX(appData drvPlcHandle true); /* Go to next state to wait until PLC Driver is ready */ appData state = APP_STATE_OPEN; } else { appData state = APP_PLC_STATE_ERROR; } break; } case APP_STATE_OPEN: { /* Check PLC Driver status */ if (DRV_PLC_PHY_Status(DRV_PLC_PHY_INDEX) == SYS_STATUS_READY) { /* Set channel and PLC PHY Coupling configuration */ APP_PLC_SetChannel(); /* At this point the PLC Transceiver is ready for transmission */ appData state = APP_STATE_READY; } } break; case APP_STATE_READY: { /* Do whatever request transmission or wait to receive something */ break; } /* The default state should never be executed */ default: { /* Handle error in application's state machine */ break; } } } ",
							" Configuring The Library PLC PHY Coupling Service can be configured via MCC Alternatevely the generated source/header files can be modified for custom configuration ",
							" Configuring via MCC The following snapshots show the MCC configuration window for PLC PHY Coupling Service and brief description The configuration options will vary depending on the PLC protocol used by the PLC Driver (G3 or PRIME) The configuration dynamic values (purple colour) will be updated depending on PLC Driver Mode and PLC Coupling Settings in PLC Driver MCC configuration in order to apply the configuration/calibration values for Evaluation Kits and/or reference designs ",
							" G3 Configuration Options PLC PHY Coupling configuration options (G3) SRV_PCOUP_mcc_g3 Transmission Branches: Available only if G3 selected as PLC Profile in PLC PHY Driver MCC configuration or G3 MAC RT Driver used Main Transmission branch: PLC PHY Coupling configuration for Main Transmission branch Auxiliary Transmission branch: PLC PHY Coupling configuration for Auxiliary Transmission branch Available only if Multiband enabled in PLC Driver MCC configuration Each transmission branch is configured inependentely In addition to Common Configuration Options the following options are available for each transmission branch: G3-PLC PHY Band: Indicates the frequency band associated to the corresponding transmission branch as selected in PLC Driver MCC configuration PLC DACC peripheral settings: PLC Device's DACC peripheral register values (PHY PIB PLC_ID_DACC_TABLE_CFG) These values should not be modified by the user ",
							" PRIME Configuration Options PLC PHY Coupling configuration options (PRIME) SRV_PCOUP_mcc_prime Transmission Channels: Available only if PRIME is selected as PLC Profile in PLC PHY Driver PLC DACC peripheral settings (Channel 1): PLC DACC peripheral settings (Channel 2 - Channel 8): PLC DACC peripheral settings (Double Channel): PLC Device's DACC peripheral register values (PHY PIB PLC_ID_DACC_TABLE_CFG) for single channel 1 / single channels 2 to 8 / double channels These values should not be modified by the user Channel \"i\": PLC PHY Coupling configuration for single channel \"i\" Available only if Channel \"i\" is enabled in PLC PHY Driver MCC configuration Channels \"i - j\": PLC PHY Coupling configuration for double channel \"i - j\" (two consecutive channels) Available only if Channels \"i - j\" is enabled in PLC PHY Driver MCC configuration Each channel is configured inependentely Common Configuration Options are available for each enabled channel ",
							" Common Configuration Options Number of TX levels: PHY PIB: PLC_ID_NUM_TX_LEVELS Number of transmission attenuation levels supporting dynamic capabilities G3: transmission attenuation levels in 3 dB steps PRIME: transmission attenuation levels in 1 dB steps Target RMS configuration options SRV_PCOUP_mcc_target_rms Target RMS values in HIGH mode for dynamic Tx gain: PHY PIB: PLC_ID_MAX_RMS_TABLE_HI RMS_HIGH_x: Target RMS values in HIGH Tx mode for transmission attenuation level \"x\" Target RMS values in VLOW mode for dynamic Tx gain: PHY PIB: PLC_ID_MAX_RMS_TABLE_VLO RMS_VLOW_x: Target RMS values in VLOW Tx mode for transmission attenuation level \"x\" Threshold RMS configuration options SRV_PCOUP_mcc_threshold_rms Threshold RMS values in HIGH mode for dynamic Tx mode: PHY PIB: PLC_ID_THRESHOLDS_TABLE_HI THRESHOLD_HIGH_LOW_x: Threshold RMS values to update Tx mode from HIGH to LOW for transmission attenuation level \"x\" Set to 0 to disable THRESHOLD_HIGH_VLOW_x: Threshold values to update Tx mode from HIGH to VLOW for transmission attenuation level \"x\" Set to 0 to disable Threshold RMS values in VLOW mode for dynamic Tx mode: PHY PIB: PLC_ID_THRESHOLDS_TABLE_VLO THRESHOLD_VLOW_LOW_x: Threshold values to update Tx mode from VLOW to LOW for transmission attenuation level \"x\" Set to 0 to disable THRESHOLD_VLOW_HIGH_x: Threshold values to update Tx mode from VLOW to HIGH for transmission attenuation level \"x\" Set to maximum value to disable Transmission digital gain configuration options SRV_PCOUP_mcc_gain Tx gain values for HIGH mode: PHY PIB: PLC_ID_GAIN_TABLE_HI GAIN_HIGH_INI: GAIN_HIGH_MIN: GAIN_HIGH_MAX: Initial/minimum/maximum transmission digital gain value for HIGH Tx mode Set all to same value to disable dynamic Tx gain for HIGH Tx mode Tx gain values for VLOW mode: PHY PIB: PLC_ID_GAIN_TABLE_VLO GAIN_VLOW_INI: GAIN_VLOW_MIN: GAIN_VLOW_MAX: Initial/minimum/maximum transmission digital gain value for VLOW Tx mode Set all to same value to disable dynamic Tx gain for VLOW Tx mode PLC Line Driver settings: PHY PIB: PLC_ID_IC_DRIVER_CFG PLC Device and branch configuration One value for PL360 three values for PL460: 0: PL360 5: PL460 using Main Transmission Branch with a single external filter When transmitting both ASO pins are activated simultaneously 7: PL460 using Main Transmission Branch with two external filters When transmitting ASO0 is activated for HIGH Tx mode while ASO1 is activated for LOW/VLOW Tx modes 8: PL460 using Auxiliary Transmission Branch ",
							" Modifying Generated Source Code PLC PHY Coupling Service generates the srv_pcoup c and srv_pcoup h files In the header file there are definition macros with the values configured via MCC The user can modify these files instead of using MCC interface In the current version this is the only method to customize Tx Equalization values (not supported in MCC configuration window for PLC PHY Coupling Service) ",
							" Library Interface The PLC PHY Coupling service library interface depends on the PLC protocol used by the PLC Driver (G3-PLC or PRIME) ",
							" Library Interface (G3-PLC) If the PLC Driver uses G3-PLC PHY the PLC PHY Coupling service library provides the following interfaces: Functions Name Description SRV_PCOUP_Get_Config Get the PLC PHY Coupling parameters for the specified transmission branch SRV_PCOUP_Set_Config Set the PLC PHY Coupling parameters for the specified transmission branch SRV_PCOUP_Get_Default_Branch Get the default branch of the PLC transmission coupling SRV_PCOUP_Get_Default_Branch Get the G3-PLC PHY band associated to the specified transmission branch Data types and constants Name Type Description SRV_PLC_PCOUP_BRANCH Enum List of possible transmission branches SRV_PLC_PCOUP_DATA Struct PLC PHY Coupling data ",
							" SRV_PCOUP_Get_Config Function ",
							" C SRV_PLC_PCOUP_DATA * SRV_PCOUP_Get_Config(SRV_PLC_PCOUP_BRANCH branch); ",
							" Summary Get the PLC PHY Coupling parameters for the specified transmission branch ",
							" Description This function allows to get the PLC PHY Coupling parameters for the specified transmission branch These parameters can be sent to the PLC device through PLC Driver PIB interface ( DRV_PLC_PHY_PIBSet or DRV_G3_MACRT_PIBSet ) ",
							" Precondition None ",
							" Parameters Param Description branch Transmission branch ( SRV_PLC_PCOUP_BRANCH Enum ) for which the parameters are requested ",
							" Returns Pointer to SRV_PLC_PCOUP_DATA Struct containing the PLC PHY Coupling parameters if branch parameter is valid NULL if branch parameter is not valid ",
							" Example SRV_PLC_PCOUP_DATA *pCoupValues; pCoupValues = SRV_PCOUP_Get_Config(SRV_PLC_PCOUP_MAIN_BRANCH); ",
							" Remarks This function is only generated by MCC if the PLC Driver uses G3-PLC PHY If SRV_PCOUP_Set_Config function is used to set the PLC PHY Coupling parameters this function is not needed ",
							" SRV_PCOUP_Set_Config Function ",
							" C bool SRV_PCOUP_Set_Config(DRV_HANDLE handle SRV_PLC_PCOUP_BRANCH branch); ",
							" Summary Set the PLC PHY Coupling parameters for the specified transmission branch ",
							" Description This function allows to set the PLC PHY Coupling parameters for the specified transmission branch using the PLC Driver PIB interface ( DRV_PLC_PHY_PIBSet or DRV_G3_MACRT_PIBSet ) ",
							" Precondition The PLC driver's open routine ( DRV_PLC_PHY_Open or DRV_G3_MACRT_Open ) must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the PLC driver's open routine branch Transmission branch ( SRV_PLC_PCOUP_BRANCH Enum ) for which the parameters will be set ",
							" Returns true Successful configuration false if branch parameter is not valid if there is an error when using the PLC Driver PIB interface ",
							" Example // 'handle' returned from DRV_PLC_PHY_Open or DRV_G3_MACRT_Open bool result; result = SRV_PCOUP_Set_Config(handle SRV_PLC_PCOUP_MAIN_BRANCH); ",
							" Remarks This function is only generated by MCC if the PLC Driver uses G3-PLC PHY ",
							" SRV_PCOUP_Get_Default_Branch Function ",
							" C SRV_PLC_PCOUP_BRANCH SRV_PCOUP_Get_Default_Branch( void ); ",
							" Summary Get the default branch of the PLC transmission coupling ",
							" Description This function allows to get the tranmission branch used by default which is configured through MCC of PLC Driver ",
							" Precondition None ",
							" Parameters None ",
							" Returns Default transmission branch ( SRV_PLC_PCOUP_BRANCH Enum ) ",
							" Example // 'handle' returned from DRV_PLC_PHY_Open or DRV_G3_MACRT_Open SRV_PLC_PCOUP_BRANCH plcDefaultBranch; plcDefaultBranch = SRV_PCOUP_Get_Default_Branch(); SRV_PCOUP_Set_Config(handle plcDefaultBranch); ",
							" Remarks This function is only generated by MCC if the PLC Driver uses G3-PLC PHY ",
							" SRV_PCOUP_Get_Phy_Band Function ",
							" C uint8_t SRV_PCOUP_Get_Phy_Band(SRV_PLC_PCOUP_BRANCH branch); ",
							" Summary Get the G3-PLC PHY band associated to the specified transmission branch ",
							" Description This function allows to get the G3-PLC PHY band associated to the specified transmission branch ",
							" Precondition None ",
							" Parameters Param Description branch Transmission branch ( SRV_PLC_PCOUP_BRANCH Enum ) for which the PHY band is requested ",
							" Returns G3-PLC PHY band associated to the specified transmission branch (see drv_plc_phy_comm h or drv_g3_macrt_comm h ): 0: G3_CEN_A 1: G3_CEN_B 2: G3_FCC 3: G3_ARIB 0xFF: G3_INVALID (if transmission branch is not valid) ",
							" Example uint8_t phyBand; phyBand = SRV_PCOUP_Get_Phy_Band(SRV_PLC_PCOUP_MAIN_BRANCH); if (phyBand == G3_CEN_A) { // G3 CEN-A band } ",
							" Remarks This function is only generated by MCC if the PLC Driver uses G3-PLC PHY ",
							" SRV_PLC_PCOUP_BRANCH Enum ",
							" C typedef enum { /* Main Transmission Branch */ SRV_PLC_PCOUP_MAIN_BRANCH /* Auxiliary Transmission Branch */ SRV_PLC_PCOUP_AUXILIARY_BRANCH } SRV_PLC_PCOUP_BRANCH; ",
							" Summary List of possible transmission branches ",
							" Description This type defines the possible values of PLC transmission coupling branches ",
							" Remarks This type is only generated by MCC if the PLC Driver uses G3-PLC PHY ",
							" SRV_PLC_PCOUP_DATA Struct ",
							" C typedef struct { /* Target RMS values in HIGH mode for dynamic Tx gain */ uint32_t rmsHigh[SRV_PCOUP_MAX_NUM_TX_LEVELS]; /* Target RMS values in VLOW mode for dynamic Tx gain */ uint32_t rmsVLow[SRV_PCOUP_MAX_NUM_TX_LEVELS]; /* Threshold RMS values in HIGH mode for dynamic Tx mode */ uint32_t thrsHigh[SRV_PCOUP_MAX_NUM_TX_LEVELS 1]; /* Threshold RMS values in VLOW mode for dynamic Tx mode */ uint32_t thrsVLow[SRV_PCOUP_MAX_NUM_TX_LEVELS 1]; /* Values for configuration of PLC DACC peripheral according to hardware coupling design and PLC device (PL360/PL460) */ uint32_t daccTable[17]; /* Pointer to Tx equalization coefficients table in HIGH mode There is one coefficient for each carrier in the used band */ const uint16_t * equHigh; /* Pointer to Tx equalization coefficients table in VLOW mode There is one coefficient for each carrier in the used band */ const uint16_t * equVlow; /* Tx gain values for HIGH mode [HIGH_INI HIGH_MIN HIGH_MAX] */ uint16_t gainHigh[3]; /* Tx gain values for VLOW mode [VLOW_INI VLOW_MIN VLOW_MAX] */ uint16_t gainVLow[3]; /* Number of Tx attenuation levels (3 dB step) suppoting dynamic Tx mode */ uint8_t numTxLevels; /* Size of Tx equalization coefficients table in bytes */ uint8_t equSize; /* Configuration of the PLC Tx Line Driver according to hardware coupling design and PLC device (PL360/PL460) */ uint8_t lineDrvConf; } SRV_PLC_PCOUP_DATA; ",
							" Summary PLC PHY Coupling data ",
							" Description This structure contains all the data required to set the PLC PHY Coupling parameters for a specific transmission branch (associated to a G3-PLC PHY band) ",
							" Remarks This type is only generated by MCC if the PLC Driver uses G3-PLC PHY Equalization coefficients are not stored in the structure just pointers to arrays were they are actually stored This allows to use the same type for different G3-PLC PHY bands ",
							" Library Interface (PRIME) If the PLC Driver uses PRIME PHY the PLC PHY Coupling service library provides the following interfaces: Functions Name Description SRV_PCOUP_Get_Default_Channel Get the default PRIME channel SRV_PCOUP_Get_Channel_Config Get the PLC PHY Coupling parameters for the specified PRIME channel SRV_PCOUP_Set_Channel_Config Set the PLC PHY Coupling parameters for the specified PRIME channel Data types and constants Name Type Description SRV_PLC_PCOUP_CHANNEL_DATA Struct PLC PHY Coupling data ",
							" SRV_PCOUP_Get_Default_Channel Function ",
							" C DRV_PLC_PHY_CHANNEL SRV_PCOUP_Get_Default_Channel(void); ",
							" Summary Get the default PRIME channel ",
							" Description This function allows to get the PRIME channel used by default which is configured through MCC of PLC Driver ",
							" Precondition None ",
							" Parameters None ",
							" Returns Default PRIME channel ( DRV_PLC_PHY_CHANNEL Enum ) ",
							" Example // 'handle' returned from DRV_PLC_PHY_Open DRV_PLC_PHY_CHANNEL plcDefaultChannel; DRV_PLC_PHY_PIB_OBJ pibObj; plcDefaultChannel = SRV_PCOUP_Get_Default_Channel(); pibObj id = PLC_ID_CHANNEL_CFG; pibObj length = 1; pibObj pData = plcDefaultChannel; DRV_PLC_PHY_PIBSet(handle pibObj); SRV_PCOUP_Set_Channel_Config(handle plcDefaultChannel); ",
							" Remarks This function is only generated by MCC if the PLC Driver uses PRIME PHY ",
							" SRV_PCOUP_Get_Channel_Config Function ",
							" C SRV_PLC_PCOUP_CHANNEL_DATA * SRV_PCOUP_Get_Channel_Config(DRV_PLC_PHY_CHANNEL channel); ",
							" Summary Get the PLC PHY Coupling parameters for the specified PRIME channel ",
							" Description This function allows to get the PLC PHY Coupling parameters for the specified PRIME channel These parameters can be sent to the PLC device through PLC Driver PIB interface ( DRV_PLC_PHY_PIBSet ) ",
							" Precondition None ",
							" Parameters Param Description channel PRIME channel ( DRV_PLC_PHY_CHANNEL Enum ) for which the parameters are requested ",
							" Returns Pointer to SRV_PLC_PCOUP_CHANNEL_DATA Struct containing the PLC PHY Coupling parameters if channel parameter is valid NULL if channel parameter is not valid ",
							" Example SRV_PLC_PCOUP_CHANNEL_DATA *pCoupValues; pCoupValues = SRV_PCOUP_Get_Channel_Config(SRV_PLC_PCOUP_MAIN_BRANCH); ",
							" Remarks This function is only generated by MCC if the PLC Driver uses PRIME PHY If SRV_PCOUP_Set_Channel_Config function is used to set the PLC PHY Coupling parameters this function is not needed ",
							" SRV_PCOUP_Set_Channel_Config Function ",
							" C bool SRV_PCOUP_Set_Channel_Config(DRV_HANDLE handle DRV_PLC_PHY_CHANNEL channel); ",
							" Summary Set the PLC PHY Coupling parameters for the specified PRIME channel ",
							" Description This function allows to set the PLC PHY Coupling parameters for the specified PRIME channel using the PLC Driver PIB interface ( DRV_PLC_PHY_PIBSet ) ",
							" Precondition The PLC driver's open routine ( DRV_PLC_PHY_Open ) must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid instance handle returned from the PLC driver's open routine channel PRIME channel ( DRV_PLC_PHY_CHANNEL Enum ) for which the parameters will be set ",
							" Returns true Successful configuration false if channel parameter is not valid if there is an error when using the PLC Driver PIB interface ",
							" Example // 'handle' returned from DRV_PLC_PHY_Open bool result; result = SRV_PCOUP_Set_Channel_Config(handle CHN5); ",
							" Remarks This function is only generated by MCC if the PLC Driver uses PRIME PHY ",
							" SRV_PLC_PCOUP_CHANNEL_DATA Struct ",
							" C typedef struct { /* Target RMS values in HIGH mode for dynamic Tx gain */ uint32_t rmsHigh[8]; /* Target RMS values in VLOW mode for dynamic Tx gain */ uint32_t rmsVLow[8]; /* Threshold RMS values in HIGH mode for dynamic Tx mode */ uint32_t thrsHigh[16]; /* Threshold RMS values in VLOW mode for dynamic Tx mode */ uint32_t thrsVLow[16]; /* Pointer to values for configuration of PLC DACC peripheral according to hardware coupling design and PLC device (PL360/PL460) */ const uint32_t * daccTable; /* Pointer to Tx equalization coefficients table in HIGH mode There is one coefficient for each carrier in the used band */ const uint16_t * equHigh; /* Pointer to Tx equalization coefficients table in VLOW mode There is one coefficient for each carrier in the used band */ const uint16_t * equVlow; /* Tx gain values for HIGH mode [HIGH_INI HIGH_MIN HIGH_MAX] */ uint16_t gainHigh[3]; /* Tx gain values for VLOW mode [VLOW_INI VLOW_MIN VLOW_MAX] */ uint16_t gainVLow[3]; /* Number of Tx attenuation levels (1 dB step) suppoting dynamic Tx mode */ uint8_t numTxLevels; /* Configuration of the PLC Tx Line Driver according to hardware coupling design and PLC device (PL360/PL460) */ uint8_t lineDrvConf; } SRV_PLC_PCOUP_CHANNEL_DATA; ",
							" Summary PLC PHY Coupling data ",
							" Description This structure contains all the data required to set the PLC PHY Coupling parameters for a specific PRIME channel ",
							" Remarks This type is only generated by MCC if the PLC Driver uses PRIME PHY Equalization coefficients and DACC table are not stored in the structure just pointers to arrays were they are actually stored This allows to use the same type for different PRIME channels ",
							" PLC PHY Sniffer Service This service serializes transmitted and received PLC PHY frames (along with informative frame parameters) in a buffer to later send them through a Serial Interface using USI Service On the other side a Tool such as Microchip PLC Sniffer Tool can be used to decode and show the frames ",
							" How the Library Works ",
							" PLC PHY Frames Serialization PLC Sniffer mission is to provide information about every frame present in the PLC medium This information includes the frame itself and some parameters related to PLC communications Sniffer library provides functions which perform the encoding of the frames along with their related parameters and store them in a buffer that can be later sent through a Serial interface On the other side of this interface the Microchip PLC Sniffer Tool will receive the encapsulated packets process and present them on a GUI to ease visualization and further analysis This allows monitoring the PLC medium in real time Library provides separate functions to be called either when frames are transmitted and when are received by a device This leads to 2 different modes of operation for the PLC Sniffer: Stand-alone Sniffer A device which runs an application with the only purpose of acting as a sniffer In this case device wil never send any frame and thus only the received frames serialization will be used Embedded Sniffer This mode is used when a regular device embeds sniffer capabilities In this case received frames will be serialized (after sending them to upper layers for regular processing) and also transmitted frames will be sent to the sniffer library so they are serialized (to simulate reception of own frames) ",
							" Parameters Encoded with Frames for Serialization The parameters included to provide additional information of the PLC frames depend on the used PLC profile G3 or PRIME ",
							" G3 parameters Parameter Description Modulation Type/Scheme Modulation in which PLC frame is encoded (Fixed to '0' for ACK frames) Tone Map Bitmap indicating which frquencies are used for Payload encoding (Fixed to '0' for ACK frames) Num Symbols Number of OFDM symbols that frame payload consists of (Fixed to '0' for ACK frames) SNR Indicator of frame reception quality (Fixed to '0xFF' for ACK frames and Transmitted frames) Delimiter Type Field to indicate frame type (Data with or without ACK request ACK NACK) Time Ini Timestamp for the start of frame in line Time End Timestamp for the end of frame in line RSSI Received Signal Strength Indicator (Fixed to '0xFFFF' for Transmitted frames) Length Frame lenght PDU Frame buffer Note: Number of symbols have to be provided to sniffer library by means of a dedicated function before calling encoding functions ",
							" PRIME parameters Parameter Description Modulation Scheme Modulation in which PLC frame is encoded Num Symbols Number of OFDM symbols that frame payload consists of SNR Indicator of frame reception quality (Fixed to '7' for Transmitted frames) CINR Average Auxiliary indicator of frame reception quality (averaged) (Fixed to '60' for Transmitted frames) CINR Min Auxiliary indicator of frame reception quality (minimum) (Fixed to '0xFF' for Transmitted frames) Channel PLC Channel in which device is operating BER Average Bit Error Rate estimation (averaged) (Fixed to '0' for Transmitted frames) BER Max Bit Error Rate estimation (maximum) (Fixed to '0' for Transmitted frames) Time Ini Timestamp for the start of frame in line Time End Timestamp for the end of frame in line RSSI Received Signal Strength Indicator (Fixed to '140' for Transmitted frames) Length Frame lenght PDU Frame buffer Note: Number of symbols have to be provided to sniffer library by means of a dedicated function before calling encoding functions ",
							" PLC PHY Sniffer Configuration There are some parameters that have to be correctly configured in a device in order to communicate with other peers in the network These parameters can be configured on the Sniffer library so frames are correctly received and/or parameters correctly computed Parameter difer depending on the used PLC profile G3 or PRIME ",
							" G3 configuration params G3 has one configuration parameter that if different between 2 devices blocks communication This parameter is the Tone Mask and it indicates which tones are used for frame encoding/decoding in the working band and which ones are not Sniffer library provides a dedicated function SRV_PSNIFFER_ConvertToneMask to convert a Tone Mask configuration received from the Microchip PLC Sniffer Tool and then write it to the corresponding PLC PHY IB to be used for encoding/decoding ",
							" PRIME configuration params PRIME has one configuration parameter that if different between 2 devices blocks communication This parameter is the PLC Channel and it indicates which subband is being used inside the available band Sniffer library provides a dedicated function SRV_PSNIFFER_SetPLCChannel to set the configuration received from the Microchip PLC Sniffer Tool and then write it to the corresponding PLC PHY IB ",
							" Using The Library The PLC PHY Sniffer library is an add-on that can be used along with the PLC PHY Driver or the G3 PLC MAC RT Driver The PHY or MAC RT driver is the one in charge of PLC communications while the Sniffer is used to encode the packets containing the PLC frames and then send them through a Serial interface Following examples illustrate how to use the Sniffer library (which in turn uses the USI service to send the frames to an external tool) to build a Sniffer application Both G3 and PRIME based examples are provided Example implementation of a G3 Sniffer APP_DATA appData; static uint8_t pPLCDataRxBuffer[APP_PLC_DATA_BUFFER_SIZE]; static uint8_t pPLCDataPIBBuffer[APP_PLC_PIB_BUFFER_SIZE]; static uint8_t pSerialDataBuffer[APP_SERIAL_DATA_BUFFER_SIZE]; static void APP_PLCDataIndCb(DRV_PLC_PHY_RECEPTION_OBJ *indObj uintptr_t context) { /* Send Received PLC message through USI */ if (indObj- dataLength) { size_t length; /* Report RX Symbols */ appData plcPIB id = PLC_ID_RX_PAY_SYMBOLS; appData plcPIB length = 2; DRV_PLC_PHY_PIBGet(appData drvPl360Handle appData plcPIB); SRV_PSNIFFER_SetRxPayloadSymbols(*(uint16_t *)appData plcPIB pData); /* Add received message */ length = SRV_PSNIFFER_SerialRxMessage(appData pSerialData indObj); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_SNIFF_G3 appData pSerialData length); } } void APP_USIPhyProtocolEventHandler(uint8_t *pData size_t length) { /* Message received from PLC Tool - USART */ uint8_t command; /* Retrieve Command from received message */ command = SRV_PSNIFFER_GetCommand(pData); switch (command) { /* Only TONE_MASK Command expected */ case SRV_PSNIFFER_CMD_SET_TONE_MASK: { /* Convert ToneMask from Sniffer Tool to PLC phy layer */ SRV_PSNIFFER_ConvertToneMask(appData plcPIB pData pData + 1); /* Send data to PLC */ appData plcPIB id = PLC_ID_TONE_MASK; appData plcPIB length = PSNIFFER_CARRIERS_SIZE; DRV_PLC_PHY_PIBSet(appData drvPl360Handle appData plcPIB); } break; default: break; } } void APP_Initialize(void) { /* Place the App state machine in its initial state */ appData state = APP_STATE_INIT; /* Initialize PLC objects */ appData plcRxObj pReceivedData = pPLCDataRxBuffer; appData plcPIB pData = pPLCDataPIBBuffer; appData pSerialData = pSerialDataBuffer; } void APP_Tasks(void) { /* Check the application's current state */ switch(appData state) { /* Application's initial state */ case APP_STATE_INIT: { /* Open PLC driver : Start uploading process */ appData drvPl360Handle = DRV_PLC_PHY_Open(DRV_PLC_PHY_INDEX NULL); if (appData drvPl360Handle = DRV_HANDLE_INVALID) { /* Set Application to next state */ appData state = APP_STATE_REGISTER; } else { /* Set Application to ERROR state */ appData state = APP_STATE_ERROR; } break; } /* Waiting to PLC transceiver be opened and register callback functions */ case APP_STATE_REGISTER: { /* Check PLC transceiver */ if (DRV_PLC_PHY_Status(DRV_PLC_PHY_INDEX) == SYS_STATUS_READY) { /* Register PLC callback */ DRV_PLC_PHY_DataIndCallbackRegister(appData drvPl360Handle APP_PLCDataIndCb DRV_PLC_PHY_INDEX); /* Open USI Service */ appData srvUSIHandle = SRV_USI_Open(SRV_USI_INDEX_0); if (appData srvUSIHandle = DRV_HANDLE_INVALID) { /* Set Application to next state */ appData state = APP_STATE_CONFIG_USI; } else { /* Set Application to ERROR state */ appData state = APP_STATE_ERROR; } } break; } case APP_STATE_CONFIG_USI: { if (SRV_USI_Status(appData srvUSIHandle) == SRV_USI_STATUS_CONFIGURED) { /* Register USI callback */ SRV_USI_CallbackRegister(appData srvUSIHandle SRV_USI_PROT_ID_SNIFF_G3 APP_USIPhyProtocolEventHandler); /* Set Application to next state */ appData state = APP_STATE_READY; } break; } case APP_STATE_READY: { /* Check USI status in case of USI device has been reset */ if (SRV_USI_Status(appData srvUSIHandle) == SRV_USI_STATUS_NOT_CONFIGURED) { /* Set Application to next state */ appData state = APP_STATE_CONFIG_USI; } break; } case APP_STATE_ERROR: { /* Handle error in application's state machine */ break; } /* The default state should never be executed */ default: { /* TODO: Handle error in application's state machine */ break; } } } Example implementation of a PRIME Sniffer APP_DATA appData; static uint8_t pPLCDataRxBuffer[APP_PLC_DATA_BUFFER_SIZE]; static uint8_t pPLCDataPIBBuffer[APP_PLC_PIB_BUFFER_SIZE]; static uint8_t pSerialDataBuffer[APP_SERIAL_DATA_BUFFER_SIZE]; static void APP_PLCDataIndCb(DRV_PLC_PHY_RECEPTION_OBJ *indObj uintptr_t context) { /* Send Received PLC message through USI */ if (indObj- dataLength) { size_t length; /* Report RX Symbols */ appData plcPIB id = PLC_ID_RX_PAY_SYMBOLS; appData plcPIB length = 2; DRV_PLC_PHY_PIBGet(appData drvPl360Handle appData plcPIB); SRV_PSNIFFER_SetRxPayloadSymbols(*(uint16_t *)appData plcPIB pData); /* Serialize received message */ length = SRV_PSNIFFER_SerialRxMessage(appData pSerialData indObj); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_SNIF_PRIME appData pSerialData length); } } void APP_USIPhyProtocolEventHandler(uint8_t *pData size_t length) { /* Message received from PLC Tool - USART */ uint8_t command; /* Process received message */ command = SRV_PSNIFFER_GetCommand(pData); switch (command) { /* Only SET_CHANNEL Command expected */ case SRV_PSNIFFER_CMD_SET_CHANNEL: { SRV_PLC_PCOUP_CHANNEL channel; channel = *(pData + 1); if ((appData channel = channel) (channel = CHN1) (channel = CHN7_CHN8)) { appData channel = channel; /* Set channel configuration */ appData plcPIB id = PLC_ID_CHANNEL_CFG; appData plcPIB length = 1; *appData plcPIB pData = channel; DRV_PLC_PHY_PIBSet(appData drvPl360Handle appData plcPIB); /* Update channel in PSniffer */ SRV_PSNIFFER_SetPLCChannel(appData channel); } } break; default: break; } } void APP_Initialize(void) { /* Place the App state machine in its initial state */ appData state = APP_STATE_INIT; /* Initialize PLC objects */ appData plcRxObj pReceivedData = pPLCDataRxBuffer; appData plcPIB pData = pPLCDataPIBBuffer; appData pSerialData = pSerialDataBuffer; /* Init Channel */ appData channel = SRV_PCOUP_Get_Default_Channel(); } void APP_Tasks(void) { /* Check the application's current state */ switch(appData state) { /* Application's initial state */ case APP_STATE_INIT: { /* Open PLC driver : Start uploading process */ appData drvPl360Handle = DRV_PLC_PHY_Open(DRV_PLC_PHY_INDEX NULL); if (appData drvPl360Handle = DRV_HANDLE_INVALID) { /* Set Application to next state */ appData state = APP_STATE_REGISTER; } else { /* Set Application to ERROR state */ appData state = APP_STATE_ERROR; } break; } /* Waiting to PLC transceiver be opened and register callback functions */ case APP_STATE_REGISTER: { /* Check PLC transceiver */ if (DRV_PLC_PHY_Status(DRV_PLC_PHY_INDEX) == SYS_STATUS_READY) { /* Register PLC callback */ DRV_PLC_PHY_DataIndCallbackRegister(appData drvPl360Handle APP_PLCDataIndCb DRV_PLC_PHY_INDEX); /* Open USI Service */ appData srvUSIHandle = SRV_USI_Open(SRV_USI_INDEX_0); if (appData srvUSIHandle = DRV_HANDLE_INVALID) { /* Set Application to next state */ appData state = APP_STATE_CONFIG_USI; } else { /* Set Application to ERROR state */ appData state = APP_STATE_ERROR; } } break; } case APP_STATE_CONFIG_USI: { if (SRV_USI_Status(appData srvUSIHandle) == SRV_USI_STATUS_CONFIGURED) { /* Register USI callback */ SRV_USI_CallbackRegister(appData srvUSIHandle SRV_USI_PROT_ID_SNIF_PRIME APP_USIPhyProtocolEventHandler); /* Set channel configuration */ appData plcPIB id = PLC_ID_CHANNEL_CFG; appData plcPIB length = 1; *appData plcPIB pData = appData channel; DRV_PLC_PHY_PIBSet(appData drvPl360Handle appData plcPIB); /* Update channel in PSniffer */ SRV_PSNIFFER_SetPLCChannel(appData channel); appData plcPIB id = PLC_ID_NUM_CHANNELS; appData plcPIB length = 1; if (appData channel CHN8) { *appData plcPIB pData = 2; } else { *appData plcPIB pData = 1; } DRV_PLC_PHY_PIBSet(appData drvPl360Handle appData plcPIB); /* Set Application to next state */ appData state = APP_STATE_READY; } break; } case APP_STATE_READY: { /* Check USI status in case of USI device has been reset */ if (SRV_USI_Status(appData srvUSIHandle) == SRV_USI_STATUS_NOT_CONFIGURED) { /* Set Application to next state */ appData state = APP_STATE_CONFIG_USI; } break; } case APP_STATE_ERROR: { /* Handle error in application's state machine */ break; } /* The default state should never be executed */ default: { /* TODO: Handle error in application's state machine */ break; } } } ",
							" Configuring The Library PLC PHY Sniffer Service is configured via MCC Below is the Snapshot of the MCC configuration window for PLC PHY Sniffer Service and brief description PLC PHY Sniffer Service configuration options SRV_PSNIFFER_mcc_configuration PLC Profile Specifies the PLC Profile and/or Working band used Available options are: PRIME Shared profile for all channels channel is later configured G3 CEN-A G3 Profile for Cenelec-A band G3 CEN-B G3 Profile for Cenelec-B band G3 FCC G3 Profile for FCC band Note: As PLC PHY Sniffer Service is tightly linked to PLC PHY or MAC RT Driver if PLC Profile is changed in PHY / MAC RT Driver Configuration PHY Sniffer configuration is automatically updated to match the Profile selected in Driver ",
							" Library Interface PLC PHY Sniffer library provides the following interfaces: Functions Name Description SRV_PSNIFFER_GetCommand Extracts Command field from Sniffer frame SRV_PSNIFFER_SerialRxMessage Serializes a received PLC frame along with its parameters SRV_PSNIFFER_SerialCfmMessage Serializes a transmitted PLC frame along with its parameters SRV_PSNIFFER_SetTxMessage Gives a transmitted PLC object to Sniffer library so it is stored for later serialization SRV_PSNIFFER_SetRxPayloadSymbols Sets the number of received symbols on Sniffer library for further use SRV_PSNIFFER_SetTxPayloadSymbols Sets the number of transmitted symbols on Sniffer library for further use SRV_PSNIFFER_SetPLCChannel Sets PLC channel to be used on PLC Sniffer (Only available on PRIME PLC profile) SRV_PSNIFFER_ConvertToneMask Converts a Tone Mask configuration coming from an external tool to the right format to be configured on PLC PHY layer (Only available on G3 PLC profile) Data types and constants Name Type Description SRV_PSNIFFER_COMMAND Enum Defines the available PLC Sniffer commands ",
							" SRV_PSNIFFER_GetCommand Function ",
							" C SRV_PSNIFFER_COMMAND SRV_PSNIFFER_GetCommand ( uint8_t* pData ); ",
							" Summary Extracts Command field from Sniffer frame ",
							" Description Takes Sniffer frame as parameter and extracts the Command field from the expected position in buffer ",
							" Precondition None ",
							" Parameters Param Description pData Pointer to buffer containing Sniffer frame ",
							" Returns Command in the form of SRV_PSNIFFER_COMMAND Enum  ",
							" Example SRV_PSNIFFER_COMMAND command; /* Process received message from Sniffer Tool */ command = SRV_PSNIFFER_GetCommand(pData); ",
							" Remarks None ",
							" SRV_PSNIFFER_SerialRxMessage Function ",
							" C size_t SRV_PSNIFFER_SerialRxMessage ( uint8_t* pDataDst DRV_PLC_PHY_RECEPTION_OBJ* pDataSrc ); ",
							" Summary Serializes a received PLC frame along with its parameters ",
							" Description This function takes an object containing a PLC frame and its related parameters and serializes it in a buffer for further transmission ",
							" Precondition SRV_PSNIFFER_SetRxPayloadSymbols has to be called before to set the correct number of received symbols in Sniffer library ",
							" Parameters Param Description pDataDst Pointer to buffer where frame is serialized pDataSrc Pointer to PLC Reception object containing the frame and parameters (see G3 DRV_PLC_PHY_RECEPTION_OBJ Struct and PRIME DRV_PLC_PHY_RECEPTION_OBJ Struct ) ",
							" Returns Number of bytes for serialized output ",
							" Example static void APP_PLCDataIndCb(DRV_PLC_PHY_RECEPTION_OBJ *indObj uintptr_t context) { /* Report RX Symbols */ appData plcPIB id = PLC_ID_RX_PAY_SYMBOLS; appData plcPIB length = 2; DRV_PLC_PHY_PIBGet(appData drvPl360Handle appData plcPIB); SRV_PSNIFFER_SetRxPayloadSymbols(*(uint16_t *)appData plcPIB pData); /* Serialize received message */ length = SRV_PSNIFFER_SerialRxMessage(appData pSerialData indObj); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_SNIFF_G3 appData pSerialData length); } ",
							" Remarks None ",
							" SRV_PSNIFFER_SerialCfmMessage Function ",
							" C size_t SRV_PSNIFFER_SerialCfmMessage ( uint8_t* pDataDst DRV_PLC_PHY_TRANSMISSION_CFM_OBJ* pCfmObj ); ",
							" Summary Serializes a transmitted PLC frame along with its parameters ",
							" Description This function takes a previously stored PLC transmitted frame and its related parameters and serializes it in a buffer for further transmission ",
							" Precondition SRV_PSNIFFER_SetTxMessage has to be previously called to store the PLC transmitted frame and its parameters SRV_PSNIFFER_SetTxPayloadSymbols has to be called before to set the correct number of transmitted symbols in Sniffer library ",
							" Parameters Param Description pDataDst Pointer to buffer where frame is serialized pCfmObj Pointer to PLC Transmission Confirm object containing the transmission result (see G3 DRV_PLC_PHY_TRANSMISSION_CFM_OBJ Struct and PRIME DRV_PLC_PHY_TRANSMISSION_CFM_OBJ Struct ) ",
							" Returns Number of bytes for serialized output ",
							" Example static void APP_PLCDataCfmCb(DRV_PLC_PHY_TRANSMISSION_CFM_OBJ *pCfmObj) { /* Report TX Symbols */ appData plcPIB id = PLC_ID_TX_PAY_SYMBOLS; appData plcPIB length = 2; DRV_PLC_PHY_PIBGet(appData drvPl360Handle appData plcPIB); SRV_PSNIFFER_SetTxPayloadSymbols(*(uint16_t *)appData plcPIB pData); /* Serialize transmitted message */ length = SRV_PSNIFFER_SerialCfmMessage(appData pSerialData pCfmObj); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_SNIFF_G3 appData pSerialData length); } ",
							" Remarks None ",
							" SRV_PSNIFFER_SetTxMessage Function ",
							" C void SRV_PSNIFFER_SetTxMessage ( DRV_PLC_PHY_TRANSMISSION_OBJ* pTxObj ); ",
							" Summary Gives a transmitted PLC object to Sniffer library so it is stored for later serialization ",
							" Description The given transmitted PLC object contains a PLC frame and its related parameters all this info is stored in sniffer library for later serialization when SRV_PSNIFFER_SerialCfmMessage is called ",
							" Precondition None ",
							" Parameters Param Description pTxObj Pointer to a PLC transmission object to be stored (see G3 DRV_PLC_PHY_TRANSMISSION_OBJ Struct and PRIME DRV_PLC_PHY_TRANSMISSION_OBJ Struct ) ",
							" Returns None ",
							" Example static void APP_PLCTxFrame(DRV_PLC_PHY_TRANSMISSION_OBJ* pTxObj) { /* Give transmission object to Sniffer */ SRV_PSNIFFER_SetTxMessage(pTxObj); /* Send PLC frame through PHY Driver */ /* DRV_PLC_PHY_xxx(pTxObj); */ } ",
							" Remarks None ",
							" SRV_PSNIFFER_SetRxPayloadSymbols Function ",
							" C void SRV_PSNIFFER_SetRxPayloadSymbols ( uint16_t payloadSym ); ",
							" Summary Sets the number of received symbols on Sniffer library for further use ",
							" Description Number of received symbols is set on Sniffer library so that info can be later serialized along with other reception parameters ",
							" Precondition None ",
							" Parameters Param Description payloadSym Number of symbols ",
							" Returns None ",
							" Example static void APP_PLCDataIndCb(DRV_PLC_PHY_RECEPTION_OBJ *indObj uintptr_t context) { /* Report RX Symbols */ appData plcPIB id = PLC_ID_RX_PAY_SYMBOLS; appData plcPIB length = 2; DRV_PLC_PHY_PIBGet(appData drvPl360Handle appData plcPIB); SRV_PSNIFFER_SetRxPayloadSymbols(*(uint16_t *)appData plcPIB pData); /* Serialize received message */ length = SRV_PSNIFFER_SerialRxMessage(appData pSerialData indObj); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_SNIFF_G3 appData pSerialData length); } ",
							" Remarks None ",
							" SRV_PSNIFFER_SetTxPayloadSymbols Function ",
							" C void SRV_PSNIFFER_SetTxPayloadSymbols ( uint16_t payloadSym ); ",
							" Summary Sets the number of transmitted symbols on Sniffer library for further use ",
							" Description Number of transmitted symbols is set on Sniffer library so that info can be later serialized along with other transmission parameters ",
							" Precondition None ",
							" Parameters Param Description payloadSym Number of symbols ",
							" Returns None ",
							" Example static void APP_PLCDataCfmCb(DRV_PLC_PHY_TRANSMISSION_CFM_OBJ *pCfmObj) { /* Report TX Symbols */ appData plcPIB id = PLC_ID_TX_PAY_SYMBOLS; appData plcPIB length = 2; DRV_PLC_PHY_PIBGet(appData drvPl360Handle appData plcPIB); SRV_PSNIFFER_SetTxPayloadSymbols(*(uint16_t *)appData plcPIB pData); /* Serialize transmitted message */ length = SRV_PSNIFFER_SerialCfmMessage(appData pSerialData pCfmObj); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_SNIFF_G3 appData pSerialData length); } ",
							" Remarks None ",
							" SRV_PSNIFFER_SetPLCChannel Function ",
							" C void SRV_PSNIFFER_SetPLCChannel ( uint8_t channel ); ",
							" Summary Sets PLC channel to be used on PLC Sniffer ",
							" Description This function allows setting the right PLC channel to listed to If misconfigured no PLC frames will be seen ",
							" Precondition None ",
							" Parameters Param Description channel The PLC channel to listen to ",
							" Returns None ",
							" Example switch (command) { case SRV_PSNIFFER_CMD_SET_CHANNEL: { SRV_PLC_PCOUP_CHANNEL channel; channel = *(pData + 1); if ((appData channel = channel) (channel = CHN1) (channel = CHN7_CHN8)) { appData channel = channel; /* Set channel configuration */ appData plcPIB id = PLC_ID_CHANNEL_CFG; appData plcPIB length = 1; *appData plcPIB pData = channel; DRV_PLC_PHY_PIBSet(appData drvPl360Handle appData plcPIB); /* Update channel in PSniffer */ SRV_PSNIFFER_SetPLCChannel(appData channel); } } break; /* */ } ",
							" Remarks This function is only available in PRIME PLC profile ",
							" SRV_PSNIFFER_ConvertToneMask Function ",
							" C void SRV_PSNIFFER_ConvertToneMask ( uint8_t* pToneMaskDst uint8_t* pToneMaskSrc ); ",
							" Summary Converts a Tone Mask configuration coming from an external tool to the right format to be configured on PLC PHY layer ",
							" Description This function takes a Tone Mask configuration with the format coming from MCHP PLC Sniffer Tool and converts it to a format to be configured on PLC PHY layer to be used on further transmissions and receptions If misconfigured no PLC frames will be seen ",
							" Precondition None ",
							" Parameters Param Description pToneMaskDst The Tone Mask converted to PHY format pToneMaskSrc The Tone Mask with format coming from external tool ",
							" Returns None ",
							" Example switch (command) { case SRV_PSNIFFER_CMD_SET_TONE_MASK: { /* Convert ToneMask from Sniffer Tool to PLC phy layer */ SRV_PSNIFFER_ConvertToneMask(appData plcPIB pData pData + 1); /* Send data to PLC */ appData plcPIB id = PLC_ID_TONE_MASK; appData plcPIB length = PSNIFFER_CARRIERS_SIZE; DRV_PLC_PHY_PIBSet(appData drvPl360Handle appData plcPIB); } break; /* */ } ",
							" Remarks This function is only available in G3 PLC profile ",
							" SRV_PSNIFFER_COMMAND Enum ",
							" C - PRIME Implementation typedef enum { /* Set PLC Channel */ SRV_PSNIFFER_CMD_SET_CHANNEL = 2 /* Enable robust modes of PRIME */ SRV_PSNIFFER_CMD_ENABLE_PRIME_PLUS_ROBUST /* Inject message in PLC */ SRV_PSNIFFER_CMD_MESSAGE } SRV_PSNIFFER_COMMAND; ",
							" C - G3 Implementation typedef enum { /* Receive new PLC message */ SRV_PSNIFFER_CMD_RECEIVE_MSG = 0 /* Set Tone Mask request */ SRV_PSNIFFER_CMD_SET_TONE_MASK } SRV_PSNIFFER_COMMAND; ",
							" Summary List of PLC Sniffer Commands ",
							" Description This enumeration defines the PLC commands used by PLC Phy Sniffer Tool provided by Microchip ",
							" PLC PHY Serial Service This service allows controlling a PLC transceiver at PHY level through a Serial interface using USI Service This serialization includes transmission and reception of PLC frames as well as getting and setting parameters in PHY layer Information Base PIBs On the other side of Serial interface a Tool such as Microchip Phy Tester Tool or Microchip PLC Python Libs can be used to perform these operations ",
							" How the Library Works ",
							" PLC PHY API Serialization PLC Serial library allow accessing to PLC PHY Driver API through a Serial interface Library manages commands coming from a Serial interface through the USI library these commands include access to PLC Transmission primitives and also access to read/write parameters of the PHY Information Base (PIBs) On the other direction library sends the received PLC frames through the Serial interface as well as the resulting status of a requested transmission or PIB access A tool is required at the other side of the Serial interface to send and receive commands For this purpose Microchip offers 2 different options: Microchip Phy Tester Tool A GUI which allows sending and receiving PLC frames and accessing the PHY Information Base Microchip PLC Python Libs A set of Python libraries that allow easily building scripts on top of them to perform sending receiving and configuring operations ",
							" Commands Accepted by Library Serial library accepts commands for PLC frame trasnmission and PIB access The following list describes these commands and their behaviour: SRV_PSERIAL_CMD_PHY_SEND_MSG This command is followed by a serialized stream that contains the frame to be sent to PLC and the transmission paramters Upon reception of this command Serial library generates a PLC transmission object and requests transmission to the PLC PHY Driver SRV_PSERIAL_CMD_PHY_GET_CFG This command is followed by the identifier of the PIB object to be retrieved Upon reception of this command the PIB is retrieved from the PLC transceiver and a response command ( SRV_PSERIAL_CMD_PHY_GET_CFG_RSP ) is generated to send back the value and result of the Get operation SRV_PSERIAL_CMD_PHY_SET_CFG This command is followed by the identifier of the PIB object to be set Upon reception of this command the PIB is written to the PLC transceiver and a response command ( SRV_PSERIAL_CMD_PHY_SET_CFG_RSP ) is generated to send back the result of the Set operation ",
							" Commands Generated by Library Serial library generates commands either by itself or as a response to requested commands to indicate PLC frame reception PLC transmission result and PIB access result The following list describes these commands and the evenst that generate them: SRV_PSERIAL_CMD_PHY_RECEIVE_MSG This command is generated upon reception of a PLC frame from the PLC PHY Driver The command is followed by the received frame and reception related parameters SRV_PSERIAL_CMD_PHY_SEND_MSG_RSP This command is generated upon confirm of a transmitted (or aborted trasnsmission) PLC frame from the PLC PHY Driver The command is followed by the transmission result or the error code in case of transmission failure SRV_PSERIAL_CMD_PHY_GET_CFG_RSP This command is generated as a response to a PIB Get command ( SRV_PSERIAL_CMD_PHY_GET_CFG ) and is follwed by the Get operation result and (if successful) the retrieved value of the Get operation SRV_PSERIAL_CMD_PHY_SET_CFG_RSP This command is generated as a response to a PIB Set command ( SRV_PSERIAL_CMD_PHY_SET_CFG ) and is follwed by the Set operation result ",
							" Using The Library The PLC PHY Serial library is an add-on that can be used along with the PLC PHY Driver The PHY driver is the one in charge of PLC communications while the Serial library is used to serialize the PHY API this is to decode/encode the packets containing the PLC frames their related parameters and the PIB objects after receiving/sending them them from/to a Serial interface Following example illustrate how to use the Serial library (which in turn uses the USI service to send/receive the packets to/from an external tool) to serialize the PLC PHY API Even if G3 and PRIME protocols have differences in the content of the serialized packets a unique example is provided not entering is such details so it is seen that the implementation is the same in terms of function calling and state machines Example implementation of a PLC PHY API Serialization APP_DATA appData; static uint8_t pPLCDataTxBuffer[APP_PLC_DATA_BUFFER_SIZE]; static uint8_t pPLCDataRxBuffer[APP_PLC_DATA_BUFFER_SIZE]; static uint8_t pPLCDataPIBBuffer[APP_PLC_PIB_BUFFER_SIZE]; static uint8_t pSerialDataBuffer[APP_SERIAL_DATA_BUFFER_SIZE]; /* PLC Data Indication Callback */ static void APP_PLCDataIndCb(DRV_PLC_PHY_RECEPTION_OBJ *indObj uintptr_t context) { /* Send Received PLC message through USI */ if (indObj- dataLength) { size_t length; /* Serialize received message */ length = SRV_PSERIAL_SerialRxMessage(appData pSerialData indObj); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_PHY appData pSerialData length); } } /* PLC Data Confirm Callback */ static void APP_PLCDataCfmCb(DRV_PLC_PHY_TRANSMISSION_CFM_OBJ *cfmObj uintptr_t context) { size_t length; appData plcTxState = APP_PLC_TX_STATE_IDLE; /* Serialize received message */ length = SRV_PSERIAL_SerialCfmMessage(appData pSerialData cfmObj); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_PHY appData pSerialData length); } /* USI packet received Callback */ void APP_USIPhyProtocolEventHandler(uint8_t *pData size_t length) { /* Message received from PLC Tool - USART */ SRV_PSERIAL_COMMAND command; /* Process received message */ command = SRV_PSERIAL_GetCommand(pData); switch (command) { case SRV_PSERIAL_CMD_PHY_GET_CFG: { /* Extract PIB information */ SRV_PSERIAL_ParseGetPIB( appData plcPIB pData); if (DRV_PLC_PHY_PIBGet(appData drvPl360Handle appData plcPIB)) { size_t len; /* Serialize PIB data */ len = SRV_PSERIAL_SerialGetPIB(appData pSerialData appData plcPIB); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_PHY appData pSerialData len); } } break; case SRV_PSERIAL_CMD_PHY_SET_CFG: { /* Extract PIB information */ SRV_PSERIAL_ParseSetPIB( appData plcPIB pData); if (DRV_PLC_PHY_PIBSet(appData drvPl360Handle appData plcPIB)) { size_t len; /* Serialize PIB data */ len = SRV_PSERIAL_SerialSetPIB( appData pSerialData[1] appData plcPIB); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_PHY appData pSerialData len); } } break; case SRV_PSERIAL_CMD_PHY_SEND_MSG: { /* Set PLC TX State to wait Tx confirmation */ appData plcTxState = APP_PLC_TX_STATE_WAIT_TX_CFM; /* Capture and parse data from USI */ SRV_PSERIAL_ParseTxMessage( appData plcTxObj pData); /* Send Message through PLC */ DRV_PLC_PHY_Send(appData drvPl360Handle appData plcTxObj); } break; default: break; } } void APP_Initialize(void) { /* Place the App state machine in its initial state */ appData state = APP_STATE_INIT; /* Initialize PLC buffers */ appData plcTxObj pTransmitData = pPLCDataTxBuffer; appData plcRxObj pReceivedData = pPLCDataRxBuffer; appData plcPIB pData = pPLCDataPIBBuffer; appData pSerialData = pSerialDataBuffer; /* Init PLC TX status */ appData plcTxState = APP_PLC_TX_STATE_IDLE; } void APP_Tasks(void) { /* Check the application's current state */ switch(appData state) { /* Application's initial state */ case APP_STATE_INIT: { /* Open PLC driver : Start uploading process */ appData drvPl360Handle = DRV_PLC_PHY_Open(DRV_PLC_PHY_INDEX NULL); if (appData drvPl360Handle = DRV_HANDLE_INVALID) { /* Set Application to next state */ appData state = APP_STATE_REGISTER; } else { /* Set Application to ERROR state */ appData state = APP_STATE_ERROR; } break; } /* Waiting to PLC transceiver be opened and register callback functions */ case APP_STATE_REGISTER: { /* Check PLC transceiver */ if (DRV_PLC_PHY_Status(DRV_PLC_PHY_INDEX) == SYS_STATUS_READY) { /* Register PLC callback */ DRV_PLC_PHY_ExceptionCallbackRegister(appData drvPl360Handle APP_PLCExceptionCb DRV_PLC_PHY_INDEX); DRV_PLC_PHY_DataIndCallbackRegister(appData drvPl360Handle APP_PLCDataIndCb DRV_PLC_PHY_INDEX); DRV_PLC_PHY_DataCfmCallbackRegister(appData drvPl360Handle APP_PLCDataCfmCb DRV_PLC_PHY_INDEX); /* Open USI Service */ appData srvUSIHandle = SRV_USI_Open(SRV_USI_INDEX_0); if (appData srvUSIHandle = DRV_HANDLE_INVALID) { /* Set Application to next state */ appData state = APP_STATE_CONFIG_USI; } else { /* Set Application to ERROR state */ appData state = APP_STATE_ERROR; } } break; } case APP_STATE_CONFIG_USI: { if (SRV_USI_Status(appData srvUSIHandle) == SRV_USI_STATUS_CONFIGURED) { /* Register USI callback */ SRV_USI_CallbackRegister(appData srvUSIHandle SRV_USI_PROT_ID_PHY APP_USIPhyProtocolEventHandler); /* Set Application to next state */ appData state = APP_STATE_CONFIG_PLC; } break; } case APP_STATE_CONFIG_PLC: { /* Set PLC configuration (differs from G3 to PRIME) */ /* */ /* Set Application to next state */ appData state = APP_STATE_READY; break; } case APP_STATE_READY: { /* Check USI status in case of USI device has been reset */ if (SRV_USI_Status(appData srvUSIHandle) == SRV_USI_STATUS_NOT_CONFIGURED) { /* Set Application to next state */ appData state = APP_STATE_CONFIG_USI; } /* Else just wait for events to trigger callbacks */ break; } case APP_STATE_ERROR: { /* Handle error in application's state machine */ break; } /* The default state should never be executed */ default: { break; } } } ",
							" Configuring The Library PLC PHY Serial Service is configured via MCC Below is the Snapshot of the MCC configuration window for PLC PHY Serial Service and brief description PLC PHY Serial Service configuration options SRV_PSERIAL_mcc_configuration PLC Profile Specifies the PLC Profile and/or Working band used Available options are: PRIME Shared profile for all channels channel is later configured G3 CEN-A G3 Profile for Cenelec-A band G3 CEN-B G3 Profile for Cenelec-B band G3 FCC G3 Profile for FCC band Note: As PLC PHY Serial Service is tightly linked to PLC PHY Driver if PLC Profile is changed in PHY Driver Configuration PHY Serial configuration is automatically updated to match the Profile selected in PHY Driver ",
							" Library Interface PLC PHY Sniffer library provides the following interfaces: Functions Name Description SRV_PSERIAL_GetCommand Extracts Command field from Serial frame SRV_PSERIAL_ParseGetPIB Extracts PIB field from SRV_PSERIAL_CMD_PHY_GET_CFG Serial frame SRV_PSERIAL_SerialGetPIB Serializes a response to a SRV_PSERIAL_CMD_PHY_GET_CFG command SRV_PSERIAL_ParseSetPIB Extracts PIB field from SRV_PSERIAL_CMD_PHY_SET_CFG Serial frame SRV_PSERIAL_SerialSetPIB Serializes a response to a SRV_PSERIAL_CMD_PHY_SET_CFG command SRV_PSERIAL_ParseTxMessage Extracts a PLC frame to be transmitted from SRV_PSERIAL_CMD_PHY_SEND_MSG Serial frame SRV_PSERIAL_SerialRxMessage Serializes a received PLC frame and its related information SRV_PSERIAL_SerialCfmMessage Serializes the result of a PLC transmitted frame Data types and constants Name Type Description SRV_PSERIAL_COMMAND Enum Defines the available PLC Serial commands ",
							" SRV_PSERIAL_GetCommand Function ",
							" C SRV_PSERIAL_COMMAND SRV_PSERIAL_GetCommand ( uint8_t* pData ); ",
							" Summary Extracts Command field from Sniffer frame ",
							" Description Takes Serial frame as parameter and extracts the Command field from the expected position in buffer ",
							" Precondition None ",
							" Parameters Param Description pData Pointer to buffer containing Serial frame ",
							" Returns Command in the form of SRV_PSERIAL_COMMAND Enum  ",
							" Example SRV_PSERIAL_COMMAND command; /* Process received message from USI */ command = SRV_PSERIAL_GetCommand(pData); ",
							" Remarks None ",
							" SRV_PSERIAL_ParseGetPIB Function ",
							" C void SRV_PSERIAL_ParseGetPIB ( DRV_PLC_PHY_PIB_OBJ* pDataDst uint8_t* pDataSrc ); ",
							" Summary Extracts PIB field from SRV_PSERIAL_CMD_PHY_GET_CFG Serial frame ",
							" Description Takes a GetPIB Serial frame as parameter extracts the PIB information from the expected position in buffer and fills a DRV_PLC_PHY_PIB_OBJ object see G3 DRV_PLC_PHY_PIB_OBJ Struct and PRIME DRV_PLC_PHY_PIB_OBJ Struct  ",
							" Precondition None ",
							" Parameters Param Description pDataDst Pointer to a DRV_PLC_PHY_PIB_OBJ object to fill pDataSrc Pointer to buffer containing Serial frame ",
							" Returns None ",
							" Example SRV_PSERIAL_COMMAND command; DRV_PLC_PHY_PIB_OBJ pibObj; /* Process received message from USI */ command = SRV_PSERIAL_GetCommand(pData); if (command == SRV_PSERIAL_CMD_PHY_GET_CFG) { SRV_PSERIAL_ParseGetPIB( pibObj pData); /* Get PIB object from PLC Driver */ } ",
							" Remarks None ",
							" SRV_PSERIAL_SerialGetPIB Function ",
							" C size_t SRV_PSERIAL_SerialGetPIB ( uint8_t* pDataDst DRV_PLC_PHY_PIB_OBJ* pDataSrc ); ",
							" Summary Serializes a response to a SRV_PSERIAL_CMD_PHY_GET_CFG command ",
							" Description Takes a DRV_PLC_PHY_PIB_OBJ object as parameter and builds a serialized frame containing the Get result and (if successful) the PIB value see G3 DRV_PLC_PHY_PIB_OBJ Struct and PRIME DRV_PLC_PHY_PIB_OBJ Struct  ",
							" Precondition None ",
							" Parameters Param Description pDataDst Pointer to buffer where frame will be serialized pDataSrc Pointer to a DRV_PLC_PHY_PIB_OBJ object containing PIB value ",
							" Returns Length of serialized frame ",
							" Example SRV_PSERIAL_COMMAND command; DRV_PLC_PHY_PIB_OBJ pibObj; /* Process received message from USI */ command = SRV_PSERIAL_GetCommand(pData); if (command == SRV_PSERIAL_CMD_PHY_GET_CFG) { SRV_PSERIAL_ParseGetPIB( pibObj pData); if (DRV_PLC_PHY_PIBGet(appData drvPl360Handle pibObj)) { size_t len; /* Serialize PIB data */ len = SRV_PSERIAL_SerialGetPIB(appData pSerialData pibObj); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_PHY appData pSerialData len); } } ",
							" Remarks None ",
							" SRV_PSERIAL_ParseSetPIB Function ",
							" C void SRV_PSERIAL_ParseSetPIB ( DRV_PLC_PHY_PIB_OBJ* pDataDst uint8_t* pDataSrc ); ",
							" Summary Extracts PIB field from SRV_PSERIAL_CMD_PHY_SET_CFG Serial frame ",
							" Description Takes a SetPIB Serial frame as parameter extracts the PIB information from the expected position in buffer and fills a DRV_PLC_PHY_PIB_OBJ object see G3 DRV_PLC_PHY_PIB_OBJ Struct and PRIME DRV_PLC_PHY_PIB_OBJ Struct  ",
							" Precondition None ",
							" Parameters Param Description pDataDst Pointer to a DRV_PLC_PHY_PIB_OBJ object to fill pDataSrc Pointer to buffer containing Serial frame ",
							" Returns None ",
							" Example SRV_PSERIAL_COMMAND command; DRV_PLC_PHY_PIB_OBJ pibObj; /* Process received message from USI */ command = SRV_PSERIAL_GetCommand(pData); if (command == SRV_PSERIAL_CMD_PHY_SET_CFG) { SRV_PSERIAL_ParseSetPIB( pibObj pData); /* Set PIB object on PLC Driver */ } ",
							" Remarks None ",
							" SRV_PSERIAL_SerialSetPIB Function ",
							" C size_t SRV_PSERIAL_SerialSetPIB ( uint8_t* pDataDst DRV_PLC_PHY_PIB_OBJ* pDataSrc ); ",
							" Summary Serializes a response to a SRV_PSERIAL_CMD_PHY_SET_CFG command ",
							" Description Takes a DRV_PLC_PHY_PIB_OBJ object as parameter and builds a serialized frame containing the Set result see G3 DRV_PLC_PHY_PIB_OBJ Struct and PRIME DRV_PLC_PHY_PIB_OBJ Struct  ",
							" Precondition None ",
							" Parameters Param Description pDataDst Pointer to buffer where frame will be serialized pDataSrc Pointer to a DRV_PLC_PHY_PIB_OBJ object containing PIB value ",
							" Returns Length of serialized frame ",
							" Example SRV_PSERIAL_COMMAND command; DRV_PLC_PHY_PIB_OBJ pibObj; /* Process received message from USI */ command = SRV_PSERIAL_GetCommand(pData); if (command == SRV_PSERIAL_CMD_PHY_SET_CFG) { SRV_PSERIAL_ParseSetPIB( pibObj pData); if (DRV_PLC_PHY_PIBSet(appData drvPl360Handle pibObj)) { size_t len; /* Serialize PIB data */ len = SRV_PSERIAL_SerialSetPIB(appData pSerialData pibObj); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_PHY appData pSerialData len); } } ",
							" Remarks None ",
							" SRV_PSERIAL_ParseTxMessage Function ",
							" C void SRV_PSERIAL_ParseTxMessage ( DRV_PLC_PHY_TRANSMISSION_OBJ* pDataDst uint8_t* pDataSrc ); ",
							" Summary Extracts a PLC frame to be transmitted from SRV_PSERIAL_CMD_PHY_SEND_MSG Serial frame ",
							" Description Takes a SendMsg Serial frame as parameter extracts the PLC frame and its related transmission information and fills a DRV_PLC_PHY_TRANSMISSION_OBJ object see G3 DRV_PLC_PHY_TRANSMISSION_OBJ Struct and PRIME DRV_PLC_PHY_TRANSMISSION_OBJ Struct  ",
							" Precondition None ",
							" Parameters Param Description pDataDst Pointer to a DRV_PLC_PHY_TRANSMISSION_OBJ object to fill pDataSrc Pointer to buffer containing Serial frame ",
							" Returns None ",
							" Example SRV_PSERIAL_COMMAND command; DRV_PLC_PHY_TRANSMISSION_OBJ plcTxObj; /* Process received message from USI */ command = SRV_PSERIAL_GetCommand(pData); if (command == SRV_PSERIAL_CMD_PHY_SEND_MSG) { SRV_PSERIAL_ParseTxMessage( plcTxObj pData); /* Send Message through PLC */ DRV_PLC_PHY_Send(appData drvPl360Handle plcTxObj); } ",
							" Remarks None ",
							" SRV_PSERIAL_SerialRxMessage Function ",
							" C size_t SRV_PSERIAL_SerialRxMessage ( uint8_t* pDataDst DRV_PLC_PHY_RECEPTION_OBJ* pDataSrc ); ",
							" Summary Serializes a received PLC frame and its related information ",
							" Description Takes a DRV_PLC_PHY_RECEPTION_OBJ object as parameter and builds a serialized frame containing the PLC frame and its related reception parameters see G3 DRV_PLC_PHY_RECEPTION_OBJ Struct and PRIME DRV_PLC_PHY_RECEPTION_OBJ Struct  ",
							" Precondition None ",
							" Parameters Param Description pDataDst Pointer to buffer where frame will be serialized pDataSrc Pointer to a DRV_PLC_PHY_RECEPTION_OBJ object containing the PLC frame ",
							" Returns Length of serialized frame ",
							" Example static void APP_PLCDataIndCb(DRV_PLC_PHY_RECEPTION_OBJ *indObj uintptr_t context) { /* Send Received PLC message through USI */ if (indObj- dataLength) { size_t length; /* Serialize received message */ length = SRV_PSERIAL_SerialRxMessage(appData pSerialData indObj); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_PHY appData pSerialData length); } } ",
							" Remarks None ",
							" SRV_PSERIAL_SerialCfmMessage Function ",
							" C size_t SRV_PSERIAL_SerialCfmMessage ( uint8_t* pDataDst DRV_PLC_PHY_TRANSMISSION_CFM_OBJ* pDataSrc ); ",
							" Summary Serializes the result of a PLC transmitted frame ",
							" Description Takes a DRV_PLC_PHY_TRANSMISSION_CFM_OBJ object as parameter and builds a serialized frame containing the PLC transmission result and parameters see G3 DRV_PLC_PHY_TRANSMISSION_CFM_OBJ Struct and PRIME DRV_PLC_PHY_TRANSMISSION_CFM_OBJ Struct  ",
							" Precondition None ",
							" Parameters Param Description pDataDst Pointer to buffer where frame will be serialized pDataSrc Pointer to a DRV_PLC_PHY_TRANSMISSION_CFM_OBJ object containing the PLC transmission result and parameters ",
							" Returns Length of serialized frame ",
							" Example static void APP_PLCDataCfmCb(DRV_PLC_PHY_TRANSMISSION_CFM_OBJ *cfmObj uintptr_t context) { size_t length; /* Serialize received message */ length = SRV_PSERIAL_SerialCfmMessage(appData pSerialData cfmObj); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_PHY appData pSerialData length); } ",
							" Remarks None ",
							" SRV_PSERIAL_COMMAND Enum ",
							" C typedef enum { /* Get data configuration request */ SRV_PSERIAL_CMD_PHY_GET_CFG = 0 /* Get data configuration response */ SRV_PSERIAL_CMD_PHY_GET_CFG_RSP /* Set data configuration request */ SRV_PSERIAL_CMD_PHY_SET_CFG /* Set data configuration response */ SRV_PSERIAL_CMD_PHY_SET_CFG_RSP /* Get command request */ SRV_PSERIAL_CMD_PHY_CMD_CFG /* Get command response */ SRV_PSERIAL_CMD_PHY_CMD_CFG_RSP /* Send message data */ SRV_PSERIAL_CMD_PHY_SEND_MSG /* Send message data response */ SRV_PSERIAL_CMD_PHY_SEND_MSG_RSP /* Receive message data */ SRV_PSERIAL_CMD_PHY_RECEIVE_MSG /* Noise capture request */ SRV_PSERIAL_CMD_PHY_NOISE_REQ /* Noise capture response */ SRV_PSERIAL_CMD_PHY_NOISE_RSP /* Get parameter list */ SRV_PSERIAL_CMD_PHY_GET_CFG_LIST /* Parameter list response */ SRV_PSERIAL_CMD_PHY_GET_CFG_LIST_RSP /* Reset PHY layer */ SRV_PSERIAL_CMD_PHY_RESET_PHY_LAYER } SRV_PSERIAL_COMMAND; ",
							" Summary List of PLC Serial Commands ",
							" Description This enumeration defines the PLC commands used by PLC Phy Tester Tool provided by Microchip ",
							" PLC PVDD Monitor Service This service aims to protect the amplification stage for the main transmission branch integrated in PL460 device ",
							" How the Library Works To assure the integrity of the amplification stage embedded in the PL460 device the PVDD Monitor service implements a window comparator in which the power supply of PLC driver amplifier and regulators (PVDDAMP) is monitored via ADC PLIB SRV_PVDDMON_blocks2 If this voltage is outside the allowed thresholds PLC transmission must not be performed as it could destroy the output stage of the PLC driver amplifier To enable PLC transmission act on the TX Enable pin of the PL460 SRV_PVDDMON_signals Hysteresis thresholding has been implemented by taking a fixed value of 100mV as a reference ",
							" Using The Library The PLC PVDD Monitor service must be used from within the PLC application to monitor whether PLC transmissions are allowed PLC PVDD Monitor service requires a callback to be set in order to notify PVDD Threshold events to the user Example application to monitor PVDD voltage to allow PLC transmissions APP_PLC_DATA appPlc; static void APP_PLC_PVDDMonitorCb( SRV_PVDDMON_CMP_MODE cmpMode uintptr_t context ) { (void)context; if (cmpMode == SRV_PVDDMON_CMP_MODE_OUT) { /* PLC Transmission is not permitted */ DRV_PLC_PHY_EnableTX(appPlc drvPl360Handle false); appPlc pvddMonTxEnable = false; /* Restart PVDD Monitor to check when VDD is within the comparison window */ SRV_PVDDMON_Restart(SRV_PVDDMON_CMP_MODE_IN); } else { /* PLC Transmission is permitted again */ DRV_PLC_PHY_EnableTX(appPlc drvPl360Handle true); appPlc pvddMonTxEnable = true; /* Restart PVDD Monitor to check when VDD is out of the comparison window */ SRV_PVDDMON_Restart(SRV_PVDDMON_CMP_MODE_OUT); } } void APP_PLC_Initialize ( void ) { /* Set PVDD Monitor tracking data */ appPlc pvddMonTxEnable = true; } void APP_PLC_Tasks ( void ) { /* Check the application's current state */ switch ( appPlc state ) { case APP_PLC_STATE_IDLE: { /* Initialize PLC driver */ appPlc state = APP_PLC_STATE_INIT; } break; case APP_PLC_STATE_INIT: { /* Open PLC driver */ appPlc drvPl360Handle = DRV_PLC_PHY_Open(DRV_PLC_PHY_INDEX_0 NULL); if (appPlc drvPl360Handle = DRV_HANDLE_INVALID) { appPlc state = APP_PLC_STATE_OPEN; } else { appPlc state = APP_PLC_STATE_ERROR; } break; } case APP_PLC_STATE_OPEN: { /* Check PLC transceiver */ if (DRV_PLC_PHY_Status(DRV_PLC_PHY_INDEX_0) == SYS_STATUS_READY) { /* Configure PLC callbacks */ DRV_PLC_PHY_DataCfmCallbackRegister(appPlc drvPl360Handle APP_PLC_DataCfmCb NULL); DRV_PLC_PHY_DataIndCallbackRegister(appPlc drvPl360Handle APP_PLC_DataIndCb NULL); /* Apply PLC initial configuration */ APP_PLC_SetInitialConfiguration(); /* Enable PLC Transmission */ DRV_PLC_PHY_EnableTX(appPlc drvPl360Handle true); /* Enable PLC PVDD Monitor Service */ SRV_PVDDMON_RegisterCallback(APP_PLC_PVDDMonitorCb 0); SRV_PVDDMON_Start(SRV_PVDDMON_CMP_MODE_OUT); /* Set PLC state to transmit a frame */ appPlc state = APP_PLC_STATE_TX_REQUEST; } } break; } } bool APP_PLC_SendData ( uint8_t* pData uint16_t length ) { if (appPlc state == APP_PLC_STATE_WAITING) { if (appPlc pvddMonTxEnable) { if ((length 0) (length = APP_PLC_BUFFER_SIZE)) { /* Set data length in Tx Parameters structure */ /* It should be equal or less than Maximum Data Length (see _get_max_psdu_len) */ /* Otherwise DRV_PLC_PHY_TX_RESULT_INV_LENGTH will be reported in Tx Confirm */ appPlcTx pl360Tx dataLength = length; memcpy(appPlcTx pDataTx pData length); appPlc plcTxState = APP_PLC_TX_STATE_WAIT_TX_CFM; DRV_PLC_PHY_TxRequest(appPlc drvPl360Handle appPlcTx pl360Tx); /* Set PLC state */ if (appPlc plcTxState == APP_PLC_TX_STATE_WAIT_TX_CFM) { appPlc state = APP_PLC_STATE_WAITING_TX_CFM; return true; } } } } return false; } ",
							" Configuring The Library PVDD Monitor Service Specific User Configurations PVDD Monitor Service library should be configured via MCC Below is the Snapshot of the MCC configuration window for PVDD Monitor Service and brief description PVDD Monitor Service Project graph SRV_PVDDMON_mcc_project_graph PVDD Monitor Service configuration options SRV_PVDDMON_mcc_configuration Peripheral lib: Indicates the ADC peripheral instance used by the PVDD Monitor Service The name of the peripheral will vary from device to device Channel: ADC channel to use with PVDD Monitor Service according to the HW board design PL460 Evaluation Kit has been designed to provide a Supply Monitor pin through the Xplained PRO connector PL460-EK Xplained PRO connector SRV_PVDDMON_XplainProSCH This Supply Monitor pin should be connected to the ADC peripheral so that connection determines what ADC channel should be used Result Resolution bits: ADC conversion resolution Voltage Monitor hardware configuration: PL460-EK evaluation kit includes a specific circuit to monitor VDD voltage PL460-EK Supply Monitor SRV_PVDDMON_SupplyMonitorSCH Resistor Up: Value in ohms of the HW resistor connected to VDD In case of PL460-EK it is R51 Resistor Down: Value in ohms of the HW resistor connected to GND In case of PL460-EK it is R53 Comparison Window thresholds: Threshold values to configure the comparison window of the PVDD Monitor service High Threshold: The PLC transmission shall not take place when the PVDD level is above the high threshold value Low Threshold: The PLC transmission shall not take place when the PVDD level is under the low threshold value ADC Configurations There are some configuration values which must be adjusted manually in ADC PLIB configuration options to match the values configured in PVDD Monitor service These configuration values are the following: Result Resolution Conversion mode must be configured manually in FreeRun mode Enable the proper channel according to the board HW design ADC End of conversion interrupt must be enable manually ADC PLIB configuration options SRV_PVDDMON_ADC_mcc_configuration ",
							" Library Interface PLC PVDD Monitor service provides the following interfaces: Functions Name Description SRV_PVDDMON_Initialize Initializes the PVDD Monitor service SRV_PVDDMON_Start Start the PVDD Monitor service according to the requested comparison mode SRV_PVDDMON_Restart Restart the PVDD Monitor service allowing to change the comparison mode SRV_PVDDMON_CallbackRegister Allows a client to set a PVDD Monitor event handling function for the service to call back when the value of the analog signal crosses any fixed threshold value Data types and constants Name Type Description SRV_PVDDMON_CALLBACK Typedef Pointer to a PVDD Monitor Event handler function SRV_PVDDMON_CMP_MODE Enum Defines the comparison mode ",
							" SRV_PVDDMON_CMP_MODE Enum ",
							" C typedef enum { /* Notify when PVDD level enters the comparison window */ SRV_PVDDMON_CMP_MODE_IN /* Notify when PVDD level leaves the comparison window */ SRV_PVDDMON_CMP_MODE_OUT } SRV_PVDDMON_CMP_MODE; ",
							" Summary Defines two comparison modes ",
							" Description This will be used to set the comparison mode ",
							" SRV_PVDDMON_CALLBACK Typedef ",
							" C typedef void (*SRV_PVDDMON_CALLBACK)( SRV_PVDDMON_CMP_MODE cmpMode uintptr_t context ); ",
							" Summary Pointer to a PVDD Monitor Event handler function ",
							" Description This data type defines the required function signature for the PVDD Monitor Event handling callback function A client must register a pointer using the callback register function whose function signature match the types specified by this function pointer in order to receive a notification related the comparison event ",
							" Parameters Param Description cmpMode Comparison mode - SRV_PVDDMON_CMP_MODE context Pointer to parameters to be passed to Handler function ",
							" Returns None ",
							" Example static void APP_PLC_PVDDMonitorCb( SRV_PVDDMON_CMP_MODE cmpMode uintptr_t context ) { (void)context; if (cmpMode == SRV_PVDDMON_CMP_MODE_OUT) { /* PLC Transmission is not permitted */ DRV_PLC_PHY_EnableTX(appPlc drvPl360Handle false); appPlc pvddMonTxEnable = false; /* Restart PVDD Monitor to check when VDD is within the comparison window */ SRV_PVDDMON_Restart(SRV_PVDDMON_CMP_MODE_IN); } else { /* PLC Transmission is permitted again */ DRV_PLC_PHY_EnableTX(appPlc drvPl360Handle true); appPlc pvddMonTxEnable = true; /* Restart PVDD Monitor to check when VDD is out of the comparison window */ SRV_PVDDMON_Restart(SRV_PVDDMON_CMP_MODE_OUT); } } ",
							" SRV_PVDDMON_Initialize Function ",
							" C void SRV_PVDDMON_Initialize ( void ); ",
							" Summary Initializes the PVDD Monitor service ",
							" Description This routine initializes the PVDD Monitor service making it ready for clients to start and use it ",
							" Parameters None ",
							" Returns None ",
							" Example /* Init PVDD Monitor service */ SRV_PVDDMON_Initialize(); ",
							" SRV_PVDDMON_Start Function ",
							" C void SRV_PVDDMON_Start ( SRV_PVDDMON_CMP_MODE cmpMode ); ",
							" Summary Start the PVDD Monitor service ",
							" Description This routine starts the PVDD Monitor service configuring the ADC plib and setting the comparison mode ",
							" Parameters Param Description cmpMode Comparison mode - SRV_PVDDMON_CMP_MODE ",
							" Returns None ",
							" Example /* Enable PLC PVDD Monitor Service */ SRV_PVDDMON_CallbackRegister(APP_PLC_PVDDMonitorCb 0); /* Notify when PVDD level leaves the comparison window */ SRV_PVDDMON_Start(SRV_PVDDMON_CMP_MODE_OUT); ",
							" Remarks Function SRV_PVDDMON_Initialize must have been called before calling this function PVDD Monitor event handler must have been set before calling this function to be able to receive the PVDD Monitor events ",
							" SRV_PVDDMON_Restart Function ",
							" C void SRV_PVDDMON_Restart ( SRV_PVDDMON_CMP_MODE cmpMode ); ",
							" Summary Restart the PVDD Monitor service ",
							" Description This routine restarts the PVDD Monitor service and allows clients to modify the comparison mode in runtime This routine is commonly used in the PVDD Monitor event handler to switch the comparison mode once ADC has been previously configured and is running ",
							" Parameters Param Description cmpMode Comparison mode - SRV_PVDDMON_CMP_MODE ",
							" Returns None ",
							" Example static void APP_PLC_PVDDMonitorCb( SRV_PVDDMON_CMP_MODE cmpMode uintptr_t context ) { (void)context; if (cmpMode == SRV_PVDDMON_CMP_MODE_OUT) { /* PLC Transmission is not permitted */ DRV_PLC_PHY_EnableTX(appPlc drvPl360Handle false); appPlc pvddMonTxEnable = false; /* Restart PVDD Monitor to check when VDD is within the comparison window */ SRV_PVDDMON_Restart(SRV_PVDDMON_CMP_MODE_IN); } else { /* PLC Transmission is permitted again */ DRV_PLC_PHY_EnableTX(appPlc drvPl360Handle true); appPlc pvddMonTxEnable = true; /* Restart PVDD Monitor to check when VDD is out of the comparison window */ SRV_PVDDMON_Restart(SRV_PVDDMON_CMP_MODE_OUT); } } ",
							" Remarks Function SRV_PVDDMON_Start must have been called before calling this function ",
							" SRV_PVDDMON_CallbackRegister Function ",
							" C void SRV_PVDDMON_CallbackRegister ( SRV_PVDDMON_CALLBACK callback uintptr_t context ); ",
							" Summary Allows a client to identify a PVDD Monitor event handling function to call back when the PVDD level is in/out comparison window ",
							" Description The callback once set persists until the client closes the sets another callback (which could be a \"NULL\" pointer to indicate no callback) ",
							" Parameters Param Description callback Pointer to the callback function context The value of parameter will be passed back to the client unchanged when the callback function is called ",
							" Returns None ",
							" Example /* Enable PLC PVDD Monitor Service */ SRV_PVDDMON_CallbackRegister(APP_PLC_PVDDMonitorCb 0); /* Notify when PVDD level leaves the comparison window */ SRV_PVDDMON_Start(SRV_PVDDMON_CMP_MODE_OUT); ",
							" Remarks None ",
							" PLC CRC Service Some Smart Energy components such as PLC stacks and the USI Service for seralization use CRCs to protect frame integrity on communication media (PLC or Serial) This library offers CRC calculation/verification as a unified service allowing addition/modification of available CRCs in a single module accessible by all consumers at the same time ",
							" How the Library Works This library does not need to be neither initialized nor maintained periodically It simply receives a request to calculate a CRC with a set of parameters and returns back the computed CRC It can be invoked at any time no preconditions or maintenance are requested ",
							" Using The Library The CRC library is called to compute the CRC of a given length (8 16 32 bits) to append to a data buffer on transmission and to verify the correctness of a received frame and its CRC The following example illustrates how the USI service computes the CRC of a received frame to verify frame integrity Example implementation of CRC library usage for frame validation static void _SRV_USI_Callback_Handle ( uint8_t *pData uint16_t length uintptr_t context ) { uint32_t crcGetValue; uint32_t crcRcvValue; SRV_USI_PROTOCOL_ID protocol; PCRC_CRC_TYPE crcType; if (length) { /* New received message */ /* Extract Protocol */ protocol = (SRV_USI_PROTOCOL_ID)USI_TYPE_PROTOCOL(*(pData + 1)); /* Get CRC type from Protocol */ crcType = _SRV_USI_GetCRCTypeFromProtocol(protocol); /* Check CRC */ crcGetValue = SRV_PCRC_GetValue(pData length - (1 crcType) PCRC_HT_USI crcType 0); if (crcType == PCRC_CRC8) { crcRcvValue = (uint32_t)(*(pData + length - 1)); } else if (crcType == PCRC_CRC16) { crcRcvValue = (((uint32_t)(*(pData + length - 2))) 8) + (uint32_t)(*(pData + length - 1)); } else { crcRcvValue = (((uint32_t)(*(pData + length - 4))) 24) + (((uint32_t)(*(pData + length - 3))) 16) + (((uint32_t)(*(pData + length - 2))) 8) + (uint32_t)(*(pData + length - 1)); } if (crcGetValue = crcRcvValue) { /* Discard message */ return; } /* Correct frame process it */ } } ",
							" Configuring The Library The CRC Library has no configuration options It just satisfies the requirement of other libraries such as USI service as seen on the figure below CRC Service satisfies USI requirement SRV_PCRC_mcc_configuration ",
							" Library Interface PLC CRC library provides the following interfaces: Functions Name Description SRV_PCRC_GetValue Obtains the CRC for a data stream SRV_PCRC_SetSNAValue Sets SNA value to be used as initial value on further CRC calculations (used by PRIME stack) Data types and constants Name Type Description PCRC_HEADER_TYPE Enum The list of all header types supported by PRIME spec and specific type to use with USI service PCRC_CRC_TYPE Enum The list of all CRC types supported (8 16 and 32 bits) ",
							" SRV_PCRC_GetValue Function ",
							" C uint32_t SRV_PCRC_GetValue( uint8_t *pData size_t length PCRC_HEADER_TYPE hdrType PCRC_CRC_TYPE crcType uint32_t initValue ); ",
							" Summary Obtains the CRC for a data stream ",
							" Description This routine gets the CRC value (8 16 or 32 bits depending on arguments) of the data stream provided as argument ",
							" Precondition None ",
							" Parameters Param Description pData Pointer to buffer containing the data stream length Length of the data stream hdrType Header type to determine the method to obtain CRC It is different for USI and PRIME packets (GENERIC PROMOTION and BEACON) crcType CRC type (8 16 or 32 bits) Used only in case of header type PCRC_HT_USI initValue Initialization value for CRC computation Used only in case of header type PCRC_HT_USI ",
							" Returns If successful the routine returns a valid CRC value If an error occurs the return value is PCRC_INVALID Error can occur if hdrType or crcType are wrong Returned CRC is always a 32-bit value in case 8-bit or 16-bit CRC is calculated it is casted to 32-bit ",
							" Example uint32_t crc32; crc32 = SRV_PCRC_GetValue(pData length PCRC_HT_USI PCRC_CRC32); ",
							" Remarks None ",
							" SRV_PCRC_SetSNAValue Function ",
							" C void SRV_PCRC_SetSNAValue ( uint8_t* sna ); ",
							" Summary Sets SNA (Sub-Network Address) value to be used as initial value on further CRC calculations (used by PRIME stack) ",
							" Description This routine sets the value that will be set as the initial CRC value for computations related to PRIME stack as stated on PRIME specification ",
							" Precondition None ",
							" Parameters Param Description sna Pointer to buffer containing SNA value ",
							" Returns None ",
							" Example uint8_t sna[PCRC_SNA_SIZE]; SRV_PCRC_SetSNAValue(sna); ",
							" Remarks None ",
							" PCRC_HEADER_TYPE Enum ",
							" C typedef enum { PCRC_HT_GENERIC = 0 /* PRIME Generic Packet type */ PCRC_HT_PROMOTION = 1 /* PRIME Promotion Packet type */ PCRC_HT_BEACON = 2 /* PRIME Beacon Packet type */ PCRC_HT_USI = 3 /* USI Packet type */ }PCRC_HEADER_TYPE; ",
							" Summary List of packet types to enforce rules for CRC calculation ",
							" Description The list of all header types supported by PRIME spec and an specific type to use with USI service ",
							" PCRC_CRC_TYPE Enum ",
							" C typedef enum { PCRC_CRC8 = 0 /* 8-bit CRC */ PCRC_CRC16 = 1 /* 16-bit CRC */ PCRC_CRC32 = 2 /* 32-bit CRC */ PCRC_NOCRC = 3 /* No CRC */ }PCRC_CRC_TYPE; ",
							" Summary The list of all CRC types supported (8 16 and 32 bits) ",
							" Description List of CRC-length supported types and a special one to indicate that No CRC is calculated ",
							" USI Service The Smart Energy USI (Unified Serial Interface) Service is a multi-instance buffer model based driver interface which can be used in conjuction with another Smart Energy services/drivers to communicate with external devices through serial interfaces Key Features: Multi-instance: Provides interface to manage multiple instances of serial interfaces Multi-protocol: Each instance of USI service can manage different protocols through the same serial interface Supports UART serial interfaces Supports USB (CDC Device) serial interfaces Several tools can be used on the other side of serial interfaces: Microchip PLC PHY Tester Tool Microchip Smart Energy Python Libs Microchip Hybrid Sniffer Tool ",
							" How the Library Works USI service is a wrapper that provides the interface between the Smart Energy stacks and the serial communications channel (UART or USB CDC) For USI message transmission SRV_USI_Send_Message function is provided which packs the data into USI frame format and sends the message through serial interface For USI message reception the service unpacks the data and passes it through callback ( SRV_USI_CallbackRegister ) to the corresponding client depending on the USI protocol In the other side of the serial interface a similar implementation is needed in an external device to pack/unpack USI messages for the corresponding USI protocol Microchip provides PC tools and Python libraries which are used to manage different layers of the Smart Energy stacks ",
							" USI Frame Format The USI frame format is based on the HDLC specification used along with DLMS The Serial Communications Profile of the Management Plane defined in the PRIME specification also uses the same format Below is the structure of the USI frame and field description USI Frame Format USI general frame format 0x7E : Frame start/end identifier MSG LENGTH : Message payload length in bytes ( MESSAGE DATA field) PROTOCOL ID : USI protocol identifier MESSAGE DATA : Message payload (variable length) The format is defined by each protocol CRC : Error detection code for the message The CRC size is defined by each protocol (see the table below) For more information about CRC format see PLC CRC Service USI Protocol ( SRV_USI_PROTOCOL_ID Enum ) PROTOCOL ID CRC size (bits) SRV_USI_PROT_ID_MNGP_PRIME 0x00-0x07 32 SRV_USI_PROT_ID_SNIF_PRIME 0x13 16 SRV_USI_PROT_ID_PHY_SERIAL_PRIME 0x1F 16 SRV_USI_PROT_ID_PHY 0x22 16 SRV_USI_PROT_ID_SNIFF_G3 0x23 16 SRV_USI_PROT_ID_MAC_G3 0x24 16 SRV_USI_PROT_ID_ADP_G3 0x25 16 SRV_USI_PROT_ID_COORD_G3 0x26 16 SRV_USI_PROT_ID_PRIME_API 0x30 8 In order to detect the end of the message properly it is needed to add escape bytes to all fields described above: 0x7E bytes are replaced by 0x7D5E (2 bytes) 0x7D bytes are replaced by 0x7D5D (2 bytes) This adds overhead and has to be considered when configuring the size of USI service buffers The size of transmission buffers must be at least twice the size of the biggest message payload used (for the very worst case all bytes 0x7E or 0x7D) ",
							" USI Protocols Each protocol defines its own frame format for the USI payload data A specific PC tool or Python library is provided for each protocol ",
							" PHY Sniffer There are two USI protocols used to communicate with Microchip Hybrid Sniffer Tool one for PRIME ( SRV_USI_PROT_ID_SNIF_PRIME ) and one for G3 ( SRV_USI_PROT_ID_SNIFF_G3 ) For more information see PLC PHY Sniffer Service  ",
							" PLC PHY Serial There is one USI protocol used to serialize PLC PHY API ( SRV_USI_PROT_ID_PHY ) and communicate with Microchip PLC PHY Tester Tool or Microchip PLC PHY Python Libraries The protocol defines different sub-format for G3 and PRIME For more information see PLC PHY Serial Service  ",
							" Using The Library USI is a service that allows to send/receive messages to/from an external tool It is used in conjuction with another Smart Energy libraries to serialize different protocol layers Following example illustrate how to use the USI library along with PLC PHY driver and PLC PHY Serial service to serialize the PLC PHY API Example implementation of a PLC PHY API Serialization APP_DATA appData; static uint8_t pPLCDataTxBuffer[APP_PLC_DATA_BUFFER_SIZE]; static uint8_t pPLCDataRxBuffer[APP_PLC_DATA_BUFFER_SIZE]; static uint8_t pPLCDataPIBBuffer[APP_PLC_PIB_BUFFER_SIZE]; static uint8_t pSerialDataBuffer[APP_SERIAL_DATA_BUFFER_SIZE]; /* PLC Data Indication Callback */ static void APP_PLCDataIndCb(DRV_PLC_PHY_RECEPTION_OBJ *indObj uintptr_t context) { /* Send Received PLC message through USI */ if (indObj- dataLength) { size_t length; /* Serialize received message */ length = SRV_PSERIAL_SerialRxMessage(appData pSerialData indObj); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_PHY appData pSerialData length); } } /* PLC Data Confirm Callback */ static void APP_PLCDataCfmCb(DRV_PLC_PHY_TRANSMISSION_CFM_OBJ *cfmObj uintptr_t context) { size_t length; appData plcTxState = APP_PLC_TX_STATE_IDLE; /* Serialize received message */ length = SRV_PSERIAL_SerialCfmMessage(appData pSerialData cfmObj); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_PHY appData pSerialData length); } /* USI packet received Callback */ void APP_USIPhyProtocolEventHandler(uint8_t *pData size_t length) { /* Message received from PLC Tool - USART */ SRV_PSERIAL_COMMAND command; /* Process received message */ command = SRV_PSERIAL_GetCommand(pData); switch (command) { case SRV_PSERIAL_CMD_PHY_GET_CFG: { /* Extract PIB information */ SRV_PSERIAL_ParseGetPIB( appData plcPIB pData); if (DRV_PLC_PHY_PIBGet(appData drvPl360Handle appData plcPIB)) { size_t len; /* Serialize PIB data */ len = SRV_PSERIAL_SerialGetPIB(appData pSerialData appData plcPIB); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_PHY appData pSerialData len); } } break; case SRV_PSERIAL_CMD_PHY_SET_CFG: { /* Extract PIB information */ SRV_PSERIAL_ParseSetPIB( appData plcPIB pData); if (DRV_PLC_PHY_PIBSet(appData drvPl360Handle appData plcPIB)) { size_t len; /* Serialize PIB data */ len = SRV_PSERIAL_SerialSetPIB( appData pSerialData[1] appData plcPIB); /* Send through USI */ SRV_USI_Send_Message(appData srvUSIHandle SRV_USI_PROT_ID_PHY appData pSerialData len); } } break; case SRV_PSERIAL_CMD_PHY_SEND_MSG: { /* Set PLC TX State to wait Tx confirmation */ appData plcTxState = APP_PLC_TX_STATE_WAIT_TX_CFM; /* Capture and parse data from USI */ SRV_PSERIAL_ParseTxMessage( appData plcTxObj pData); /* Send Message through PLC */ DRV_PLC_PHY_Send(appData drvPl360Handle appData plcTxObj); } break; default: break; } } void APP_Initialize(void) { /* Place the App state machine in its initial state */ appData state = APP_STATE_INIT; /* Initialize PLC buffers */ appData plcTxObj pTransmitData = pPLCDataTxBuffer; appData plcRxObj pReceivedData = pPLCDataRxBuffer; appData plcPIB pData = pPLCDataPIBBuffer; appData pSerialData = pSerialDataBuffer; /* Init PLC TX status */ appData plcTxState = APP_PLC_TX_STATE_IDLE; } void APP_Tasks(void) { /* Check the application's current state */ switch(appData state) { /* Application's initial state */ case APP_STATE_INIT: { /* Open PLC driver : Start uploading process */ appData drvPl360Handle = DRV_PLC_PHY_Open(DRV_PLC_PHY_INDEX NULL); if (appData drvPl360Handle = DRV_HANDLE_INVALID) { /* Set Application to next state */ appData state = APP_STATE_REGISTER; } else { /* Set Application to ERROR state */ appData state = APP_STATE_ERROR; } break; } /* Waiting to PLC transceiver be opened and register callback functions */ case APP_STATE_REGISTER: { /* Check PLC transceiver */ if (DRV_PLC_PHY_Status(DRV_PLC_PHY_INDEX) == SYS_STATUS_READY) { /* Register PLC callback */ DRV_PLC_PHY_ExceptionCallbackRegister(appData drvPl360Handle APP_PLCExceptionCb DRV_PLC_PHY_INDEX); DRV_PLC_PHY_DataIndCallbackRegister(appData drvPl360Handle APP_PLCDataIndCb DRV_PLC_PHY_INDEX); DRV_PLC_PHY_DataCfmCallbackRegister(appData drvPl360Handle APP_PLCDataCfmCb DRV_PLC_PHY_INDEX); /* Open USI Service */ appData srvUSIHandle = SRV_USI_Open(SRV_USI_INDEX_0); if (appData srvUSIHandle = DRV_HANDLE_INVALID) { /* Set Application to next state */ appData state = APP_STATE_CONFIG_USI; } else { /* Set Application to ERROR state */ appData state = APP_STATE_ERROR; } } break; } case APP_STATE_CONFIG_USI: { if (SRV_USI_Status(appData srvUSIHandle) == SRV_USI_STATUS_CONFIGURED) { /* Register USI callback */ SRV_USI_CallbackRegister(appData srvUSIHandle SRV_USI_PROT_ID_PHY APP_USIPhyProtocolEventHandler); /* Set Application to next state */ appData state = APP_STATE_CONFIG_PLC; } break; } case APP_STATE_CONFIG_PLC: { /* Set PLC configuration (differs from G3 to PRIME) */ /* */ /* Set Application to next state */ appData state = APP_STATE_READY; break; } case APP_STATE_READY: { /* Check USI status in case of USI device has been reset */ if (SRV_USI_Status(appData srvUSIHandle) == SRV_USI_STATUS_NOT_CONFIGURED) { /* Set Application to next state */ appData state = APP_STATE_CONFIG_USI; } /* Else just wait for events to trigger callbacks */ break; } case APP_STATE_ERROR: { /* Handle error in application's state machine */ break; } /* The default state should never be executed */ default: { break; } } } ",
							" Configuring The Library USI Service is configured via MCC The following snapshots show the MCC configuration window for USI Service and brief description USI Service common configuration options for all instances SRV_USI_mcc_usi Received Message Pool Size Specifies the maximum number of received USI messages (of any length) that can be stored without calling SRV_USI_Tasks for all instances using UART (not used for instances using USB CDC) UART API UART Connections Indicates the number of USI instances using UART CDC API CDC Connections Indicates the number of USI instances using USB CDC Each USI instance can be connected to: Peripheral Library with UART capability (UART/USART/FLEXCOM/SERCOM) USB CDC Function Driver ( USB_DEVICE_CDC capability) The user must connect only one dependency to each USI instance Altough it is allowed in MCC to connect an instance to both UART and USB_DEVICE_CDC it is not supported by the library and the code will not be generated properly USI Service configuration options for UART instance SRV_USI_mcc_usi_uart Device Used Indicates the hardware PLIB instance used by the corresponding instance of USI Service The underlying PLIB is automatically configured in Non-blocking mode as shown in the figure below Read Buffer Size Size in bytes of the buffer used by the corresponding USI instance for message reception Note that the buffer can store more than one received message ( Received Message Pool Size ) if a new message is received before calling SRV_USI_Tasks Write Buffer Size Size in bytes of the buffer used by the corresponding USI instance for message transmission Note that USI adds overhead (start/end marks USI header escaped characters) to the message sent to SRV_USI_Send_Message UART Peripheral configuration SRV_USI_mcc_uart USI Service configuration options for USB CDC instance SRV_USI_mcc_usi_cdc Device Used Indicates the USB CDC Instance used by the corresponding instance of USI Service The user should configure cdc_com_port_single_demo in the USB Device Layer module as shown in the figure below Read Buffer Size Size in bytes of the buffer used by the corresponding USI instance for message reception Write Buffer Size Size in bytes of the buffer used by the corresponding USI instance for message transmission Note that USI adds overhead (start/end marks USI header escaped characters) to the message sent to SRV_USI_Send_Message USB Device Layer configuration SRV_USI_mcc_cdc ",
							" Library Interface USI service library provides the following interfaces: Functions Name Description SRV_USI_Initialize Initializes the specified USI service instance SRV_USI_Open Opens the specified USI service instance and returns a handle to it SRV_USI_Close Closes an opened-instance of the USI service SRV_USI_Status Returns the current status of the USI service SRV_USI_CallbackRegister Registers a function to be called back when a new message is received and it belongs to the specified USI protocol SRV_USI_Tasks Maintains the USI's state machine SRV_USI_Send_Message Sends a message through serial interface (USI) Data types and constants Name Type Description SRV_USI_PROTOCOL_ID Enum List of available USI protocols SRV_USI_STATUS Enum List of possible values of USI status SRV_USI_HANDLE Typedef Handle to an opened instance of the USI service SRV_USI_HANDLE_INVALID Macro Definition of invalid USI handle SRV_USI_CALLBACK Typedef Pointer to an USI service callback function SRV_USI_DEV_DESC Struct Contains the API required by the USI service to abstract from the hardware peripheral used SRV_USI_INIT Struct Contains the data required to initialize an instance of the USI service ",
							" SRV_USI_Initialize Function ",
							" C SYS_MODULE_OBJ SRV_USI_Initialize( const SYS_MODULE_INDEX index const SYS_MODULE_INIT * const init) ",
							" Summary Initializes the specified USI service instance ",
							" Description This routine initializes the specified USI service instance making it ready for clients to open and use The initialization data is specified by the init parameter The initialization may fail if the number of instances allocated are insufficient or if the specified instance is already initialized The USI service instance index is independent of the peripheral instance it is associated with For example USI service instance 0 can be assigned to UART peripheral instance 2 ",
							" Parameters Param Description index Index for the instance to be initialized init Pointer to the init data structure containing any data necessary to initialize the service ",
							" Returns If successful returns a valid USI instance object Otherwise returns SYS_MODULE_OBJ_INVALID  ",
							" Example static uint8_t CACHE_ALIGN srvUSI0ReadBuffer[SRV_USI0_RD_BUF_SIZE] = {0}; static uint8_t CACHE_ALIGN srvUSI0WriteBuffer[SRV_USI0_WR_BUF_SIZE] = {0}; /* Declared in USI USART service implementation (srv_usi_usart c) */ extern const SRV_USI_DEV_DESC srvUSIUSARTDevDesc; const SRV_USI_USART_INTERFACE srvUsi0InitDataUART2 = { readCallbackRegister = (USI_USART_PLIB_READ_CALLBACK_REG)UART2_ReadCallbackRegister read = (USI_USART_PLIB_WRRD)UART2_Read write = (USI_USART_PLIB_WRRD)UART2_Write writeIsBusy = (USI_USART_PLIB_WRITE_ISBUSY)UART2_WriteIsBusy }; const USI_USART_INIT_DATA srvUsi0InitData = { plib = (void*) srvUsi0InitDataUART2 pRdBuffer = (void*)srvUSI0ReadBuffer rdBufferSize = SRV_USI0_RD_BUF_SIZE }; const SRV_USI_INIT srvUSI0Init = { deviceInitData = (const void*) srvUsi0InitData consDevDesc = srvUSIUSARTDevDesc deviceIndex = 0 pWrBuffer = srvUSI0WriteBuffer wrBufferSize = SRV_USI0_WR_BUF_SIZE }; static uint8_t CACHE_ALIGN srvUSI1ReadBuffer[SRV_USI1_RD_BUF_SIZE] = {0}; static uint8_t CACHE_ALIGN srvUSI1WriteBuffer[SRV_USI1_WR_BUF_SIZE] = {0}; static uint8_t CACHE_ALIGN srvUSI1CDCReadBuffer[128] = {0}; /* Declared in USI CDC service implementation (srv_usi_cdc c) */ extern const SRV_USI_DEV_DESC srvUSICDCDevDesc; const USI_CDC_INIT_DATA srvUsi1InitData = { cdcInstanceIndex = 0 usiReadBuffer = srvUSI1ReadBuffer usiBufferSize = SRV_USI1_RD_BUF_SIZE cdcReadBuffer = srvUSI1CDCReadBuffer cdcBufferSize = 128 }; const SRV_USI_INIT srvUSI1Init = { deviceInitData = (const void*) srvUsi1InitData consDevDesc = srvUSICDCDevDesc deviceIndex = 0 pWrBuffer = srvUSI1WriteBuffer wrBufferSize = SRV_USI1_WR_BUF_SIZE }; SYS_MODULE_OBJ objSrvUSI0; SYS_MODULE_OBJ objSrvUSI1; objSrvUSI0 = SRV_USI_Initialize(SRV_USI_INDEX_0 (SYS_MODULE_INIT *) srvUSI0Init); if (objSrvUSI0 == SYS_MODULE_OBJ_INVALID) { // Handle error } objSrvUSI1 = SRV_USI_Initialize(SRV_USI_INDEX_1 (SYS_MODULE_INIT *) srvUSI1Init); if (objSrvUSI1 == SYS_MODULE_OBJ_INVALID) { // Handle error } ",
							" Remarks This routine must be called before any other USI routine is called This routine should only during system initialization ",
							" SRV_USI_Open Function ",
							" C SRV_USI_HANDLE SRV_USI_Open( const SYS_MODULE_INDEX index ) ",
							" Summary Opens the specified USI service instance and returns a handle to it ",
							" Description This routine opens the specified USI service instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the service ",
							" Precondition Function SRV_USI_Initialize must have been called before calling this function ",
							" Parameters Param Description index Index for the instance to be opened ",
							" Returns If successful the routine returns a valid open-instance handle ( SRV_USI_HANDLE Typedef ) If an error occurs the return value is SRV_USI_HANDLE_INVALID Error can occur if the specified instance has been already opened if the instance being opened is not initialized or is invalid if there is an error opening the serial interface (USB CDC instances only) ",
							" Example SRV_USI_HANDLE handle; handle = SRV_USI_Open(SRV_USI_INDEX_0); if (handle == SRV_USI_HANDLE_INVALID) { // Unable to open USI instance Maybe it is not initialized } ",
							" Remarks The handle returned is valid until SRV_USI_Close is called ",
							" SRV_USI_Close Function ",
							" C void SRV_USI_Close( const SRV_USI_HANDLE handle ) ",
							" Summary Closes an opened-instance of the USI service ",
							" Description This routine closes an opened-instance of the USI service invalidating the handle A new handle must be obtained by calling SRV_USI_Open before the caller uses the service again ",
							" Precondition SRV_USI_Open must have been called to obtain a valid opened service handle ",
							" Parameters Param Description handle A valid open-instance handle returned from SRV_USI_Open ",
							" Returns None ",
							" Example // 'handle' returned from SRV_USI_Open previously called SRV_USI_Close(handle); ",
							" Remarks None ",
							" SRV_USI_Status Function ",
							" C SRV_USI_STATUS SRV_USI_Status( SRV_USI_HANDLE handle ) ",
							" Summary Returns the current status of the USI service ",
							" Description This routine provides the current status of the USI service instance ",
							" Precondition SRV_USI_Open must have been called to obtain a valid opened service handle ",
							" Parameters Param Description handle A valid open-instance handle returned from SRV_USI_Open ",
							" Returns Current status of the USI service instance ( SRV_USI_STATUS Enum ) ",
							" Example // 'handle' returned from SRV_USI_Open previously called if (SRV_USI_Status (handle) == SRV_USI_STATUS_CONFIGURED) { // USI service is initialized and ready to accept new requests } ",
							" Remarks After opening an USI instance before any other operation the client must use this function to check the instance is ready ",
							" SRV_USI_CallbackRegister Function ",
							" C void SRV_USI_CallbackRegister( const SRV_USI_HANDLE handle SRV_USI_PROTOCOL_ID protocol SRV_USI_CALLBACK callback) ",
							" Summary Registers a function to be called back when a new message is received and it belongs to the specified USI protocol ",
							" Description This function allows a client to register an event handling function to be called back when a new message is received and it belongs to the specified USI protocol One USI instance can have different callbacks for different USI protocols The callback once set persists until the client closes the USI service instance or sets another callback (which could be a NULL pointer to indicate no callback) ",
							" Precondition SRV_USI_Open must have been called to obtain a valid opened service handle ",
							" Parameters Param Description handle A valid open-instance handle returned from SRV_USI_Open protocol Identifier of the protocol for which callback function will be registered ( SRV_USI_PROTOCOL_ID Enum ) callback Pointer to the callback function ( SRV_USI_CALLBACK Typedef ) ",
							" Returns None ",
							" Example void APP_USIPhyProtocolEventHandler(uint8_t *pData size_t length) { /* Message received from external tool */ } // 'handle' returned from SRV_USI_Open previously called SRV_USI_CallbackRegister(handle SRV_USI_PROT_ID_PHY APP_USIPhyProtocolEventHandler); ",
							" Remarks If the client only needs to send USI messages (not receive them) it does not need to register a callback The USI service manages the peripheral interrupts internally but the registered function is called inside SRV_USI_Tasks which simplifies the thread safety management at client level ",
							" SRV_USI_Tasks Function ",
							" C void SRV_USI_Tasks( const SYS_MODULE_INDEX index ) ",
							" Summary Maintains the USI's state machine ",
							" Description This function is used to maintain the USI's internal state machine and generate callback functions ",
							" Precondition SRV_USI_Initialize must have been called for the specified USI service instance ",
							" Parameters Param Description index Index for the instance to maintain its state machine ",
							" Returns None ",
							" Example while (true) { SRV_USI_Tasks(SRV_USI_INDEX_0); // Do other tasks } ",
							" Remarks This function is normally not called directly by an application It is called by the system's Tasks routine ( SYS_Tasks ) This function will never block or access any resources that may cause it to block ",
							" SRV_USI_Send_Message Function ",
							" C void SRV_USI_Send_Message( const SRV_USI_HANDLE handle SRV_USI_PROTOCOL_ID protocol uint8_t *data size_t length ) ",
							" Summary Sends a message through serial interface (USI) ",
							" Description This function is used to send a message through USI The message will be formated depending on the specified Protocol and will be sent using the serial interface associated to the corresponding USI instance ",
							" Precondition SRV_USI_Open must have been called to obtain a valid opened service handle ",
							" Parameters Param Description handle A valid open-instance handle returned from SRV_USI_Open protocol Identifier of the protocol for the message to send ( SRV_USI_PROTOCOL_ID Enum ) data Pointer to the data to send length Length of the data to send in bytes ",
							" Returns None ",
							" Example uint8_t pData[] = \"Message to send through USI\"; // 'handle' returned from SRV_USI_Open previously called SRV_USI_Send_Message(handle SRV_USI_PROT_ID_PHY pData sizeof(pData)); ",
							" Remarks None ",
							" SRV_USI_PROTOCOL_ID Enum ",
							" C typedef enum { /* PRIME Manager generic */ SRV_USI_PROT_ID_MNGP_PRIME = 0x00 /* PRIME Manager: GETQRY */ SRV_USI_PROT_ID_MNGP_PRIME_GETQRY = 0x00 /* PRIME Manager: GETRSP */ SRV_USI_PROT_ID_MNGP_PRIME_GETRSP = 0x01 /* PRIME Manager: SET */ SRV_USI_PROT_ID_MNGP_PRIME_SET = 0x02 /* PRIME Manager: RESET */ SRV_USI_PROT_ID_MNGP_PRIME_RESET = 0x03 /* PRIME Manager: REBOOT */ SRV_USI_PROT_ID_MNGP_PRIME_REBOOT = 0x04 /* PRIME Manager: Firmware Upgrade */ SRV_USI_PROT_ID_MNGP_PRIME_FU = 0x05 /* PRIME Manager: GETQRY enhanced */ SRV_USI_PROT_ID_MNGP_PRIME_GETQRY_EN = 0x06 /* PRIME Manager: GETRSP enhanced */ SRV_USI_PROT_ID_MNGP_PRIME_GETRSP_EN = 0x07 /* PRIME Sniffer */ SRV_USI_PROT_ID_SNIF_PRIME = 0x13 /* PRIME PHY Serial */ SRV_USI_PROT_ID_PHY_SERIAL_PRIME = 0x1F /* Physical Layer */ SRV_USI_PROT_ID_PHY = 0x22 /* G3 Sniffer */ SRV_USI_PROT_ID_SNIFF_G3 = 0x23 /* G3 MAC layer */ SRV_USI_PROT_ID_MAC_G3 = 0x24 /* G3 ADP layer */ SRV_USI_PROT_ID_ADP_G3 = 0x25 /* G3 Coordinator */ SRV_USI_PROT_ID_COORD_G3 = 0x26 /* MicroPLC Physical Layer */ SRV_USI_PROT_ID_PHY_MICROPLC = 0x27 /* PRIME API */ SRV_USI_PROT_ID_PRIME_API = 0x30 /* Invalid protocol */ SRV_USI_PROT_ID_INVALID = 0xFF } SRV_USI_PROTOCOL_ID; ",
							" Summary List of available USI protocols ",
							" Description This data type defines the identifier required to specify the protocol to use by USI service ",
							" Remarks None ",
							" SRV_USI_STATUS Enum ",
							" C typedef enum { SRV_USI_STATUS_UNINITIALIZED SRV_USI_STATUS_NOT_CONFIGURED SRV_USI_STATUS_CONFIGURED SRV_USI_STATUS_BUSY SRV_USI_STATUS_ERROR } SRV_USI_STATUS; ",
							" Summary List of possible values of USI status ",
							" Description This type defines the possible return values for SRV_USI_Status function ",
							" Remarks None ",
							" SRV_USI_HANDLE Typedef ",
							" C typedef uintptr_t SRV_USI_HANDLE; ",
							" Summary Handle to an opened instance of the USI service ",
							" Description This handle identifies an opened instance of the USI service It is returned from SRV_USI_Open and it has to be passed to all other USI routines (except SRV_USI_Initialize and SRV_USI_Tasks ) ",
							" Remarks None ",
							" SRV_USI_HANDLE_INVALID Macro ",
							" C #define SRV_USI_HANDLE_INVALID (((SRV_USI_HANDLE) -1)) ",
							" Summary Definition of invalid USI handle ",
							" Description This definition is used to indicate that an USI handle ( SRV_USI_HANDLE Typedef ) is invalid SRV_USI_Open returns this value if: the specified instance has been already opened the instance being opened is not initialized or is invalid if there is an error opening the serial interface (USB CDC instances only) ",
							" Remarks The handle returned from SRV_USI_Open should be checked to ensure it is different to SRV_USI_HANDLE_INVALID before attempting to call any other USI routine using the handle ",
							" SRV_USI_CALLBACK Typedef ",
							" C typedef void ( * SRV_USI_CALLBACK ) ( uint8_t *pData size_t length ); ",
							" Summary Pointer to an USI service callback function ",
							" Description This data type defines a pointer to an USI service callback function thus defining the function signature Clients of the USI service can register callback functions for a specific USI protocol with SRV_USI_CallbackRegister function That function will be called back when a new message is received and it belongs to the specified USI protocol ",
							" Parameters Param Description pData Pointer to data payload of the received USI message length Length in bytes of data payload of the received USI message ",
							" Returns None ",
							" Example void APP_USIPhyProtocolEventHandler(uint8_t *pData size_t length) { /* Message received from external tool */ } // 'handle' returned from SRV_USI_Open previously called SRV_USI_CallbackRegister(handle SRV_USI_PROT_ID_PHY APP_USIPhyProtocolEventHandler); ",
							" Remarks None ",
							" SRV_USI_DEV_DESC Struct ",
							" C typedef struct { SRV_USI_INIT_FPTR init; SRV_USI_OPEN_FPTR open; SRV_USI_REGISTER_READ_CALLBACK_FPTR setReadCallback; SRV_USI_WRITE_FPTR write; SRV_USI_TASK_FPTR task; SRV_USI_CLOSE close; SRV_USI_STATUS_FPTR status; } SRV_USI_DEV_DESC; ",
							" Summary Contains the API required by the USI service to abstract from the hardware peripheral used ",
							" Description This structure contains pointers to functions required by the USI service to abstract from the hardware peripheral used The USI service implements these functions for UART peripherals (see srv_usi_usart c ) and USB CDC Function Driver (see srv_usi_cdc c ) ",
							" Remarks The generated code will include srv_usi_usart c and/or srv_usi_cdc c files depending on the USI instance(s) MCC configuration ",
							" SRV_USI_INIT Struct ",
							" C typedef struct { const void* deviceInitData; const SRV_USI_DEV_DESC* consDevDesc; uint32_t deviceIndex; void* pWrBuffer; size_t wrBufferSize; } SRV_USI_INIT; ",
							" Summary Contains the data required to initialize an instance of the USI service ",
							" Description This structure contains the data needed to initialize an instance of the USI service It is passed as parameter (casted as SYS_MODULE_INIT ) to SRV_USI_Initialize function Field description: deviceInitData : Pointer to data initialization struct for the specific USI instance type; UART (see srv_usi_usart h ) or USB CDC (see srv_usi_cdc h ) consDevDesc : Pointer to SRV_USI_DEV_DESC Struct deviceIndex : USI instance index for the specific USI instance type (UART or USB CDC) pWrBuffer : Pointer to buffer to encode transmitted USI messages wrBufferSize : Size in bytes of buffer to encode transmitted USI messages ",
							" Remarks This initialization data struct is automatically generated for each USI instance depending on MCC configuration (see initialization c ) ",
							" Demo Meter Application Enter a short description of your concept here (optional)  This is the start of your concept  "];

