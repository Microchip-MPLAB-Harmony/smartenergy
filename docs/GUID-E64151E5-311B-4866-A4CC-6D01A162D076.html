<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE11" /><meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="DC.type" content="topic" />
<meta name="DC.title" content="Using The Library" />
<meta name="DC.relation" scheme="URI" content="GUID-2023FB1C-E7E7-4813-9BA3-480FEB57627B.html" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="using-the-library" />
<link rel="stylesheet" type="text/css" href="stylesheets/atmel.css" />
<title>Using The Library</title>
<meta name="Microsoft.Help.Id" content="GUID-87F4E49E-0A61-4067-B9CF-1FE226A94F9B-using-the-library" />
<meta name="Microsoft.Help.TocParent" content="GUID-87F4E49E-0A61-4067-B9CF-1FE226A94F9B" />
<meta name="Microsoft.Help.TocOrder" content="0" />
<meta name="Microsoft.Help.Locale" content="en-US" />
<meta name="Microsoft.Help.TopicLocale" content="en-US" />
<meta name="Microsoft.Help.DisplayVersion" content="MPLAB Harmony Smart Energy Library Reference A 02/2022" />
<script language="javascript">
       
       if (window.parent.location.protocol != 'file:') {
				document.addEventListener('click', function(e) {
				    if (e.target) {
               if (e.target.nodeName == "A" ) {
                    if (!e.target.target) {
                      e.preventDefault();
                      e.stopPropagation();
                              
                      var origUrl = window.parent.location.href.substr(0, window.parent.location.href.indexOf("?"));
                      if (origUrl.length === 0) {
                          origUrl = window.parent.location.href;
                      }
                      var href= e.target.getAttribute("href");
                      var parts = href.split("#");
          
                      var url = "";
                      if (parts.length == 2 ) {
                        if (!parts[0].length) {
                            url = window.parent.location.search.replace('?','')
                        } else {
                            url = parts[0].replace('.html','');
                        }
                      } else {
                        url = parts[0].replace('.html','');
                      }

                      if (parts.length == 2) {
                          url += "#" + parts[1];
                      }
    
                      window.parent.location.href = origUrl + "?" + url;

                      return false;
                    }
               }
            }
				});
			}

		</script><script language="javascript">
         
         function copyContent(content, button) {
         
            var textArea = document.createElement("textarea");
            
            // Place in the top-left corner of screen regardless of scroll position.
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            
            // Ensure it has a small width and height. Setting to 1px / 1em
            // doesn't work as this gives a negative w/h on some browsers.
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            
            // We don't need padding, reducing the size if it does flash render.
            textArea.style.padding = 0;
            
            // Clean up any borders.
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            
            // Avoid flash of the white box if rendered for any reason.
            textArea.style.background = 'transparent';
            
            textArea.value = content;
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
               var successful = document.execCommand('copy');
               var msg = successful ? 'successful' : 'unsuccessful';
               if (!button.classList.contains("copied")){
                  button.textContent = "Copied";
                  button.classList.add("copied");
                  setTimeout(function(){
                     button.textContent = "Copy";
                     button.classList.remove("copied");
                  },1000);
               }
            } catch (err) {
               console.log('Oops, unable to copy');
            }
            
            document.body.removeChild(textArea);
         }
         
         function cpy(id, button) {
            var element = document.getElementById(id);
            var content = element.getAttribute("content");
            
            copyContent(content, button);
         }
         
         document.addEventListener("DOMContentLoaded", function(event) {
            document.querySelectorAll(".codeblock").forEach(function(elem) {
               elem.style.position = "relative";
               var copy = document.createElement("button");
               copy.textContent = "Copy";
               copy.setAttribute("class", "copy-code");
               
               var content = elem.textContent;
               
               copy.addEventListener("click", function(){
                  copyContent(content, copy);
               });
               
               elem.addEventListener("mouseenter", function(evt){
                  elem.prepend(copy);
               });
            });
            
            document.querySelectorAll(".codeblock").forEach(function(elem) {
               elem.addEventListener("mouseleave", function(evt){
                  document.querySelector(".copy-code").remove();
               });
            });
         });
         
      </script><script language="javascript">
          
          // Add the MathML namespace to html
          var html = document.getElementsByTagName("html")[0],
          head = document.getElementsByTagName("head")[0];
          
          var mathJax = document.createElement("script");
          mathJax.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML";
          head.appendChild(mathJax);
          
          html.setAttribute("xmlns:m","http://www.w3.org/1998/Math/MathML");
          
          function inIframe() { try { return window.self !== window.top; } catch (e) { return true; } }
          
          if (!inIframe()) { 
          
          var Default = "index.html?GUID-E64151E5-311B-4866-A4CC-6D01A162D076"; 
          
          var displaylocation = "value" + window.location.href;
          
          var GUIDS = displaylocation.split('GUID');          
          
          if (displaylocation.indexOf('#GUID') != -1) {            
          var First = GUIDS[1].split('.html');  
          if (GUIDS[3]){First = GUIDS[2].split('.html');}
          if (GUIDS[4]){First = GUIDS[3].split('.html');}
          if (GUIDS[5]){First = GUIDS[4].split('.html');}
          
          var Second = GUIDS[2].split('#');   
          if (GUIDS[3]){Second = GUIDS[3].split('#');}
          if (GUIDS[4]){Second = GUIDS[4].split('#');}
          if (GUIDS[5]){Second = GUIDS[5].split('#');}
          
          Default = "index.html?" + "GUID" + First[0] + "GUID" + Second[0];     
          }                    
          window.top.location = Default;
          }       
          
        </script><link rel="stylesheet" type="text/css" href="syntax-highlight.css" /><style xml:space="">
        
          button.copy-code{
            display:none;
            padding:0.7em 1.4em;
            margin:0 0.3em 0.3em 0;
            border-radius:0.15em;
            box-sizing: border-box;
            text-decoration:none;
            font-family:'Roboto',sans-serif;
            text-transform:uppercase;
            font-weight:400;
            color:#FFFFFF;
            background-color:#9c9c9c;
            box-shadow:inset 0 -0.6em 0 -0.35em rgba(0,0,0,0.17);
            text-align:center;
            position:relative;
            border: 0;
            float: right;
            border-radius: .5em;
            cursor: pointer;
          }
          button.copy-code:active{
            top:0.1em;
          }
          
          pre:hover button.copy-code{
            display: inline-block !important;
          }
          button.copy-code.copied {
            cursor: default !important;
          }
          
          
          @media all and (max-width:30em){
            button.copy-code{
              display:block;
              margin:0.4em auto;
            }
          }
        
        
      </style><link rel="stylesheet" type="text/css" href="syntax-highlight.css" /></head>
<body id="using-the-library">
<h1 class="title topictitle1" id="ariaid-title1">Using The Library</h1><div class="body"><ul class="ul"><li class="li"><p class="p">The quantities available in the Metrology Module make observable all basic components required to completely define or derive all power system measurement quantities for most currently used definitions of power. All per-phase voltages, currents, and power for fundamental and fundamental + harmonics are available, allowing computation of all modern system or poly-phase power quantities.</p>
</li>
<li class="li"><p class="p">Measurement data from one measurement interval is short-lived and does not persist longer than one measurement interval. At the end of a measurement interval, the user will be informed by software interrupt at which point the user must read all pertinent quantities before the next measurement period ends.</p>
</li>
<li class="li"><p class="p">All computed quantities available through the Metrology Module are integrated over a time interval equivalent to an integral number of periods of the fundamental frequency. All integration periods are approximated by the final output sample rate of the DSP filters, 4000 Hz; so, measurement accuracy will increase using longer integration periods. One second is the recommended minimum integration period (50 cycles of 50Hz or 60 cycles of 60Hz), but fewer numbers of samples may still yield acceptable results.
DSP filters require a settling time before accurate measurements may be used for revenue-quality metering. It is recommended to wait at least 250ms after startup before testing when testing to revenue-grade accuracy.</p>
</li>
<li class="li"><p class="p">The Smart Meter DSP Module is specifically designed to accept samples from an ATSENSE Δ/Σ ADC using an OSR=64, at an input sample rate of 16.000 KHz. This input data stream is further filtered to an internal sample rate of 4.000 KHz for generation of metrology quantities. All computed metrology quantities are available at a rate of approximately 1Hz, when using recommended settings.</p>
</li>
<li class="li"><p class="p">DSP channel nomenclature defines 3 basic voltage channels: V_A, V_B and V_C, and 4 basic current channels: I_A, I_B, I_C, and measured neutral current,
I_ Nm. The current channels are combined to create an accumulated imputed neutral current, I_Ni, and an accumulated sample-by-sample difference between the measured and imputed neutral currents, I_Nmi.</p>
</li>
<li class="li"><p class="p">Values further labeled as “_F” indicate values associated with the fundamental frequency component only, while values without the “_F” indicate values associated with fundamental + harmonics.</p>
</li>
</ul>
<p class="p"><strong class="ph b">Example application to handle metrology driver based on FreeRTOS application</strong></p>
<pre class="pre codeblock c">
<strong class="hl-keyword">void</strong> SYS_Initialize ( <strong class="hl-keyword">void</strong>* data )
{
    (...)
    
    <em class="hl-comment">/* Initialize Metrology Driver Instance */</em>
    DRV_METROLOGY_Initialize((SYS_MODULE_INIT *)&amp;drvMetrologyInitData, RSTC_ResetCauseGet());
    
    (...)
}

<strong class="hl-keyword">static</strong> <strong class="hl-keyword">void</strong> <span class="hl-functions">_APP_METROLOGY_NewIntegrationCallback</span>(<strong class="hl-keyword">void</strong>)
{
    <strong class="hl-keyword">if</strong> (app_metrologyData.state == APP_METROLOGY_STATE_RUNNING)
    {
        <em class="hl-comment">/* Signal Metrology thread to update measurements for an integration period */</em>
        OSAL_SEM_PostISR(&amp;appMetrologySemID);
    }
}

<strong class="hl-keyword">void</strong> APP_METROLOGY_Initialize (<strong class="hl-keyword">void</strong>)
{
    <em class="hl-comment">/* Detection of the WDOG0 Reset */</em>
    <strong class="hl-keyword">if</strong> (RSTC_ResetCauseGet() == RSTC_SR_RSTTYP(RSTC_SR_RSTTYP_WDT0_RST_Val))
    {
        app_metrologyData.startMode = DRV_METROLOGY_START_SOFT;
    }
    <strong class="hl-keyword">else</strong>
    {
        app_metrologyData.startMode = DRV_METROLOGY_START_HARD;        
    }

    <em class="hl-comment">/* Get Pointers to metrology data regions */</em>
    app_metrologyData.pMetControl = DRV_METROLOGY_GetControl();
    app_metrologyData.pMetStatus = DRV_METROLOGY_GetStatus();
    app_metrologyData.pMetAccData = DRV_METROLOGY_GetAccData();
    app_metrologyData.pMetHarData = DRV_METROLOGY_GetHarData();
    
    <em class="hl-comment">/* Set Callback for each metrology integration process */</em>
    DRV_METROLOGY_IntegrationCallbackRegister(_APP_METROLOGY_NewIntegrationCallback);
    
    <em class="hl-comment">/* Clear Harmonic Analysis Data */</em>
    app_metrologyData.harmonicAnalysisPending = false;
    app_metrologyData.pHarmonicAnalisysCallback = NULL;
    app_metrologyData.pHarmonicAnalysisResponse = NULL;
    
    <em class="hl-comment">/* Clear Calibration Data */</em>
    app_metrologyData.pCalibrationCallback = NULL;

    <em class="hl-comment">/* Create the Switches Semaphore. */</em>
    <strong class="hl-keyword">if</strong> (OSAL_SEM_Create(&amp;appMetrologySemID, OSAL_SEM_TYPE_BINARY, <span class="hl-number">0</span>, <span class="hl-number">0</span>) == OSAL_RESULT_FALSE)
    {
        <em class="hl-comment">/* Handle error condition. Not sufficient memory to create semaphore */</em>
    }
    
    app_metrologyData.state = APP_METROLOGY_STATE_INIT;
}

<strong class="hl-keyword">void</strong> APP_METROLOGY_Tasks (<strong class="hl-keyword">void</strong>)
{
    APP_ENERGY_QUEUE_DATA newMetrologyData;
    APP_EVENTS_QUEUE_DATA newEvent;

    <em class="hl-comment">/* Check the application's current state. */</em>
    <strong class="hl-keyword">switch</strong> (app_metrologyData.state)
    {
        <em class="hl-comment">/* Application's initial state. */</em>
        <strong class="hl-keyword">case</strong> APP_METROLOGY_STATE_INIT:
        {
            <strong class="hl-keyword">if</strong> (DRV_METROLOGY_Open(app_metrologyData.startMode) == DRV_METROLOGY_SUCCESS)
            {
                <strong class="hl-keyword">if</strong> (app_metrologyData.startMode == DRV_METROLOGY_START_HARD)
                {
                    app_metrologyData.state = APP_METROLOGY_STATE_START;
                }
                <strong class="hl-keyword">else</strong>
                {
                    app_metrologyData.state = APP_METROLOGY_STATE_RUNNING;
                }
            }
            <strong class="hl-keyword">else</strong>
            {
                app_metrologyData.state = APP_METROLOGY_STATE_ERROR;
            }

            vTaskDelay(<span class="hl-number">10</span> / portTICK_PERIOD_MS);
            <strong class="hl-keyword">break</strong>;
        }

        <strong class="hl-keyword">case</strong> APP_METROLOGY_STATE_START:
        {
            <strong class="hl-keyword">if</strong> (DRV_METROLOGY_GetState() == DRV_METROLOGY_STATE_READY)
            {
                <strong class="hl-keyword">if</strong> (DRV_METROLOGY_Start() == DRV_METROLOGY_SUCCESS)
                {
                    app_metrologyData.state = APP_METROLOGY_STATE_RUNNING;
                }
                <strong class="hl-keyword">else</strong>
                {
                    app_metrologyData.state = APP_METROLOGY_STATE_ERROR;
                }

                vTaskDelay(<span class="hl-number">10</span> / portTICK_PERIOD_MS);
            }

            <strong class="hl-keyword">break</strong>;
        }

        <strong class="hl-keyword">case</strong> APP_METROLOGY_STATE_RUNNING:
        {
            <em class="hl-comment">/* Wait for the metrology semaphore to get measurements at the end of the integration period. */</em>
            OSAL_SEM_Pend(&amp;appMetrologySemID, OSAL_WAIT_FOREVER);
            
            <em class="hl-comment">/* Obtain RMS values and events */</em>
            DRV_METROLOGY_UpdateMeasurements();
            
            <em class="hl-comment">/* Send new Energy values to the Energy Task */</em>
            app_metrologyData.queueFree = uxQueueSpacesAvailable(appEnergyQueueID);
            <strong class="hl-keyword">if</strong> (app_metrologyData.queueFree)
            {
                newMetrologyData.energy = DRV_METROLOGY_GetEnergyValue(true);
                newMetrologyData.Pt = DRV_METROLOGY_GetRMSValue(RMS_PT);
                xQueueSend(appEnergyQueueID, &amp;newMetrologyData, (TickType_t) <span class="hl-number">0</span>);
            }
            <strong class="hl-keyword">else</strong>
            {
                SYS_CMD_MESSAGE(<span class="hl-string">"ENERGY Queue is FULL!!!\n\r"</span>);
            }
            
            <em class="hl-comment">/* Send new Events to the Events Task */</em>
            app_metrologyData.queueFree = uxQueueSpacesAvailable(appEventsQueueID);
            <strong class="hl-keyword">if</strong> (app_metrologyData.queueFree)
            {
                RTC_TimeGet(&amp;newEvent.eventTime);
                DRV_METROLOGY_GetEventsData(&amp;newEvent.eventFlags);
                xQueueSend(appEventsQueueID, &amp;newEvent, (TickType_t) <span class="hl-number">0</span>);
            }
            <strong class="hl-keyword">else</strong>
            {
                SYS_CMD_MESSAGE(<span class="hl-string">"EVENTS Queue is FULL!!!\n\r"</span>);
            }
            
            <strong class="hl-keyword">break</strong>;
        }

        <em class="hl-comment">/* The default state should never be executed. */</em>
        <strong class="hl-keyword">case</strong> APP_METROLOGY_STATE_ERROR:
        <strong class="hl-keyword">default</strong>:
        {
            <em class="hl-comment">/* TODO: Handle error in application's state machine. */</em>
            <strong class="hl-keyword">break</strong>;
        }
    }
}</pre></div>
<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="GUID-2023FB1C-E7E7-4813-9BA3-480FEB57627B.html">Metrology Driver</a></div>
</div>
</div></body>
</html>